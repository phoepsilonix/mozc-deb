diff --git a/scripts/README.md b/scripts/README.md
new file mode 100644
index 0000000..599c6eb
--- /dev/null
+++ b/scripts/README.md
@@ -0,0 +1,6 @@
+The scripts under this directory are only served as a reference about how the
+files is suppose to be installed. The actual path is different on distribution
+and distribution packagers is suppose to write their own version of install
+script.
+
+There is no guranantee that these scripts work for everyone and everywhere.
diff --git a/scripts/build b/scripts/build
new file mode 100755
index 0000000..b21022f
--- /dev/null
+++ b/scripts/build
@@ -0,0 +1,6 @@
+#!/bin/sh
+
+TARGETS="server/server.gyp:mozc_server gui/gui.gyp:mozc_tool unix/fcitx/fcitx.gyp:fcitx-mozc"
+_bldtype="${_bldtype:-Debug}"
+
+python build_mozc.py build ${TARGETS} -c ${_bldtype}
diff --git a/scripts/build_fcitx5 b/scripts/build_fcitx5
new file mode 100755
index 0000000..829e5c6
--- /dev/null
+++ b/scripts/build_fcitx5
@@ -0,0 +1,6 @@
+#!/bin/sh
+
+_BUILD_TARGETS="${_BUILD_TARGETS:-server/server.gyp:mozc_server gui/gui.gyp:mozc_tool unix/fcitx5/fcitx5.gyp:fcitx5-mozc}"
+_bldtype="${_bldtype:-Debug}"
+
+python build_mozc.py build ${_BUILD_TARGETS} -c ${_bldtype}
diff --git a/scripts/build_fcitx5_bazel b/scripts/build_fcitx5_bazel
new file mode 100755
index 0000000..f7946af
--- /dev/null
+++ b/scripts/build_fcitx5_bazel
@@ -0,0 +1,5 @@
+#!/bin/sh
+
+_BUILD_TARGETS="${_BUILD_TARGETS:-unix/fcitx5:fcitx5-mozc.so server:mozc_server gui/tool:mozc_tool}"
+
+bazel build -c opt --copt=-fPIC --config oss_linux --define server=1 "$@" $_BUILD_TARGETS
diff --git a/scripts/build_fcitx_bazel b/scripts/build_fcitx_bazel
new file mode 100755
index 0000000..c68e9e6
--- /dev/null
+++ b/scripts/build_fcitx_bazel
@@ -0,0 +1,5 @@
+#!/bin/sh
+
+_BUILD_TARGETS="${_BUILD_TARGETS:-unix/fcitx:fcitx-mozc.so server:mozc_server gui/tool:mozc_tool}"
+
+bazel build -c opt --copt=-fPIC  --config oss_linux "$@" $_BUILD_TARGETS
diff --git a/scripts/clang-format.sh b/scripts/clang-format.sh
new file mode 100755
index 0000000..1b574d5
--- /dev/null
+++ b/scripts/clang-format.sh
@@ -0,0 +1,2 @@
+#!/bin/sh
+find unix/fcitx5  -name '*.h' -o -name '*.cc'  | xargs clang-format -style=Google -i
diff --git a/scripts/configure b/scripts/configure
new file mode 100755
index 0000000..1775d81
--- /dev/null
+++ b/scripts/configure
@@ -0,0 +1,2 @@
+#!/bin/sh
+python build_mozc.py gyp "$@"
diff --git a/scripts/get_mozc_version b/scripts/get_mozc_version
new file mode 100755
index 0000000..bb71ac0
--- /dev/null
+++ b/scripts/get_mozc_version
@@ -0,0 +1,4 @@
+#!/bin/sh
+set -e
+bazel build --config oss_linux base:mozc_version_txt >/dev/null 2>&1
+python3 -c 'from build_tools.mozc_version import MozcVersion; print(MozcVersion("bazel-bin/base/mozc_version.txt").GetVersionString())'
diff --git a/scripts/install_fcitx b/scripts/install_fcitx
new file mode 100755
index 0000000..493f1e1
--- /dev/null
+++ b/scripts/install_fcitx
@@ -0,0 +1,27 @@
+#!/bin/sh
+
+_bldtype="${_bldtype:-Debug}"
+PREFIX="${PREFIX:-/usr}"
+
+for mofile in out_linux/${_bldtype}/gen/unix/fcitx/po/*.mo
+do
+    filename=`basename $mofile`
+    lang=${filename/.mo/}
+    install -D -m 644 "$mofile" "${PREFIX}/share/locale/$lang/LC_MESSAGES/fcitx-mozc.mo"
+done
+
+install -D -m 755 "out_linux/${_bldtype}/fcitx-mozc.so" "${PREFIX}/lib/fcitx/fcitx-mozc.so"
+install -D -m 644 unix/fcitx/fcitx-mozc.conf "${PREFIX}/share/fcitx/addon/fcitx-mozc.conf"
+install -D -m 644 unix/fcitx/mozc.conf "${PREFIX}/share/fcitx/inputmethod/mozc.conf"
+
+install -d "${PREFIX}/share/fcitx/mozc/icon"
+install -D -m 644 data/images/product_icon_32bpp-128.png "${PREFIX}/share/fcitx/mozc/icon/mozc.png"
+install -D -m 644 ../scripts/icons/ui-alpha_full.png "${PREFIX}/share/fcitx/mozc/icon/mozc-alpha_full.png"
+install -D -m 644 ../scripts/icons/ui-alpha_half.png "${PREFIX}/share/fcitx/mozc/icon/mozc-alpha_half.png"
+install -D -m 644 ../scripts/icons/ui-direct.png "${PREFIX}/share/fcitx/mozc/icon/mozc-direct.png"
+install -D -m 644 ../scripts/icons/ui-hiragana.png "${PREFIX}/share/fcitx/mozc/icon/mozc-hiragana.png"
+install -D -m 644 ../scripts/icons/ui-katakana_full.png "${PREFIX}/share/fcitx/mozc/icon/mozc-katakana_full.png"
+install -D -m 644 ../scripts/icons/ui-katakana_half.png "${PREFIX}/share/fcitx/mozc/icon/mozc-katakana_half.png"
+install -D -m 644 ../scripts/icons/ui-dictionary.png "${PREFIX}/share/fcitx/mozc/icon/mozc-dictionary.png"
+install -D -m 644 ../scripts/icons/ui-properties.png "${PREFIX}/share/fcitx/mozc/icon/mozc-properties.png"
+install -D -m 644 ../scripts/icons/ui-tool.png "${PREFIX}/share/fcitx/mozc/icon/mozc-tool.png"
diff --git a/scripts/install_fcitx5 b/scripts/install_fcitx5
new file mode 100755
index 0000000..8d85f30
--- /dev/null
+++ b/scripts/install_fcitx5
@@ -0,0 +1,9 @@
+#!/bin/sh
+
+_bldtype="${_bldtype:-Debug}"
+PREFIX="${PREFIX:-/usr}"
+
+install -D -m 755 "out_linux/${_bldtype}/fcitx5-mozc.so" "${PREFIX}/lib/fcitx5/fcitx5-mozc.so"
+
+PREFIX="${PREFIX}" ../scripts/install_fcitx5_data
+PREFIX="${PREFIX}" ../scripts/install_fcitx5_icons
diff --git a/scripts/install_fcitx5_bazel b/scripts/install_fcitx5_bazel
new file mode 100755
index 0000000..629bb75
--- /dev/null
+++ b/scripts/install_fcitx5_bazel
@@ -0,0 +1,7 @@
+#!/bin/sh
+PREFIX="${PREFIX:-/usr}"
+
+install -D -m 755 "bazel-bin/unix/fcitx5/fcitx5-mozc.so" "${PREFIX}/lib/fcitx5/fcitx5-mozc.so"
+
+PREFIX="${PREFIX}" ../scripts/install_fcitx5_data
+PREFIX="${PREFIX}" ../scripts/install_fcitx5_icons
diff --git a/scripts/install_fcitx5_data b/scripts/install_fcitx5_data
new file mode 100755
index 0000000..aa05874
--- /dev/null
+++ b/scripts/install_fcitx5_data
@@ -0,0 +1,22 @@
+#!/bin/bash
+
+PREFIX="${PREFIX:-/usr}"
+
+for pofile in unix/fcitx5/po/*.po
+do
+    filename=`basename $pofile`
+    lang=${filename/.po/}
+    mofile=${pofile/.po/.mo}
+    msgfmt $pofile -o $mofile
+    install -D -m 644 "$mofile" "${PREFIX}/share/locale/$lang/LC_MESSAGES/fcitx5-mozc.mo"
+    rm -f $mofile
+done
+
+install -D -m 644 unix/fcitx5/mozc-addon.conf "${PREFIX}/share/fcitx5/addon/mozc.conf"
+install -D -m 644 unix/fcitx5/mozc.conf "${PREFIX}/share/fcitx5/inputmethod/mozc.conf"
+
+PREFIX="${PREFIX}" ../scripts/install_fcitx5_icons
+
+msgfmt --xml -d unix/fcitx5/po/ --template unix/fcitx5/org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in -o unix/fcitx5/org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml
+install -Dm644 unix/fcitx5/org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml "${PREFIX}/share/metainfo/org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml"
+rm -f unix/fcitx5/org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml
diff --git a/scripts/install_fcitx5_icons b/scripts/install_fcitx5_icons
new file mode 100755
index 0000000..e8f101b
--- /dev/null
+++ b/scripts/install_fcitx5_icons
@@ -0,0 +1,27 @@
+#!/bin/sh
+
+PREFIX="${PREFIX:-/usr}"
+
+install -D -m 644 data/images/product_icon_32bpp-128.png "${PREFIX}/share/icons/hicolor/128x128/apps/org.fcitx.Fcitx5.fcitx_mozc.png"
+install -D -m 644 data/images/unix/ime_product_icon_opensource-32.png "${PREFIX}/share/icons/hicolor/32x32/apps/org.fcitx.Fcitx5.fcitx_mozc.png"
+install -D -m 644 ../scripts/icons/ui-alpha_full.png "${PREFIX}/share/icons/hicolor/48x48/apps/org.fcitx.Fcitx5.fcitx_mozc_alpha_full.png"
+install -D -m 644 ../scripts/icons/ui-alpha_half.png "${PREFIX}/share/icons/hicolor/48x48/apps/org.fcitx.Fcitx5.fcitx_mozc_alpha_half.png"
+install -D -m 644 ../scripts/icons/ui-direct.png "${PREFIX}/share/icons/hicolor/48x48/apps/org.fcitx.Fcitx5.fcitx_mozc_direct.png"
+install -D -m 644 ../scripts/icons/ui-hiragana.png "${PREFIX}/share/icons/hicolor/48x48/apps/org.fcitx.Fcitx5.fcitx_mozc_hiragana.png"
+install -D -m 644 ../scripts/icons/ui-katakana_full.png "${PREFIX}/share/icons/hicolor/48x48/apps/org.fcitx.Fcitx5.fcitx_mozc_katakana_full.png"
+install -D -m 644 ../scripts/icons/ui-katakana_half.png "${PREFIX}/share/icons/hicolor/48x48/apps/org.fcitx.Fcitx5.fcitx_mozc_katakana_half.png"
+install -D -m 644 ../scripts/icons/ui-dictionary.png "${PREFIX}/share/icons/hicolor/48x48/apps/org.fcitx.Fcitx5.fcitx_mozc_dictionary.png"
+install -D -m 644 ../scripts/icons/ui-properties.png "${PREFIX}/share/icons/hicolor/48x48/apps/org.fcitx.Fcitx5.fcitx_mozc_properties.png"
+install -D -m 644 ../scripts/icons/ui-tool.png "${PREFIX}/share/icons/hicolor/48x48/apps/org.fcitx.Fcitx5.fcitx_mozc_tool.png"
+
+ln -sf org.fcitx.Fcitx5.fcitx_mozc.png "${PREFIX}/share/icons/hicolor/128x128/apps/fcitx_mozc.png"
+ln -sf org.fcitx.Fcitx5.fcitx_mozc.png "${PREFIX}/share/icons/hicolor/32x32/apps/fcitx_mozc.png"
+ln -sf org.fcitx.Fcitx5.fcitx_mozc_alpha_full.png "${PREFIX}/share/icons/hicolor/48x48/apps/fcitx_mozc_alpha_full.png"
+ln -sf org.fcitx.Fcitx5.fcitx_mozc_alpha_half.png "${PREFIX}/share/icons/hicolor/48x48/apps/fcitx_mozc_alpha_half.png"
+ln -sf org.fcitx.Fcitx5.fcitx_mozc_direct.png "${PREFIX}/share/icons/hicolor/48x48/apps/fcitx_mozc_direct.png"
+ln -sf org.fcitx.Fcitx5.fcitx_mozc_hiragana.png "${PREFIX}/share/icons/hicolor/48x48/apps/fcitx_mozc_hiragana.png"
+ln -sf org.fcitx.Fcitx5.fcitx_mozc_katakana_full.png "${PREFIX}/share/icons/hicolor/48x48/apps/fcitx_mozc_katakana_full.png"
+ln -sf org.fcitx.Fcitx5.fcitx_mozc_katakana_half.png "${PREFIX}/share/icons/hicolor/48x48/apps/fcitx_mozc_katakana_half.png"
+ln -sf org.fcitx.Fcitx5.fcitx_mozc_dictionary.png "${PREFIX}/share/icons/hicolor/48x48/apps/fcitx_mozc_dictionary.png"
+ln -sf org.fcitx.Fcitx5.fcitx_mozc_properties.png "${PREFIX}/share/icons/hicolor/48x48/apps/fcitx_mozc_properties.png"
+ln -sf org.fcitx.Fcitx5.fcitx_mozc_tool.png "${PREFIX}/share/icons/hicolor/48x48/apps/fcitx_mozc_tool.png"
diff --git a/scripts/install_fcitx_bazel b/scripts/install_fcitx_bazel
new file mode 100755
index 0000000..0c72e8d
--- /dev/null
+++ b/scripts/install_fcitx_bazel
@@ -0,0 +1,30 @@
+#!/bin/sh
+
+_bldtype="${_bldtype:-Debug}"
+PREFIX="${PREFIX:-/usr}"
+
+for pofile in unix/fcitx/po/*.po
+do
+  filename=`basename $pofile`
+  lang=${filename/.po/}
+  mofile=${pofile/.po/.mo}
+  msgfmt $pofile -o $mofile
+  install -D -m 644 "$mofile" "${PREFIX}/share/locale/$lang/LC_MESSAGES/fcitx-mozc.mo"
+  rm -f $mofile
+done
+
+install -D -m 755 "bazel-bin/unix/fcitx/fcitx-mozc.so" "${PREFIX}/lib/fcitx/fcitx-mozc.so"
+install -D -m 644 unix/fcitx/fcitx-mozc.conf "${PREFIX}/share/fcitx/addon/fcitx-mozc.conf"
+install -D -m 644 unix/fcitx/mozc.conf "${PREFIX}/share/fcitx/inputmethod/mozc.conf"
+
+install -d "${PREFIX}/share/fcitx/mozc/icon"
+install -D -m 644 data/images/product_icon_32bpp-128.png "${PREFIX}/share/fcitx/mozc/icon/mozc.png"
+install -D -m 644 ../scripts/icons/ui-alpha_full.png "${PREFIX}/share/fcitx/mozc/icon/mozc-alpha_full.png"
+install -D -m 644 ../scripts/icons/ui-alpha_half.png "${PREFIX}/share/fcitx/mozc/icon/mozc-alpha_half.png"
+install -D -m 644 ../scripts/icons/ui-direct.png "${PREFIX}/share/fcitx/mozc/icon/mozc-direct.png"
+install -D -m 644 ../scripts/icons/ui-hiragana.png "${PREFIX}/share/fcitx/mozc/icon/mozc-hiragana.png"
+install -D -m 644 ../scripts/icons/ui-katakana_full.png "${PREFIX}/share/fcitx/mozc/icon/mozc-katakana_full.png"
+install -D -m 644 ../scripts/icons/ui-katakana_half.png "${PREFIX}/share/fcitx/mozc/icon/mozc-katakana_half.png"
+install -D -m 644 ../scripts/icons/ui-dictionary.png "${PREFIX}/share/fcitx/mozc/icon/mozc-dictionary.png"
+install -D -m 644 ../scripts/icons/ui-properties.png "${PREFIX}/share/fcitx/mozc/icon/mozc-properties.png"
+install -D -m 644 ../scripts/icons/ui-tool.png "${PREFIX}/share/fcitx/mozc/icon/mozc-tool.png"
diff --git a/scripts/install_server b/scripts/install_server
new file mode 100755
index 0000000..726a42f
--- /dev/null
+++ b/scripts/install_server
@@ -0,0 +1,9 @@
+#!/bin/sh
+
+_bldtype=${_bldtype:-Debug}
+PREFIX="${PREFIX:-/usr}"
+
+install -D -m 755 "out_linux/${_bldtype}/mozc_server" "${PREFIX}/lib/mozc/mozc_server"
+install -D -m 755 "out_linux/${_bldtype}/mozc_tool"   "${PREFIX}/lib/mozc/mozc_tool"
+install -d "${PREFIX}/share/doc/mozc/"
+install -m 644 data/installer/*.html "${PREFIX}/share/doc/mozc/"
diff --git a/scripts/install_server_bazel b/scripts/install_server_bazel
new file mode 100755
index 0000000..c567825
--- /dev/null
+++ b/scripts/install_server_bazel
@@ -0,0 +1,8 @@
+#!/bin/sh
+
+PREFIX="${PREFIX:-/usr}"
+
+install -D -m 755 "bazel-bin/server/mozc_server" "${PREFIX}/lib/mozc/mozc_server"
+install -D -m 755 "bazel-bin/gui/tool/mozc_tool"   "${PREFIX}/lib/mozc/mozc_tool"
+install -d "${PREFIX}/share/doc/mozc/"
+install -m 644 data/installer/*.html "${PREFIX}/share/doc/mozc/"
diff --git a/scripts/update_fcitx5_metainfo b/scripts/update_fcitx5_metainfo
new file mode 100755
index 0000000..978dc8e
--- /dev/null
+++ b/scripts/update_fcitx5_metainfo
@@ -0,0 +1,17 @@
+#!/bin/sh
+
+set -e
+MOZC_VERSION=`../scripts/get_mozc_version`
+
+if [ "$?" != 0 -o -z MOZC_VERSION ]; then
+    echo "Failed to get mozc version"
+    exit 1
+fi
+
+xq -e --arg MOZC_VERSION "$MOZC_VERSION" '.component.releases.release[] | select(."@version" == $MOZC_VERSION)'  unix/fcitx5/org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in && exit 1
+
+DATE=`date +%Y-%m-%d`
+
+xq -x --xml-dtd --arg MOZC_VERSION "$MOZC_VERSION" --arg DATE "$DATE" '.component.releases.release |= [{"@version": $MOZC_VERSION, "@date": $DATE}] + .' unix/fcitx5/org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in > unix/fcitx5/org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in.new
+
+mv unix/fcitx5/org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in{.new,}
diff --git a/src/BUILD.fcitx.bazel b/src/BUILD.fcitx.bazel
new file mode 100644
index 0000000..86c9958
--- /dev/null
+++ b/src/BUILD.fcitx.bazel
@@ -0,0 +1,27 @@
+package(
+    default_visibility = ["//visibility:public"],
+)
+
+# This rule is created from pkg-config
+#
+# packages="fcitx"
+# copts, hdrs, indludes: pkg-config --cflags $packages
+# linkopts: pkg-config --libs-only-l $packages
+
+cc_library(
+    name = "fcitx",
+    hdrs = glob([
+        "include/fcitx/**",
+        "include/fcitx-config/**",
+        "include/fcitx-utils/**",
+    ]),
+    copts = ["-pthread"],
+    includes = [
+        "include",
+    ],
+    linkopts = [
+        "-lfcitx-core",
+        "-lfcitx-config",
+        "-lfcitx-utils",
+    ],
+)
diff --git a/src/MODULE.bazel b/src/MODULE.bazel
index 3ab80dc..37b3f8d 100644
--- a/src/MODULE.bazel
+++ b/src/MODULE.bazel
@@ -189,6 +189,23 @@ pkg_config_repository(
     ],
 )
 
+# Fcitx
+new_local_repository(
+    name = "fcitx",
+    build_file = "BUILD.fcitx.bazel",
+    # This path should be updated per the environment.
+    path = "/usr",  # For Debian
+)
+
+# Fcitx 5
+pkg_config_repository(
+    name = "fcitx5",
+    packages = [
+        "Fcitx5Core",
+        "Fcitx5Module",
+    ],
+)
+
 # Qt for Linux
 pkg_config_repository(
     name = "qt_linux",
diff --git a/src/base/BUILD.bazel b/src/base/BUILD.bazel
index e20f9e5..ee9345d 100644
--- a/src/base/BUILD.bazel
+++ b/src/base/BUILD.bazel
@@ -1142,3 +1142,10 @@ mozc_cc_test(
         "@com_google_absl//absl/strings:string_view",
     ],
 )
+
+# TODO(b/397718233): Remove this library once Abseil LTS supports absl_nullable.
+mozc_cc_library(
+    name = "absl_nullability",
+    hdrs = ["absl_nullability.h"],
+    deps = ["@com_google_absl//absl/base:nullability"],
+)
diff --git a/src/base/absl_nullability.h b/src/base/absl_nullability.h
new file mode 100644
index 0000000..026f9aa
--- /dev/null
+++ b/src/base/absl_nullability.h
@@ -0,0 +1,43 @@
+// Copyright 2010-2021, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MOZC_BASE_ABSL_NULLABILITY_H_
+#define MOZC_BASE_ABSL_NULLABILITY_H_
+
+#include "absl/base/nullability.h"  // IWYU pragma: export
+
+// This is for backward compatibility with the Abseil LTS version 20250127.1.
+// TODO(b/397718233): Remove this once the latest LTS version supports lower
+// case macros.
+#ifndef absl_nullable
+#define absl_nullable ABSL_NULLABLE
+#define absl_nonnull ABSL_NONNULL
+#endif  // absl_nullable
+
+#endif  // MOZC_BASE_ABSL_NULLABILITY_H_
diff --git a/src/base/clock.cc b/src/base/clock.cc
index 28eac4c..f53e176 100644
--- a/src/base/clock.cc
+++ b/src/base/clock.cc
@@ -33,21 +33,15 @@
 #include "absl/time/time.h"
 #include "base/singleton.h"
 
-#if !(defined(OS_CHROMEOS) || defined(_WIN32))
-#define MOZC_USE_ABSL_TIME_ZONE
-#endif  // !(defined(OS_CHROMEOS) || defined(_WIN32))
-
-#ifndef MOZC_USE_ABSL_TIME_ZONE
+#if defined(OS_CHROMEOS) || defined(_WIN32)
 #include <ctime>
-#endif  // MOZC_USE_ABSL_TIME_ZONE
+#endif  // defined(OS_CHROMEOS) || defined(_WIN32)
 
 namespace mozc {
 namespace {
 
 absl::TimeZone GetLocalTimeZone() {
-#ifdef MOZC_USE_ABSL_TIME_ZONE
-  return absl::LocalTimeZone();
-#else  // MOZC_USE_ABSL_TIME_ZONE
+#if defined(OS_CHROMEOS) || defined(_WIN32)
   // Do not use absl::LocalTimeZone() here because
   // - on Chrome OS, it returns UTC: b/196271425
   // - on Windows, it crashes: https://github.com/google/mozc/issues/856
@@ -60,7 +54,9 @@ absl::TimeZone GetLocalTimeZone() {
       (offset->tm_mday - 2) * 24 * 60 * 60  // date offset from Jan 2.
       + offset->tm_hour * 60 * 60           // hour offset from 00 am.
       + offset->tm_min * 60);               // minute offset.
-#endif  // MOZC_USE_ABSL_TIME_ZONE
+#else   // !defined(OS_CHROMEOS) && !defined(_WIN32)
+  return absl::LocalTimeZone();
+#endif  // defined(OS_CHROMEOS) || defined(_WIN32)
 }
 
 class ClockImpl : public ClockInterface {
@@ -70,7 +66,10 @@ class ClockImpl : public ClockInterface {
 
   absl::Time GetAbslTime() override { return absl::Now(); }
 
-  absl::TimeZone GetTimeZone() override { return GetLocalTimeZone(); }
+  absl::TimeZone GetTimeZone() override { return timezone_; }
+
+ private:
+  const absl::TimeZone timezone_ = GetLocalTimeZone();
 };
 }  // namespace
 
diff --git a/src/base/container/BUILD.bazel b/src/base/container/BUILD.bazel
index e50368b..5a83654 100644
--- a/src/base/container/BUILD.bazel
+++ b/src/base/container/BUILD.bazel
@@ -67,7 +67,7 @@ mozc_cc_library(
     hdrs = ["flat_map.h"],
     deps = [
         ":flat_internal",
-        "@com_google_absl//absl/base:nullability",
+        "//base:absl_nullability",
         "@com_google_absl//absl/types:span",
     ],
 )
@@ -124,9 +124,7 @@ mozc_cc_library(
     name = "freelist",
     hdrs = ["freelist.h"],
     visibility = ["//:__subpackages__"],
-    deps = [
-        "@com_google_absl//absl/base:nullability",
-    ],
+    deps = ["//base:absl_nullability"],
 )
 
 mozc_cc_test(
diff --git a/src/base/container/flat_map.h b/src/base/container/flat_map.h
index f386953..2b4a0e0 100644
--- a/src/base/container/flat_map.h
+++ b/src/base/container/flat_map.h
@@ -37,8 +37,8 @@
 #include <functional>
 #include <utility>
 
-#include "absl/base/nullability.h"
 #include "absl/types/span.h"
+#include "base/absl_nullability.h"
 #include "base/container/flat_internal.h"
 
 namespace mozc {
diff --git a/src/base/container/freelist.h b/src/base/container/freelist.h
index 6dcb2cb..ca07c38 100644
--- a/src/base/container/freelist.h
+++ b/src/base/container/freelist.h
@@ -37,7 +37,7 @@
 #include <utility>
 #include <vector>
 
-#include "absl/base/nullability.h"
+#include "base/absl_nullability.h"
 
 namespace mozc {
 
diff --git a/src/base/strings/BUILD.bazel b/src/base/strings/BUILD.bazel
index 0c6c02b..ce9894b 100644
--- a/src/base/strings/BUILD.bazel
+++ b/src/base/strings/BUILD.bazel
@@ -80,8 +80,8 @@ mozc_cc_library(
     hdrs = ["zstring_view.h"],
     deps = [
         ":pfchar",
+        "//base:absl_nullability",
         "@com_google_absl//absl/base:core_headers",
-        "@com_google_absl//absl/base:nullability",
         "@com_google_absl//absl/log:check",
         "@com_google_absl//absl/strings",
     ],
@@ -135,9 +135,9 @@ mozc_cc_library(
     srcs = ["unicode.cc"],
     hdrs = ["unicode.h"],
     deps = [
+        "//base:absl_nullability",
         "//base/strings/internal:utf8_internal",
         "@com_google_absl//absl/base:core_headers",
-        "@com_google_absl//absl/base:nullability",
         "@com_google_absl//absl/log:check",
         "@com_google_absl//absl/strings",
     ],
diff --git a/src/base/strings/unicode.h b/src/base/strings/unicode.h
index f04c6b2..587c552 100644
--- a/src/base/strings/unicode.h
+++ b/src/base/strings/unicode.h
@@ -41,10 +41,10 @@
 #include <utility>
 
 #include "absl/base/attributes.h"
-#include "absl/base/nullability.h"
 #include "absl/base/optimization.h"
 #include "absl/log/check.h"
 #include "absl/strings/string_view.h"
+#include "base/absl_nullability.h"
 #include "base/strings/internal/utf8_internal.h"
 
 namespace mozc {
diff --git a/src/base/strings/zstring_view.h b/src/base/strings/zstring_view.h
index 0edd7dd..dbb7500 100644
--- a/src/base/strings/zstring_view.h
+++ b/src/base/strings/zstring_view.h
@@ -39,10 +39,10 @@
 #include <string_view>
 
 #include "absl/base/attributes.h"
-#include "absl/base/nullability.h"
 #include "absl/log/check.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
+#include "base/absl_nullability.h"
 #include "base/strings/pfchar.h"
 
 namespace mozc {
diff --git a/src/build_mozc.py b/src/build_mozc.py
index 6e17812..3efd3af 100755
--- a/src/build_mozc.py
+++ b/src/build_mozc.py
@@ -164,6 +164,8 @@ def GetGypFileNames(options):
     gyp_file_names.extend(glob.glob('%s/win32/*/*.gyp' % OSS_SRC_DIR))
   elif options.target_platform == 'Linux':
     gyp_file_names.extend(glob.glob('%s/unix/emacs/*.gyp' % OSS_SRC_DIR))
+    gyp_file_names.extend(glob.glob('%s/unix/fcitx/*.gyp' % OSS_SRC_DIR))
+    gyp_file_names.extend(glob.glob('%s/unix/fcitx5/*.gyp' % OSS_SRC_DIR))
   gyp_file_names.sort()
   return gyp_file_names
 
diff --git a/src/converter/BUILD.bazel b/src/converter/BUILD.bazel
index 36d4955..1c62e91 100644
--- a/src/converter/BUILD.bazel
+++ b/src/converter/BUILD.bazel
@@ -216,13 +216,13 @@ mozc_cc_library(
         ":node",
         ":segmenter",
         ":segments",
+        "//base:absl_nullability",
         "//base:vlog",
         "//base/container:freelist",
         "//dictionary:dictionary_interface",
         "//dictionary:pos_matcher",
         "//prediction:suggestion_filter",
         "//request:conversion_request",
-        "@com_google_absl//absl/base:nullability",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/log:check",
         "@com_google_absl//absl/strings",
diff --git a/src/converter/converter.cc b/src/converter/converter.cc
index f6998dc..3601af5 100644
--- a/src/converter/converter.cc
+++ b/src/converter/converter.cc
@@ -745,17 +745,13 @@ bool Converter::PredictForRequestWithSegments(const ConversionRequest &request,
           Candidate::DecodeLengths(result.inner_segment_boundary.back());
       const int function_key_len = key_len - content_key_len;
       const int function_value_len = value_len - content_value_len;
-      const int content_key_start =
-          candidate->content_key.size() - function_key_len;
-      const int content_value_start =
-          candidate->content_value.size() - function_value_len;
-      if (function_key_len > 0 && content_key_start > 0 &&
+      if (function_key_len > 0 &&
           function_key_len <= candidate->content_key.size()) {
-        candidate->content_key.erase(content_key_start, function_key_len);
+        candidate->content_key.erase(content_key_len, function_key_len);
       }
-      if (function_value_len > 0 && content_value_start > 0 &&
+      if (function_value_len > 0 &&
           function_value_len <= candidate->content_value.size()) {
-        candidate->content_value.erase(content_value_start, function_value_len);
+        candidate->content_value.erase(content_value_len, function_value_len);
       }
     }
 #ifndef NDEBUG
diff --git a/src/converter/converter.gyp b/src/converter/converter.gyp
index 16948e0..a422d11 100644
--- a/src/converter/converter.gyp
+++ b/src/converter/converter.gyp
@@ -46,7 +46,7 @@
         '<(mozc_oss_src_dir)/base/absl.gyp:absl_strings',
         '<(mozc_oss_src_dir)/base/base.gyp:number_util',
         '<(mozc_oss_src_dir)/composer/composer.gyp:composer',
-        '<(mozc_oss_src_dir)/dictionary/pos_matcher.gyp:pos_matcher',
+        '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:pos_matcher',
         '<(mozc_oss_src_dir)/prediction/prediction.gyp:prediction',
         '<(mozc_oss_src_dir)/prediction/prediction.gyp:prediction_protocol',
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:commands_proto',
@@ -58,7 +58,7 @@
         'immutable_converter.gyp:immutable_converter',
       ],
       'export_dependent_settings': [
-        '<(mozc_oss_src_dir)/dictionary/pos_matcher.gyp:pos_matcher',
+        '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:pos_matcher',
       ],
     },
   ],
diff --git a/src/converter/converter_base.gyp b/src/converter/converter_base.gyp
index 80a53d2..46bebb9 100644
--- a/src/converter/converter_base.gyp
+++ b/src/converter/converter_base.gyp
@@ -97,7 +97,6 @@
         '<(mozc_oss_src_dir)/base/absl.gyp:absl_log',
         '<(mozc_oss_src_dir)/base/absl.gyp:absl_strings',
         '<(mozc_oss_src_dir)/base/base.gyp:base',
-        '<(mozc_oss_src_dir)/dictionary/pos_matcher.gyp:pos_matcher',
         '<(mozc_oss_src_dir)/prediction/prediction_base.gyp:suggestion_filter',
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:commands_proto',
         '<(mozc_oss_src_dir)/transliteration/transliteration.gyp:transliteration',
diff --git a/src/converter/converter_main.cc b/src/converter/converter_main.cc
index 7ff1978..f47a649 100644
--- a/src/converter/converter_main.cc
+++ b/src/converter/converter_main.cc
@@ -104,13 +104,6 @@ namespace {
 
 using ::mozc::converter::Candidate;
 
-int FindCandidate(const Segment &segment, absl::string_view value) {
-  for (int i = 0; i < segment.candidates_size(); ++i) {
-    if (segment.candidate(i).value == value) return i;
-  }
-  return -1;
-}
-
 // Wrapper class for pos id printing
 class PosIdPrintUtil {
  public:
@@ -448,36 +441,6 @@ bool ExecCommand(const ConverterInterface &converter, const std::string &line,
     config->set_history_learning_level(config::Config::NO_HISTORY);
   } else if (func == "enableuserhistory") {
     config->set_history_learning_level(config::Config::DEFAULT_HISTORY);
-  } else if (func == "zeroquerysuggest" || func == "z") {
-    CHECK_FIELDS_LENGTH(3);  // command history_key history_value
-    if (!ExecCommand(converter, "reset", request, config, segments)) {
-      LOG(ERROR) << "Reset failed";
-      return false;
-    }
-    if (!ExecCommand(converter, absl::StrFormat("predict %s", fields[1]),
-                     request, config, segments)) {
-      LOG(ERROR) << "Predict failed for context key " << fields[1];
-      return false;
-    }
-    const int index = FindCandidate(segments->conversion_segment(0), fields[2]);
-    if (index == -1) {
-      LOG(ERROR) << "Cannot find candidate " << fields[2];
-      return false;
-    }
-    if (!ExecCommand(converter, absl::StrFormat("commit 0 %d", index), request,
-                     config, segments)) {
-      LOG(ERROR) << "commit failed";
-      return false;
-    }
-    if (!ExecCommand(converter, "finish", request, config, segments)) {
-      LOG(ERROR) << "finish failed";
-      return false;
-    }
-    if (!ExecCommand(converter, "predict", request, config, segments)) {
-      LOG(ERROR) << "predict from zero query failed";
-      return false;
-    }
-    return true;
   } else {
     LOG(WARNING) << "Unknown command: " << func;
     return false;
diff --git a/src/converter/converter_test.cc b/src/converter/converter_test.cc
index 3e022e6..2e1c28c 100644
--- a/src/converter/converter_test.cc
+++ b/src/converter/converter_test.cc
@@ -115,7 +115,6 @@ using ::mozc::prediction::Result;
 using ::mozc::prediction::UserHistoryPredictor;
 using ::testing::_;
 using ::testing::AnyNumber;
-using ::testing::Return;
 using ::testing::StrEq;
 
 using UserEntry = user_dictionary::UserDictionary::Entry;
@@ -2447,69 +2446,5 @@ TEST_F(ConverterTest, MakeLearningResultsTest) {
   }
 }
 
-TEST_F(ConverterTest, Bugfix424676259) {
-  auto mock_predictor = absl::make_unique<MockPredictor>();
-  auto mock_rewriter = absl::make_unique<MockRewriter>();
-
-  std::vector<prediction::Result> results;
-
-  prediction::Result result;
-  result.key = "3:30から";
-  result.value = "３：３０から";
-
-  // 3|:|30から
-  result.inner_segment_boundary.push_back(
-      converter::Candidate::EncodeLengths(1, 3, 1, 3));  // 3
-  result.inner_segment_boundary.push_back(
-      converter::Candidate::EncodeLengths(1, 3, 1, 3));  // :
-  result.inner_segment_boundary.push_back(
-      converter::Candidate::EncodeLengths(8, 12, 2, 6));  // ３０_から
-
-  results.emplace_back(std::move(result));
-
-  EXPECT_CALL(*mock_predictor, Predict(_)).WillRepeatedly(Return(results));
-
-  std::unique_ptr<engine::Modules> modules =
-      engine::Modules::Create(std::make_unique<testing::MockDataManager>())
-          .value();
-
-  auto converter = std::make_unique<Converter>(
-      std::move(modules),
-      [](const engine::Modules &modules) {
-        return std::make_unique<ImmutableConverter>(modules);
-      },
-      [&mock_predictor](
-          const engine::Modules &modules, const ConverterInterface &converter,
-          const ImmutableConverterInterface &immutable_converter) {
-        return std::move(mock_predictor);
-      },
-      [&mock_rewriter](const engine::Modules &modules) {
-        return std::move(mock_rewriter);
-      });
-
-  commands::Request request;
-  request.set_mixed_conversion(true);
-  const ConversionRequest convreq =
-      ConversionRequestBuilder()
-          .SetRequestView(request)
-          .SetRequestType(ConversionRequest::SUGGESTION)
-          .Build();
-
-  converter::Segments segments;
-  EXPECT_TRUE(converter->StartPrediction(convreq, &segments));
-
-  ASSERT_EQ(segments.segments_size(), 1);
-  const converter::Segment &segment = segments.segment(0);
-  ASSERT_EQ(segment.candidates_size(), 1);
-  const converter::Candidate &candidate = segment.candidate(0);
-
-  EXPECT_EQ(candidate.key, "3:30から");
-  EXPECT_EQ(candidate.value, "３：３０から");
-  EXPECT_EQ(candidate.content_key, "3:30");
-  EXPECT_EQ(candidate.content_value, "３：３０");
-  EXPECT_EQ(candidate.inner_segment_boundary,
-            results[0].inner_segment_boundary);
-}
-
 }  // namespace converter
 }  // namespace mozc
diff --git a/src/converter/immutable_converter.gyp b/src/converter/immutable_converter.gyp
index 0cd7a94..228fc56 100644
--- a/src/converter/immutable_converter.gyp
+++ b/src/converter/immutable_converter.gyp
@@ -47,7 +47,7 @@
         '<(mozc_oss_src_dir)/converter/converter_base.gyp:segmenter',
         '<(mozc_oss_src_dir)/converter/converter_base.gyp:segments',
         '<(mozc_oss_src_dir)/dictionary/dictionary.gyp:suffix_dictionary',
-        '<(mozc_oss_src_dir)/dictionary/pos_matcher.gyp:pos_matcher',
+        '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:pos_matcher',
         '<(mozc_oss_src_dir)/engine/engine_base.gyp:modules',
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:commands_proto',
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:config_proto',
diff --git a/src/converter/nbest_generator.cc b/src/converter/nbest_generator.cc
index f7fca26..c6c2f48 100644
--- a/src/converter/nbest_generator.cc
+++ b/src/converter/nbest_generator.cc
@@ -36,12 +36,12 @@
 #include <string>
 #include <vector>
 
-#include "absl/base/nullability.h"
 #include "absl/log/check.h"
 #include "absl/log/log.h"
 #include "absl/strings/ascii.h"
 #include "absl/strings/string_view.h"
 #include "absl/types/span.h"
+#include "base/absl_nullability.h"
 #include "base/vlog.h"
 #include "converter/candidate.h"
 #include "converter/candidate_filter.h"
diff --git a/src/converter/nbest_generator.h b/src/converter/nbest_generator.h
index d295bb9..680a092 100644
--- a/src/converter/nbest_generator.h
+++ b/src/converter/nbest_generator.h
@@ -34,9 +34,9 @@
 #include <cstdint>
 #include <vector>
 
-#include "absl/base/nullability.h"
 #include "absl/strings/string_view.h"
 #include "absl/types/span.h"
+#include "base/absl_nullability.h"
 #include "base/container/freelist.h"
 #include "converter/candidate.h"
 #include "converter/candidate_filter.h"
diff --git a/src/data_manager/BUILD.bazel b/src/data_manager/BUILD.bazel
index 2f75f44..66bdf10 100644
--- a/src/data_manager/BUILD.bazel
+++ b/src/data_manager/BUILD.bazel
@@ -316,5 +316,8 @@ bzl_library(
 mozc_cc_library(
     name = "emoji_data",
     hdrs = ["emoji_data.h"],
-    visibility = ["//rewriter:__pkg__"],
+    visibility = [
+        "//dictionary:__pkg__",
+        "//rewriter:__pkg__",
+    ],
 )
diff --git a/src/data_manager/data_manager_base.gypi b/src/data_manager/data_manager_base.gypi
index f96e01d..6b9affc 100644
--- a/src/data_manager/data_manager_base.gypi
+++ b/src/data_manager/data_manager_base.gypi
@@ -98,7 +98,7 @@
       'type': 'none',
       'toolsets': ['host'],
       'dependencies': [
-        '<(mozc_oss_src_dir)/dictionary/pos_matcher.gyp:pos_util',
+        '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:pos_util',
       ],
       'actions': [
         {
@@ -143,7 +143,7 @@
       'type': 'none',
       'toolsets': ['host'],
       'dependencies': [
-        '<(mozc_oss_src_dir)/dictionary/pos_matcher.gyp:pos_util',
+        '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:pos_util',
       ],
       'actions': [
         {
diff --git a/src/data_manager/data_manager_test.gyp b/src/data_manager/data_manager_test.gyp
index 8500f87..4e7c7a7 100644
--- a/src/data_manager/data_manager_test.gyp
+++ b/src/data_manager/data_manager_test.gyp
@@ -44,7 +44,7 @@
         '<(mozc_oss_src_dir)/base/base.gyp:base',
         '<(mozc_oss_src_dir)/converter/converter_base.gyp:connector',
         '<(mozc_oss_src_dir)/converter/converter_base.gyp:segmenter',
-        '<(mozc_oss_src_dir)/dictionary/pos_matcher.gyp:pos_matcher',
+        '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:pos_matcher',
         '<(mozc_oss_src_dir)/prediction/prediction_base.gyp:suggestion_filter',
         '<(mozc_oss_src_dir)/testing/testing.gyp:testing',
         'data_manager.gyp:connection_file_reader',
diff --git a/src/dictionary/dictionary.gyp b/src/dictionary/dictionary.gyp
index c80d0cd..cf6cd91 100644
--- a/src/dictionary/dictionary.gyp
+++ b/src/dictionary/dictionary.gyp
@@ -85,7 +85,7 @@
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:commands_proto',
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:config_proto',
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:user_dictionary_storage_proto',
-        'pos_matcher.gyp:pos_matcher',
+        'dictionary_base.gyp:pos_matcher',
       ],
     },
     {
@@ -100,7 +100,7 @@
         '<(mozc_oss_src_dir)/base/absl.gyp:absl_strings',
         '<(mozc_oss_src_dir)/base/base.gyp:base',
         '<(mozc_oss_src_dir)/data_manager/data_manager_base.gyp:data_manager',
-        'pos_matcher.gyp:pos_matcher',
+        'dictionary_base.gyp:pos_matcher',
         'system/system_dictionary.gyp:system_dictionary_builder',
       ],
       'msvs_settings': {
diff --git a/src/dictionary/dictionary_base.gyp b/src/dictionary/dictionary_base.gyp
index 3d60c7c..2b1e9b0 100644
--- a/src/dictionary/dictionary_base.gyp
+++ b/src/dictionary/dictionary_base.gyp
@@ -49,9 +49,60 @@
         '<(mozc_oss_src_dir)/base/base.gyp:base',
         '<(mozc_oss_src_dir)/base/base.gyp:multifile',
         '<(mozc_oss_src_dir)/base/base.gyp:number_util',
-        'pos_matcher.gyp:pos_matcher',
+        'pos_matcher',
       ],
     },
+    {
+      'target_name': 'pos_util',
+      'type': 'none',
+      'toolsets': ['host'],
+      'sources': [
+        '<(mozc_oss_src_dir)/build_tools/code_generator_util.py',
+        'pos_util.py',
+      ],
+    },
+    {
+      'target_name': 'gen_pos_matcher',
+      'type': 'none',
+      'toolsets': ['host'],
+      'dependencies': [
+        'pos_util',
+      ],
+      'actions': [
+        {
+          'action_name': 'gen_pos_matcher',
+          'variables': {
+            'pos_matcher_rule': '<(mozc_oss_src_dir)/data/rules/pos_matcher_rule.def',
+            'pos_matcher_header': '<(gen_out_dir)/pos_matcher_impl.inc',
+          },
+          'inputs': [
+            'gen_pos_matcher_code.py',
+            '<(pos_matcher_rule)'
+          ],
+          'outputs': [
+            '<(pos_matcher_header)',
+          ],
+          'action': [
+            '<(python)', 'gen_pos_matcher_code.py',
+            '--pos_matcher_rule_file=<(pos_matcher_rule)',
+            '--output_pos_matcher_h=<(pos_matcher_header)',
+          ],
+          'message': ('Generating <(pos_matcher_header)'),
+        },
+      ],
+    },
+    {
+      'target_name': 'pos_matcher',
+      'type': 'none',
+      'toolsets': ['target', 'host'],
+      'hard_dependency': 1,
+      'dependencies': [
+        'gen_pos_matcher#host',
+      ],
+      'export_dependent_settings': [
+        'gen_pos_matcher#host',
+      ]
+    },
     {
       'target_name': 'user_pos',
       'type': 'static_library',
@@ -123,7 +174,7 @@
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:user_dictionary_storage_proto',
         '<(mozc_oss_src_dir)/request/request.gyp:conversion_request',
         'gen_pos_map#host',
-        'pos_matcher.gyp:pos_matcher',
+        'pos_matcher',
       ],
     },
   ],
diff --git a/src/dictionary/dictionary_test.gyp b/src/dictionary/dictionary_test.gyp
index f60ce3c..0685a98 100644
--- a/src/dictionary/dictionary_test.gyp
+++ b/src/dictionary/dictionary_test.gyp
@@ -59,9 +59,9 @@
         '<(mozc_oss_src_dir)/testing/testing.gyp:testing_util',
         'dictionary.gyp:dictionary',
         'dictionary.gyp:dictionary_test_util',
+        'dictionary_base.gyp:pos_matcher',
         'dictionary_base.gyp:user_dictionary',
         'dictionary_base.gyp:user_pos',
-        'pos_matcher.gyp:pos_matcher',
       ],
       'variables': {
         'test_size': 'small',
diff --git a/src/dictionary/pos_matcher.gyp b/src/dictionary/pos_matcher.gyp
deleted file mode 100644
index fe3bc77..0000000
--- a/src/dictionary/pos_matcher.gyp
+++ /dev/null
@@ -1,90 +0,0 @@
-# Copyright 2010-2021, Google Inc.
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions are
-# met:
-#
-#     * Redistributions of source code must retain the above copyright
-# notice, this list of conditions and the following disclaimer.
-#     * Redistributions in binary form must reproduce the above
-# copyright notice, this list of conditions and the following disclaimer
-# in the documentation and/or other materials provided with the
-# distribution.
-#     * Neither the name of Google Inc. nor the names of its
-# contributors may be used to endorse or promote products derived from
-# this software without specific prior written permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-# pos_matcher.gyp defines targets for pos_matcher.
-# This file is used to address cyclic dependency among gyp files.
-{
-  'variables': {
-    'relative_dir': 'dictionary',
-    'gen_out_dir': '<(SHARED_INTERMEDIATE_DIR)/<(relative_dir)',
-  },
-  'targets': [
-    {
-      'target_name': 'pos_util',
-      'type': 'none',
-      'toolsets': ['host'],
-      'sources': [
-        '<(mozc_oss_src_dir)/build_tools/code_generator_util.py',
-        'pos_util.py',
-      ],
-    },
-    {
-      'target_name': 'gen_pos_matcher',
-      'type': 'none',
-      'toolsets': ['host'],
-      'dependencies': [
-        'pos_util',
-      ],
-      'actions': [
-        {
-          'action_name': 'gen_pos_matcher',
-          'variables': {
-            'pos_matcher_rule': '<(mozc_oss_src_dir)/data/rules/pos_matcher_rule.def',
-            'pos_matcher_header': '<(gen_out_dir)/pos_matcher_impl.inc',
-          },
-          'inputs': [
-            'gen_pos_matcher_code.py',
-            '<(pos_matcher_rule)'
-          ],
-          'outputs': [
-            '<(pos_matcher_header)',
-          ],
-          'action': [
-            '<(python)', 'gen_pos_matcher_code.py',
-            '--pos_matcher_rule_file=<(pos_matcher_rule)',
-            '--output_pos_matcher_h=<(pos_matcher_header)',
-          ],
-          'message': ('Generating <(pos_matcher_header)'),
-        },
-      ],
-    },
-    {
-      'target_name': 'pos_matcher',
-      'type': 'none',
-      'toolsets': ['target', 'host'],
-      'hard_dependency': 1,
-      'dependencies': [
-        'gen_pos_matcher#host',
-      ],
-      'export_dependent_settings': [
-        'gen_pos_matcher#host',
-      ]
-    },
-  ],
-}
diff --git a/src/dictionary/system/system_dictionary.gyp b/src/dictionary/system/system_dictionary.gyp
index eec1d66..5542a9b 100644
--- a/src/dictionary/system/system_dictionary.gyp
+++ b/src/dictionary/system/system_dictionary.gyp
@@ -79,8 +79,8 @@
         '<(mozc_oss_src_dir)/base/base.gyp:base_core',
         '<(mozc_oss_src_dir)/request/request.gyp:conversion_request',
         '<(mozc_oss_src_dir)/storage/louds/louds.gyp:louds_trie',
+        '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:pos_matcher',
         '<(mozc_oss_src_dir)/dictionary/file/dictionary_file.gyp:codec_factory',
-        '<(mozc_oss_src_dir)/dictionary/pos_matcher.gyp:pos_matcher',
         'system_dictionary_codec',
       ],
     },
@@ -96,10 +96,10 @@
         '<(mozc_oss_src_dir)/base/base.gyp:japanese_util',
         '<(mozc_oss_src_dir)/storage/louds/louds.gyp:bit_vector_based_array_builder',
         '<(mozc_oss_src_dir)/storage/louds/louds.gyp:louds_trie_builder',
+        '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:pos_matcher',
         '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:text_dictionary_loader',
         '<(mozc_oss_src_dir)/dictionary/file/dictionary_file.gyp:codec',
         '<(mozc_oss_src_dir)/dictionary/file/dictionary_file.gyp:codec_factory',
-        '<(mozc_oss_src_dir)/dictionary/pos_matcher.gyp:pos_matcher',
         'system_dictionary_codec',
       ],
     },
diff --git a/src/dictionary/user_dictionary_session_handler_test.cc b/src/dictionary/user_dictionary_session_handler_test.cc
index b73ba2e..f375015 100644
--- a/src/dictionary/user_dictionary_session_handler_test.cc
+++ b/src/dictionary/user_dictionary_session_handler_test.cc
@@ -114,7 +114,7 @@ class UserDictionarySessionHandlerTest
     Clear();
     command_->set_type(UserDictionaryCommand::CREATE_DICTIONARY);
     command_->set_session_id(session_id);
-    command_->set_dictionary_name(name);
+    command_->set_dictionary_name(std::string(name));
     EXPECT_TRUE(handler_->Evaluate(*command_, status_.get()));
     EXPECT_EQ(status_->status(),
               (UserDictionaryCommandStatus::USER_DICTIONARY_COMMAND_SUCCESS));
diff --git a/src/dictionary/user_dictionary_util.cc b/src/dictionary/user_dictionary_util.cc
index b962bf7..3bd8b67 100644
--- a/src/dictionary/user_dictionary_util.cc
+++ b/src/dictionary/user_dictionary_util.cc
@@ -371,7 +371,7 @@ UserDictionaryCommandStatus::Status UserDictionaryUtil::CreateDictionary(
   }
 
   dictionary->set_id(*new_dictionary_id);
-  dictionary->set_name(dictionary_name);
+  dictionary->set_name(std::string(dictionary_name));
   return UserDictionaryCommandStatus::USER_DICTIONARY_COMMAND_SUCCESS;
 }
 
diff --git a/src/engine/BUILD.bazel b/src/engine/BUILD.bazel
index 7a09b90..669d99c 100644
--- a/src/engine/BUILD.bazel
+++ b/src/engine/BUILD.bazel
@@ -113,6 +113,7 @@ mozc_cc_library(
         "//prediction:__pkg__",
     ],
     deps = [
+        "//base:absl_nullability",
         "//composer:query",
         "//prediction:result",
         "//protocol:commands_cc_proto",
@@ -132,6 +133,7 @@ mozc_cc_library(
     ],
     deps = [
         ":supplemental_model_interface",
+        "//base:absl_nullability",
         "//composer:query",
         "//prediction:result",
         "//protocol:commands_cc_proto",
diff --git a/src/engine/engine.gyp b/src/engine/engine.gyp
index 5d25103..726abfd 100644
--- a/src/engine/engine.gyp
+++ b/src/engine/engine.gyp
@@ -45,7 +45,7 @@
         '<(mozc_oss_src_dir)/base/absl.gyp:absl_status',
         '<(mozc_oss_src_dir)/base/base.gyp:base',
         '<(mozc_oss_src_dir)/data_manager/data_manager_base.gyp:data_manager',
-        '<(mozc_oss_src_dir)/dictionary/pos_matcher.gyp:pos_matcher',
+        '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:pos_matcher',
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:engine_builder_proto',
         '<(mozc_oss_src_dir)/request/request.gyp:conversion_request',
       ],
@@ -64,8 +64,8 @@
         '<(mozc_oss_src_dir)/base/absl.gyp:absl_strings',
         '<(mozc_oss_src_dir)/base/base.gyp:base',
         '<(mozc_oss_src_dir)/converter/converter.gyp:converter',
+        '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:pos_matcher',
         '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:user_dictionary',
-        '<(mozc_oss_src_dir)/dictionary/pos_matcher.gyp:pos_matcher',
         '<(mozc_oss_src_dir)/engine/engine_base.gyp:modules',
         '<(mozc_oss_src_dir)/prediction/prediction.gyp:prediction',
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:commands_proto',
@@ -86,7 +86,7 @@
         '<(mozc_oss_src_dir)/composer/composer.gyp:key_parser',
         '<(mozc_oss_src_dir)/config/config.gyp:config_handler',
         '<(mozc_oss_src_dir)/converter/converter_base.gyp:segments',
-        '<(mozc_oss_src_dir)/dictionary/pos_matcher.gyp:pos_matcher',
+        '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:pos_matcher',
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:commands_proto',
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:config_proto',
         '<(mozc_oss_src_dir)/request/request.gyp:conversion_request',
@@ -131,7 +131,7 @@
       ],
       'dependencies': [
         '<(mozc_oss_src_dir)/data_manager/testing/mock_data_manager.gyp:mock_data_manager',
-        '<(mozc_oss_src_dir)/dictionary/pos_matcher.gyp:pos_matcher',
+        '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:pos_matcher',
         '<(mozc_oss_src_dir)/request/request.gyp:conversion_request',
         'engine',
         'engine_builder'
@@ -160,7 +160,7 @@
         '<(mozc_oss_src_dir)/composer/composer.gyp:composer',
         '<(mozc_oss_src_dir)/converter/converter.gyp:converter',
         '<(mozc_oss_src_dir)/data_manager/data_manager_base.gyp:data_manager',
-        '<(mozc_oss_src_dir)/dictionary/pos_matcher.gyp:pos_matcher',
+        '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:pos_matcher',
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:config_proto',
         '<(mozc_oss_src_dir)/request/request.gyp:conversion_request',
       ],
diff --git a/src/engine/engine_base.gyp b/src/engine/engine_base.gyp
index 358fb6d..30a47dc 100644
--- a/src/engine/engine_base.gyp
+++ b/src/engine/engine_base.gyp
@@ -48,9 +48,9 @@
         '<(mozc_oss_src_dir)/converter/converter_base.gyp:segmenter',
         '<(mozc_oss_src_dir)/dictionary/dictionary.gyp:dictionary_impl',
         '<(mozc_oss_src_dir)/dictionary/dictionary.gyp:suffix_dictionary',
+        '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:pos_matcher',
         '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:user_dictionary',
         '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:user_pos',
-        '<(mozc_oss_src_dir)/dictionary/pos_matcher.gyp:pos_matcher',
         '<(mozc_oss_src_dir)/dictionary/system/system_dictionary.gyp:system_dictionary',
         '<(mozc_oss_src_dir)/dictionary/system/system_dictionary.gyp:value_dictionary',
         '<(mozc_oss_src_dir)/prediction/prediction_base.gyp:suggestion_filter',
@@ -58,7 +58,7 @@
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:user_dictionary_storage_proto',
       ],
       'export_dependent_settings': [
-        '<(mozc_oss_src_dir)/dictionary/pos_matcher.gyp:pos_matcher',
+        '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:pos_matcher',
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:user_dictionary_storage_proto',
       ],
     },
diff --git a/src/gui/gui.gyp b/src/gui/gui.gyp
index 121f672..f62ec24 100644
--- a/src/gui/gui.gyp
+++ b/src/gui/gui.gyp
@@ -470,8 +470,8 @@
         '<(mozc_oss_src_dir)/base/base.gyp:base',
         '<(mozc_oss_src_dir)/client/client.gyp:client',
         '<(mozc_oss_src_dir)/data_manager/data_manager.gyp:pos_list_provider',
+        '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:pos_matcher',
         '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:user_dictionary',
-        '<(mozc_oss_src_dir)/dictionary/pos_matcher.gyp:pos_matcher',
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:commands_proto',
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:user_dictionary_storage_proto',
         'gen_word_register_dialog_files',
diff --git a/src/mac/BUILD.bazel b/src/mac/BUILD.bazel
index be26192..ef6b488 100644
--- a/src/mac/BUILD.bazel
+++ b/src/mac/BUILD.bazel
@@ -174,8 +174,6 @@ mozc_objc_test(
     name = "mozc_imk_input_controller_test",
     size = "small",
     srcs = ["mozc_imk_input_controller_test.mm"],
-    # TODO: b/426098963 - Temporarily disable this test on TAP since the test runner results fail.
-    tags = ["notap"],
     deps = [
         ":keycode_map",
         ":mozc_imk_input_controller",
@@ -240,7 +238,6 @@ mozc_objc_test(
     sdk_frameworks = ["AppKit"],
     deps = [
         ":keycode_map",
-        "//base/protobuf:text_format",
         "//protocol:commands_cc_proto",
         "//testing:gunit_main_objc",
     ],
diff --git a/src/mac/KeyCodeMap_test.mm b/src/mac/KeyCodeMap_test.mm
index a048300..30bc280 100644
--- a/src/mac/KeyCodeMap_test.mm
+++ b/src/mac/KeyCodeMap_test.mm
@@ -34,29 +34,28 @@
 
 #include <cstdint>
 
-#include "base/protobuf/text_format.h"
 #include "protocol/commands.pb.h"
 #include "testing/gunit.h"
 
 using mozc::commands::KeyEvent;
 
 struct TestCase {
-  absl::string_view title;
-  const char *characters;
-  const char *unmod_characters;
+  std::string title;
+  NSString *characters;
+  NSString *unmodCharacters;
   int flags;
   uint16_t keyCode;
-  absl::string_view expected;
+  std::string expected;
 };
 
 class KeyCodeMapTest : public testing::Test {
  protected:
-  void SetUp() override { keyCodeMap_ = [[KeyCodeMap alloc] init]; }
+  void SetUp() { keyCodeMap_ = [[KeyCodeMap alloc] init]; }
 
   void KanaMode() { keyCodeMap_.inputMode = KANA; }
 
-  bool CreateKeyEvent(const char *characters, const char *unmod_characters, int flags,
-                      uint16_t keyCode, KeyEvent *mozcKeyEvent) {
+  bool CreateKeyEvent(NSString *characters, NSString *unmodCharacters, int flags, uint16_t keyCode,
+                      KeyEvent *mozcKeyEvent) {
     if (mozcKeyEvent == nullptr) {
       return false;
     }
@@ -64,15 +63,15 @@ class KeyCodeMapTest : public testing::Test {
     NSEventType type = NSKeyDown;
     // if the key event is just pressing modifiers, the type should be
     // NSFlagsChanged.
-    if (characters == nullptr && unmod_characters == nullptr) {
+    if (characters == nil && unmodCharacters == nil) {
       type = NSFlagsChanged;
     }
 
-    if (characters == nullptr) {
-      characters = "";
+    if (characters == nil) {
+      characters = @"";
     }
-    if (unmod_characters == nullptr) {
-      unmod_characters = characters;
+    if (unmodCharacters == nil) {
+      unmodCharacters = [characters copy];
     }
 
     NSEvent *event = [NSEvent keyEventWithType:type
@@ -81,92 +80,88 @@ class KeyCodeMapTest : public testing::Test {
                                      timestamp:0.0
                                   windowNumber:0
                                        context:nil
-                                    characters:@(characters)
-                   charactersIgnoringModifiers:@(unmod_characters)
+                                    characters:characters
+                   charactersIgnoringModifiers:unmodCharacters
                                      isARepeat:NO
                                        keyCode:keyCode];
     return [keyCodeMap_ getMozcKeyCodeFromKeyEvent:event toMozcKeyEvent:mozcKeyEvent];
   }
 
   bool CreateKeyEventFromTestCase(const TestCase &testCase, KeyEvent *mozcKeyEvent) {
-    return CreateKeyEvent(testCase.characters, testCase.unmod_characters, testCase.flags,
+    return CreateKeyEvent(testCase.characters, testCase.unmodCharacters, testCase.flags,
                           testCase.keyCode, mozcKeyEvent);
   }
 
-  std::string GetDebugString(const KeyEvent &event) {
-    std::string output;
-    mozc::protobuf::TextFormat::PrintToString(event, &output);
-    return output;
-  }
-
  private:
   KeyCodeMap *keyCodeMap_;
 };
 
+static const TestCase kKeyEventTestCases[] = {
+    {"normal a", @"a", nil, 0, kVK_ANSI_A, "key_code: 97\n"},
+    {"\\S-a", @"A", @"a", NSShiftKeyMask, kVK_ANSI_A, "key_code: 65\n"},
+    {"\\C-a", @"\x01", @"a", NSControlKeyMask, kVK_ANSI_A,
+     "key_code: 97\n"
+     "modifier_keys: CTRL\n"},
+    {"\\S-C-a", @"a", nil, NSControlKeyMask | NSShiftKeyMask, kVK_ANSI_A,
+     "key_code: 97\n"
+     "modifier_keys: SHIFT\n"
+     "modifier_keys: CTRL\n"},
+    {"Tab key", @"\x09", nil, 0, kVK_Tab, "special_key: TAB\n"},
+    {"\\S-Tab", @"\x09", nil, NSShiftKeyMask, kVK_Tab,
+     "special_key: TAB\n"
+     "modifier_keys: SHIFT\n"},
+    {"function key", @"\x10", nil, 0, kVK_F1, "special_key: F1\n"},
+    {"tenkey", @"0", nil, 0, kVK_ANSI_Keypad0, "special_key: NUMPAD0\n"}};
+
+static const TestCase kKanaTypingTestCases[] = {
+    {"a -> ち", @"a", nil, 0, kVK_ANSI_A,
+     "key_code: 97\n"
+     "key_string: \"\\343\\201\\241\"\n"},
+    {"yen mark", @"¥", nil, 0, kVK_JIS_Yen,
+     "key_code: 92\n"
+     "key_string: \"\\343\\203\\274\"\n"},
+    {"\\S-2 -> ふ", @"@", @"2", NSShiftKeyMask, kVK_ANSI_2,
+     "key_code: 64\n"
+     "key_string: \"\\343\\201\\265\"\n"},
+    {"\\C-a -> \\C-a", @"\x01", @"a", NSControlKeyMask, kVK_ANSI_A,
+     "key_code: 97\n"
+     "modifier_keys: CTRL\n"
+     "key_string: \"\\343\\201\\241\"\n"},
+    {"\\S-0 -> を", @"0", nil, NSShiftKeyMask, kVK_ANSI_0,
+     "key_code: 48\n"
+     "key_string: \"\\343\\202\\222\"\n"},
+    {"yen mark -> ー", @"￥", nil, 0, kVK_JIS_Yen, "key_string: \"\\343\\203\\274\"\n"},
+    {"underscore -> ろ", @"_", nil, 0, kVK_JIS_Underscore,
+     "key_code: 95\n"
+     "key_string: \"\\343\\202\\215\"\n"},
+    {"@ -> ゛ in JIS keyboard", @"@", nil, 0, kVK_ANSI_LeftBracket,
+     "key_code: 64\n"
+     "key_string: \"\\343\\202\\233\"\n"},
+    {"[ -> ゛ in US keyboard", @"[", nil, 0, kVK_ANSI_LeftBracket,
+     "key_code: 91\n"
+     "key_string: \"\\343\\202\\233\"\n"},
+};
+
 // Test for romaji typing
 TEST_F(KeyCodeMapTest, NormaKeyEvent) {
-  const TestCase test_cases[] = {
-      {"normal a", "a", nullptr, 0, kVK_ANSI_A, "key_code: 97\n"},
-      {"\\S-a", "A", "a", NSShiftKeyMask, kVK_ANSI_A, "key_code: 65\n"},
-      {"\\C-a", "\x01", "a", NSControlKeyMask, kVK_ANSI_A,
-       "key_code: 97\n"
-       "modifier_keys: CTRL\n"},
-      {"\\S-C-a", "a", nullptr, NSControlKeyMask | NSShiftKeyMask, kVK_ANSI_A,
-       "key_code: 97\n"
-       "modifier_keys: SHIFT\n"
-       "modifier_keys: CTRL\n"},
-      {"Tab key", "\x09", nullptr, 0, kVK_Tab, "special_key: TAB\n"},
-      {"\\S-Tab", "\x09", nullptr, NSShiftKeyMask, kVK_Tab,
-       "special_key: TAB\n"
-       "modifier_keys: SHIFT\n"},
-      {"function key", "\x10", nullptr, 0, kVK_F1, "special_key: F1\n"},
-      {"tenkey", "0", nullptr, 0, kVK_ANSI_Keypad0, "special_key: NUMPAD0\n"}};
-
   KeyEvent event;
-  for (const TestCase &test_case : test_cases) {
+  for (int i = 0; i < std::size(kKeyEventTestCases); ++i) {
+    const TestCase &testCase = kKeyEventTestCases[i];
     event.Clear();
-    EXPECT_TRUE(CreateKeyEventFromTestCase(test_case, &event));
-    EXPECT_EQ(GetDebugString(event), test_case.expected) << test_case.title;
+    EXPECT_TRUE(CreateKeyEventFromTestCase(testCase, &event));
+    EXPECT_EQ(event.DebugString(), testCase.expected) << testCase.title;
   }
 }
 
 // Test for kana typing
 TEST_F(KeyCodeMapTest, KanaEvent) {
-  const TestCase test_cases[] = {
-      {"a -> ち", "a", nullptr, 0, kVK_ANSI_A,
-       "key_code: 97\n"
-       "key_string: \"\\343\\201\\241\"\n"},
-      {"yen mark", "¥", nullptr, 0, kVK_JIS_Yen,
-       "key_code: 92\n"
-       "key_string: \"\\343\\203\\274\"\n"},
-      {"\\S-2 -> ふ", "@", "2", NSShiftKeyMask, kVK_ANSI_2,
-       "key_code: 64\n"
-       "key_string: \"\\343\\201\\265\"\n"},
-      {"\\C-a -> \\C-a", "\x01", "a", NSControlKeyMask, kVK_ANSI_A,
-       "key_code: 97\n"
-       "modifier_keys: CTRL\n"
-       "key_string: \"\\343\\201\\241\"\n"},
-      {"\\S-0 -> を", "0", nullptr, NSShiftKeyMask, kVK_ANSI_0,
-       "key_code: 48\n"
-       "key_string: \"\\343\\202\\222\"\n"},
-      {"yen mark -> ー", "￥", nullptr, 0, kVK_JIS_Yen, "key_string: \"\\343\\203\\274\"\n"},
-      {"underscore -> ろ", "_", nullptr, 0, kVK_JIS_Underscore,
-       "key_code: 95\n"
-       "key_string: \"\\343\\202\\215\"\n"},
-      {"@ -> ゛ in JIS keyboard", "@", nullptr, 0, kVK_ANSI_LeftBracket,
-       "key_code: 64\n"
-       "key_string: \"\\343\\202\\233\"\n"},
-      {"[ -> ゛ in US keyboard", "[", nullptr, 0, kVK_ANSI_LeftBracket,
-       "key_code: 91\n"
-       "key_string: \"\\343\\202\\233\"\n"},
-  };
-
   KanaMode();
   KeyEvent event;
-  for (const TestCase &test_case : test_cases) {
+  for (int i = 0; i < std::size(kKanaTypingTestCases); ++i) {
+    const TestCase &testCase = kKanaTypingTestCases[i];
     event.Clear();
-    EXPECT_TRUE(CreateKeyEventFromTestCase(test_case, &event));
-    EXPECT_EQ(GetDebugString(event), test_case.expected) << test_case.title;
+    EXPECT_TRUE(CreateKeyEventFromTestCase(testCase, &event));
+    EXPECT_EQ(event.DebugString(), testCase.expected) << testCase.title;
   }
 }
 
@@ -175,41 +170,40 @@ TEST_F(KeyCodeMapTest, Modifiers) {
   KeyEvent event;
   TestCase testCase;
   // Press shift key
-  EXPECT_FALSE(CreateKeyEvent(nullptr, nullptr, NSShiftKeyMask, kVK_Shift, &event));
+  EXPECT_FALSE(CreateKeyEvent(nil, nil, NSShiftKeyMask, kVK_Shift, &event));
 
   // Release the shift key -> emit Shift-key event
   event.Clear();
-  EXPECT_TRUE(CreateKeyEvent(nullptr, nullptr, 0, kVK_Shift, &event));
-  EXPECT_EQ(GetDebugString(event), "modifier_keys: SHIFT\n");
+  EXPECT_TRUE(CreateKeyEvent(nil, nil, 0, kVK_Shift, &event));
+  EXPECT_EQ(event.DebugString(), "modifier_keys: SHIFT\n");
 
   // Press shift key
   event.Clear();
-  EXPECT_FALSE(CreateKeyEvent(nullptr, nullptr, NSShiftKeyMask, kVK_Shift, &event));
+  EXPECT_FALSE(CreateKeyEvent(nil, nil, NSShiftKeyMask, kVK_Shift, &event));
 
   // Press control key
   event.Clear();
-  EXPECT_FALSE(
-      CreateKeyEvent(nullptr, nullptr, NSShiftKeyMask | NSControlKeyMask, kVK_Control, &event));
+  EXPECT_FALSE(CreateKeyEvent(nil, nil, NSShiftKeyMask | NSControlKeyMask, kVK_Control, &event));
 
   // Release shift key
   event.Clear();
-  EXPECT_FALSE(CreateKeyEvent(nullptr, nullptr, NSControlKeyMask, kVK_Control, &event));
+  EXPECT_FALSE(CreateKeyEvent(nil, nil, NSControlKeyMask, kVK_Control, &event));
 
   // Release control key -> emit Control + Shift
   event.Clear();
-  EXPECT_TRUE(CreateKeyEvent(nullptr, nullptr, 0, kVK_Control, &event));
-  EXPECT_EQ(GetDebugString(event), "modifier_keys: SHIFT\nmodifier_keys: CTRL\n");
+  EXPECT_TRUE(CreateKeyEvent(nil, nil, 0, kVK_Control, &event));
+  EXPECT_EQ(event.DebugString(), "modifier_keys: SHIFT\nmodifier_keys: CTRL\n");
 
   // Press control key
   event.Clear();
-  EXPECT_FALSE(CreateKeyEvent(nullptr, nullptr, NSControlKeyMask, kVK_Control, &event));
+  EXPECT_FALSE(CreateKeyEvent(nil, nil, NSControlKeyMask, kVK_Control, &event));
 
   // Press a -> emit \C-a
   event.Clear();
-  EXPECT_TRUE(CreateKeyEvent("a", nullptr, NSControlKeyMask, kVK_ANSI_A, &event));
-  EXPECT_EQ(GetDebugString(event), "key_code: 97\nmodifier_keys: CTRL\n");
+  EXPECT_TRUE(CreateKeyEvent(@"a", nil, NSControlKeyMask, kVK_ANSI_A, &event));
+  EXPECT_EQ(event.DebugString(), "key_code: 97\nmodifier_keys: CTRL\n");
 
   // Release control key -> Doesn't emit any key events
   event.Clear();
-  EXPECT_FALSE(CreateKeyEvent(nullptr, nullptr, 0, kVK_Control, &event));
+  EXPECT_FALSE(CreateKeyEvent(nil, nil, 0, kVK_Control, &event));
 }
diff --git a/src/prediction/BUILD.bazel b/src/prediction/BUILD.bazel
index b3a7263..f1051b2 100644
--- a/src/prediction/BUILD.bazel
+++ b/src/prediction/BUILD.bazel
@@ -191,6 +191,7 @@ mozc_cc_library(
         "//converter:segmenter",
         "//converter:segments",
         "//dictionary:pos_matcher",
+        "//dictionary:single_kanji_dictionary",
         "//engine:modules",
         "//engine:supplemental_model_interface",
         "//protocol:commands_cc_proto",
@@ -219,11 +220,11 @@ mozc_cc_library(
     ],
     deps = [
         ":zero_query_dict",
+        "//base:absl_nullability",
         "//base/strings:unicode",
         "//composer:query",
         "//converter:segments",
         "//dictionary:dictionary_token",
-        "@com_google_absl//absl/base:nullability",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/strings",
         "@com_google_absl//absl/strings:str_format",
@@ -586,7 +587,6 @@ mozc_cc_library(
     ],
     deps = [
         "//base/container:trie",
-        "@com_google_absl//absl/base:no_destructor",
         "@com_google_absl//absl/log",
         "@com_google_absl//absl/log:check",
         "@com_google_absl//absl/strings",
diff --git a/src/prediction/dictionary_prediction_aggregator.cc b/src/prediction/dictionary_prediction_aggregator.cc
index 43856b6..e0441db 100644
--- a/src/prediction/dictionary_prediction_aggregator.cc
+++ b/src/prediction/dictionary_prediction_aggregator.cc
@@ -259,6 +259,7 @@ class PredictiveLookupCallback : public DictionaryInterface::Callback {
     result.wcost += penalty_;
     if (penalty_ > 0) result.types |= KEY_EXPANDED_IN_DICTIONARY;
     RewriteResult(result);
+    if (types_ & SUFFIX) result.zero_query_type = ZERO_QUERY_SUFFIX;
     results_->emplace_back(std::move(result));
     return (results_->size() < limit_) ? TRAVERSE_CONTINUE : TRAVERSE_DONE;
   }
@@ -1356,6 +1357,7 @@ void DictionaryPredictionAggregator::GetZeroQueryCandidatesForKey(
 
     Result result;
     result.SetTypesAndTokenAttributes(SUFFIX, Token::NONE);
+    result.zero_query_type = type;
     result.key = value;
     result.value = value;
     result.wcost = cost;
@@ -1569,6 +1571,12 @@ void DictionaryPredictionAggregator::CheckBigramResult(
     Result *result) const {
   DCHECK(result);
 
+  const bool is_zero_query = request.IsZeroQuerySuggestion();
+
+  if (is_zero_query) {
+    result->zero_query_type = ZERO_QUERY_BIGRAM;
+  }
+
   absl::string_view key = result->key;
   absl::string_view value = result->value;
 
diff --git a/src/prediction/dictionary_prediction_aggregator_test.cc b/src/prediction/dictionary_prediction_aggregator_test.cc
index 8cd6f24..952db76 100644
--- a/src/prediction/dictionary_prediction_aggregator_test.cc
+++ b/src/prediction/dictionary_prediction_aggregator_test.cc
@@ -697,6 +697,8 @@ TEST_F(DictionaryPredictionAggregatorTest, BigramTestWithZeroQueryFilterMode) {
   Segments segments;
   config_->set_use_dictionary_suggest(true);
   request_->set_zero_query_suggestion(true);
+  request_->mutable_decoder_experiment_params()->set_bigram_nwp_filtering_mode(
+      commands::DecoderExperimentParams::FILTER_ALL);
 
   // current query is empty
   InitSegmentsWithKey("", &segments);
@@ -1353,6 +1355,8 @@ TEST_F(DictionaryPredictionAggregatorTest, AggregateBigramPrediction) {
       EXPECT_FALSE(results[i].value.starts_with(kHistoryValue));
       EXPECT_TRUE(results[i].key.starts_with("あ"));
       EXPECT_TRUE(results[i].value.starts_with("ア"));
+      // Not zero query
+      EXPECT_EQ(results[i].zero_query_type, 0);
     }
 
     EXPECT_EQ(segments.conversion_segments_size(), 1);
@@ -2090,6 +2094,7 @@ TEST_F(DictionaryPredictionAggregatorTest, AggregateSuffixPrediction) {
   EXPECT_TRUE(GetMergedTypes(results) & SUFFIX);
   for (const auto &result : results) {
     EXPECT_EQ(result.types, SUFFIX);
+    EXPECT_EQ(result.zero_query_type, ZERO_QUERY_SUFFIX);
   }
 }
 
@@ -2122,6 +2127,8 @@ TEST_F(DictionaryPredictionAggregatorTest, AggregateZeroQuerySuffixPrediction) {
     EXPECT_FALSE(results.empty());
     for (size_t i = 0; i < results.size(); ++i) {
       EXPECT_EQ(results[i].types, SUFFIX);
+      // Zero query
+      EXPECT_EQ(results[i].zero_query_type, ZERO_QUERY_SUFFIX);
     }
   }
   {
@@ -2367,6 +2374,7 @@ TEST_F(DictionaryPredictionAggregatorTest, ZeroQuerySuggestionAfterNumbers) {
     auto target = results.end();
     for (auto it = results.begin(); it != results.end(); ++it) {
       EXPECT_EQ(it->types, SUFFIX);
+      EXPECT_EQ(it->zero_query_type, ZERO_QUERY_NUMBER_SUFFIX);
 
       if (it->value == kExpectedValue) {
         target = it;
@@ -2396,6 +2404,7 @@ TEST_F(DictionaryPredictionAggregatorTest, ZeroQuerySuggestionAfterNumbers) {
     for (auto it = results.begin(); it != results.end(); ++it) {
       EXPECT_EQ(it->types, SUFFIX);
       if (it->value == kExpectedValue) {
+        EXPECT_EQ(it->zero_query_type, ZERO_QUERY_NUMBER_SUFFIX);
         found = true;
         break;
       }
@@ -2444,6 +2453,7 @@ TEST_F(DictionaryPredictionAggregatorTest, TriggerNumberZeroQuerySuggestion) {
       EXPECT_EQ(it->types, SUFFIX);
       if (it->value == test_case.find_suffix_value &&
           it->lid == pos_matcher.GetCounterSuffixWordId()) {
+        EXPECT_EQ(it->zero_query_type, ZERO_QUERY_NUMBER_SUFFIX);
         found = true;
         break;
       }
@@ -2958,6 +2968,7 @@ TEST_F(DictionaryPredictionAggregatorTest, GetZeroQueryCandidates) {
     EXPECT_EQ(results.size(), test_case.expected_candidates.size());
     for (size_t i = 0; i < test_case.expected_candidates.size(); ++i) {
       EXPECT_EQ(results[i].value, test_case.expected_candidates[i]);
+      EXPECT_EQ(results[i].zero_query_type, test_case.expected_types[i]);
     }
   }
 }
diff --git a/src/prediction/dictionary_predictor.cc b/src/prediction/dictionary_predictor.cc
index 4670a9c..976043b 100644
--- a/src/prediction/dictionary_predictor.cc
+++ b/src/prediction/dictionary_predictor.cc
@@ -60,6 +60,7 @@
 #include "converter/segmenter.h"
 #include "converter/segments.h"
 #include "dictionary/pos_matcher.h"
+#include "dictionary/single_kanji_dictionary.h"
 #include "engine/modules.h"
 #include "engine/supplemental_model_interface.h"
 #include "prediction/dictionary_prediction_aggregator.h"
@@ -89,8 +90,8 @@ bool IsLatinInputMode(const ConversionRequest &request) {
          request.composer().GetInputMode() == transliteration::FULL_ASCII;
 }
 
-bool IsMixedConversionEnabled(const ConversionRequest &request) {
-  return request.request().mixed_conversion();
+bool IsMixedConversionEnabled(const Request &request) {
+  return request.mixed_conversion();
 }
 
 bool IsTypingCorrectionEnabled(const ConversionRequest &request) {
@@ -140,13 +141,13 @@ DictionaryPredictor::DictionaryPredictor(
     const engine::Modules &modules, const ConverterInterface &converter,
     const ImmutableConverterInterface &immutable_converter)
     : DictionaryPredictor(
-          modules,
+          "DictionaryPredictor", modules,
           std::make_unique<prediction::DictionaryPredictionAggregator>(
               modules, converter, immutable_converter),
           immutable_converter) {}
 
 DictionaryPredictor::DictionaryPredictor(
-    const engine::Modules &modules,
+    std::string predictor_name, const engine::Modules &modules,
     std::unique_ptr<const DictionaryPredictionAggregatorInterface> aggregator,
     const ImmutableConverterInterface &immutable_converter)
     : aggregator_(std::move(aggregator)),
@@ -154,8 +155,12 @@ DictionaryPredictor::DictionaryPredictor(
       connector_(modules.GetConnector()),
       segmenter_(modules.GetSegmenter()),
       suggestion_filter_(modules.GetSuggestionFilter()),
+      single_kanji_dictionary_(
+          std::make_unique<dictionary::SingleKanjiDictionary>(
+              modules.GetDataManager())),
       pos_matcher_(modules.GetPosMatcher()),
       general_symbol_id_(pos_matcher_.GetGeneralSymbolId()),
+      predictor_name_(std::move(predictor_name)),
       modules_(modules) {}
 
 std::vector<Result> DictionaryPredictor::Predict(
@@ -168,7 +173,7 @@ std::vector<Result> DictionaryPredictor::Predict(
   std::vector<Result> results;
 
   // TODO(taku): Separate DesktopPredictor and MixedDecodingPredictor.
-  if (IsMixedConversionEnabled(request)) {
+  if (IsMixedConversionEnabled(request.request())) {
     std::vector<Result> literal_results =
         aggregator_->AggregateResultsForMixedConversion(request);
     std::vector<Result> tc_results =
@@ -192,7 +197,7 @@ void DictionaryPredictor::RewriteResultsForPrediction(
   // Mixed conversion is the feature that mixes prediction and
   // conversion, meaning that results may include the candidates whose
   // key is exactly the same as the composition.  This mode is used in mobile.
-  const bool is_mixed_conversion = IsMixedConversionEnabled(request);
+  const bool is_mixed_conversion = IsMixedConversionEnabled(request.request());
 
   if (is_mixed_conversion) {
     SetPredictionCostForMixedConversion(request, results);
@@ -271,6 +276,9 @@ std::vector<Result> DictionaryPredictor::RerankAndFilterResults(
       continue;
     }
 
+    // TODO(taku): Add new method to fill the Result::candidate_attributes.
+    single_kanji_dictionary_->GenerateDescription(result.value,
+                                                  &result.description);
     if ((result.candidate_attributes &
          converter::Candidate::PARTIALLY_KEY_CONSUMED) &&
         cursor_at_tail) {
@@ -310,8 +318,10 @@ std::vector<Result> DictionaryPredictor::RerankAndFilterResults(
 void DictionaryPredictor::MaybeApplyPostCorrection(
     const ConversionRequest &request, std::vector<Result> &results) const {
   // b/363902660:
-  // Stop applying post correction when handwriting mode.
-  if (request_util::IsHandwriting(request)) {
+  // Stop applying post correction when typing correction is disabled.
+  // We may want to use other conditions if we want to enable post correction
+  // separately.
+  if (!IsTypingCorrectionEnabled(request)) {
     return;
   }
   modules_.GetSupplementalModel().PostCorrect(request, results);
@@ -381,6 +391,41 @@ int DictionaryPredictor::CalculateSingleKanjiCostOffset(
   return wcost_diff + kSingleKanjiPredictionCostOffset;
 }
 
+std::string DictionaryPredictor::GetPredictionTypeDebugString(
+    PredictionTypes types) {
+  std::string debug_desc;
+  if (types & PredictionType::UNIGRAM) {
+    debug_desc.append(1, 'U');
+  }
+  if (types & PredictionType::BIGRAM) {
+    debug_desc.append(1, 'B');
+  }
+  if (types & PredictionType::REALTIME_TOP) {
+    debug_desc.append("R1");
+  } else if (types & PredictionType::REALTIME) {
+    debug_desc.append(1, 'R');
+  }
+  if (types & PredictionType::SUFFIX) {
+    debug_desc.append(1, 'S');
+  }
+  if (types & PredictionType::ENGLISH) {
+    debug_desc.append(1, 'E');
+  }
+  if (types & PredictionType::TYPING_CORRECTION) {
+    debug_desc.append(1, 'T');
+  }
+  if (types & PredictionType::TYPING_COMPLETION) {
+    debug_desc.append(1, 'C');
+  }
+  if (types & PredictionType::SUPPLEMENTAL_MODEL) {
+    debug_desc.append(1, 'X');
+  }
+  if (types & PredictionType::KEY_EXPANDED_IN_DICTIONARY) {
+    debug_desc.append(1, 'K');
+  }
+  return debug_desc;
+}
+
 // Returns cost for |result| when it's transitioned from |rid|.  Suffix penalty
 // is also added for non-realtime results.
 int DictionaryPredictor::GetLMCost(const Result &result, int rid) const {
diff --git a/src/prediction/dictionary_predictor.h b/src/prediction/dictionary_predictor.h
index e6b2fa8..8edb666 100644
--- a/src/prediction/dictionary_predictor.h
+++ b/src/prediction/dictionary_predictor.h
@@ -49,6 +49,7 @@
 #include "converter/immutable_converter_interface.h"
 #include "converter/segmenter.h"
 #include "dictionary/pos_matcher.h"
+#include "dictionary/single_kanji_dictionary.h"
 #include "engine/modules.h"
 #include "prediction/dictionary_prediction_aggregator.h"
 #include "prediction/predictor_interface.h"
@@ -61,6 +62,12 @@ namespace mozc::prediction {
 // Dictionary-based predictor
 class DictionaryPredictor : public PredictorInterface {
  public:
+  // Cost penalty 1151 means that expanded candidates are evaluated
+  // 10 times smaller in frequency.
+  // Note that the cost is calcurated by cost = -500 * log(prob)
+  // 1151 = 500 * log(10)
+  static constexpr int kKeyExpansionPenalty = 1151;
+
   // Initializes a predictor with given references to submodules. Note that
   // pointers are not owned by the class and to be deleted by the caller.
   DictionaryPredictor(const engine::Modules &modules,
@@ -73,7 +80,7 @@ class DictionaryPredictor : public PredictorInterface {
   std::vector<Result> Predict(const ConversionRequest &request) const override;
 
   absl::string_view GetPredictorName() const override {
-    return "DictionaryPredictor";
+    return predictor_name_;
   }
 
  private:
@@ -86,7 +93,7 @@ class DictionaryPredictor : public PredictorInterface {
 
   // Constructor for testing
   DictionaryPredictor(
-      const engine::Modules &modules,
+      std::string predictor_name, const engine::Modules &modules,
       std::unique_ptr<const DictionaryPredictionAggregatorInterface> aggregator,
       const ImmutableConverterInterface &immutable_converter);
 
@@ -171,6 +178,8 @@ class DictionaryPredictor : public PredictorInterface {
                                      bool is_suggestion,
                                      size_t total_candidates_size);
 
+  static std::string GetPredictionTypeDebugString(PredictionTypes types);
+
   int CalculatePrefixPenalty(
       const ConversionRequest &request, absl::string_view input_key,
       const Result &result,
@@ -209,8 +218,11 @@ class DictionaryPredictor : public PredictorInterface {
   const Connector &connector_;
   const Segmenter &segmenter_;
   const SuggestionFilter &suggestion_filter_;
+  std::unique_ptr<const dictionary::SingleKanjiDictionary>
+      single_kanji_dictionary_;
   const dictionary::PosMatcher pos_matcher_;
   const uint16_t general_symbol_id_;
+  const std::string predictor_name_;
   const engine::Modules &modules_;
 };
 
diff --git a/src/prediction/dictionary_predictor_test.cc b/src/prediction/dictionary_predictor_test.cc
index 8f8542f..de7002d 100644
--- a/src/prediction/dictionary_predictor_test.cc
+++ b/src/prediction/dictionary_predictor_test.cc
@@ -134,9 +134,9 @@ class MockDataAndPredictor {
                    .PresetSupplementalModel(std::move(supplemental_model))
                    .Build(std::make_unique<testing::MockDataManager>())
                    .value();
-    predictor_ = absl::WrapUnique(
-        new DictionaryPredictor(*modules_, absl::WrapUnique(mock_aggregator_),
-                                mock_immutable_converter_));
+    predictor_ = absl::WrapUnique(new DictionaryPredictor(
+        "DictionaryPredictorForTest", *modules_,
+        absl::WrapUnique(mock_aggregator_), mock_immutable_converter_));
   }
 
   MockImmutableConverter *mutable_immutable_converter() {
@@ -837,6 +837,36 @@ TEST_F(DictionaryPredictorTest, MergeAttributesForDebug) {
   }
 }
 
+TEST_F(DictionaryPredictorTest, SetDescription) {
+  auto data_and_predictor = std::make_unique<MockDataAndPredictor>();
+  DictionaryPredictorTestPeer predictor_peer =
+      data_and_predictor->predictor_peer();
+
+  std::vector<Result> results = {
+      CreateResult6("ほせい", "補正", 0, 0, prediction::TYPING_CORRECTION,
+                    Token::NONE),
+      CreateResult6("あ", "亞", 0, 10, prediction::UNIGRAM, Token::NONE),
+      CreateResult6("たんご", "単語", 0, 20, prediction::UNIGRAM, Token::NONE),
+  };
+
+  Segments segments;
+  InitSegmentsWithKey("test", &segments);
+
+  const ConversionRequest convreq =
+      CreateConversionRequest(ConversionRequest::PREDICTION, segments);
+  results = predictor_peer.RerankAndFilterResults(convreq, results);
+
+  EXPECT_EQ(results.size(), 3);
+  EXPECT_EQ(results[0].value, "補正");
+  EXPECT_EQ(results[1].value, "亞");
+  // "亜の旧字体"
+  // We cannot compare the description as-is, since the other description
+  // may be appended in the dbg build.
+  EXPECT_TRUE(absl::StrContains(results[1].description, "の"));
+  EXPECT_EQ(results[2].value, "単語");
+  EXPECT_FALSE(absl::StrContains(results[2].description, "の"));
+}
+
 TEST_F(DictionaryPredictorTest, PropagateResultCosts) {
   auto data_and_predictor = std::make_unique<MockDataAndPredictor>();
   DictionaryPredictorTestPeer predictor_peer =
diff --git a/src/prediction/number_decoder.cc b/src/prediction/number_decoder.cc
index 8ddc2df..5e7afc9 100644
--- a/src/prediction/number_decoder.cc
+++ b/src/prediction/number_decoder.cc
@@ -31,14 +31,12 @@
 
 #include <algorithm>
 #include <cstddef>
-#include <memory>
 #include <optional>
 #include <ostream>
 #include <string>
 #include <utility>
 #include <vector>
 
-#include "absl/base/no_destructor.h"
 #include "absl/log/check.h"
 #include "absl/log/log.h"
 #include "absl/strings/str_cat.h"
@@ -80,65 +78,65 @@ void MaybeAppendResult(const State &state,
   results.push_back(*std::move(result));
 }
 
-std::unique_ptr<const Trie<Entry>> CreateDefaultEntries() {
-  auto result = std::make_unique<Trie<Entry>>();
+Trie<Entry> InitEntries() {
+  Trie<Entry> result;
   // unit
-  result->AddEntry("ぜろ", Entry({Type::UNIT, 0}));
-  result->AddEntry("いち", Entry({Type::UNIT, 1}));
-  result->AddEntry("いっ", Entry({Type::UNIT, 1}));
-  result->AddEntry("に", Entry({Type::UNIT, 2}));
-  result->AddEntry("さん", Entry({Type::UNIT, 3}));
-  result->AddEntry("し", Entry({Type::UNIT, 4}));
-  result->AddEntry("よん", Entry({Type::UNIT, 4}));
-  result->AddEntry("よ", Entry({Type::UNIT, 4}));
-  result->AddEntry("ご", Entry({Type::UNIT, 5}));
-  result->AddEntry("ろく", Entry({Type::UNIT, 6}));
-  result->AddEntry("ろっ", Entry({Type::UNIT, 6}));
-  result->AddEntry("なな", Entry({Type::UNIT, 7}));
-  result->AddEntry("しち", Entry({Type::UNIT, 7}));
-  result->AddEntry("はち", Entry({Type::UNIT, 8}));
-  result->AddEntry("はっ", Entry({Type::UNIT, 8}));
-  result->AddEntry("きゅう", Entry({Type::UNIT, 9}));
-  result->AddEntry("きゅー", Entry({Type::UNIT, 9}));
-  result->AddEntry("く", Entry({Type::UNIT, 9}));
+  result.AddEntry("ぜろ", Entry({Type::UNIT, 0}));
+  result.AddEntry("いち", Entry({Type::UNIT, 1}));
+  result.AddEntry("いっ", Entry({Type::UNIT, 1}));
+  result.AddEntry("に", Entry({Type::UNIT, 2}));
+  result.AddEntry("さん", Entry({Type::UNIT, 3}));
+  result.AddEntry("し", Entry({Type::UNIT, 4}));
+  result.AddEntry("よん", Entry({Type::UNIT, 4}));
+  result.AddEntry("よ", Entry({Type::UNIT, 4}));
+  result.AddEntry("ご", Entry({Type::UNIT, 5}));
+  result.AddEntry("ろく", Entry({Type::UNIT, 6}));
+  result.AddEntry("ろっ", Entry({Type::UNIT, 6}));
+  result.AddEntry("なな", Entry({Type::UNIT, 7}));
+  result.AddEntry("しち", Entry({Type::UNIT, 7}));
+  result.AddEntry("はち", Entry({Type::UNIT, 8}));
+  result.AddEntry("はっ", Entry({Type::UNIT, 8}));
+  result.AddEntry("きゅう", Entry({Type::UNIT, 9}));
+  result.AddEntry("きゅー", Entry({Type::UNIT, 9}));
+  result.AddEntry("く", Entry({Type::UNIT, 9}));
 
   // small digit
   // "重", etc
-  result->AddEntry("じゅう", Entry({Type::SMALL_DIGIT, 10, 2, "", true}));
-  result->AddEntry("じゅー", Entry({Type::SMALL_DIGIT, 10, 2, "", true}));
-  result->AddEntry("じゅっ", Entry({Type::SMALL_DIGIT, 10, 2}));
-  result->AddEntry("ひゃく", Entry({Type::SMALL_DIGIT, 100, 3}));
-  result->AddEntry("ひゃっ", Entry({Type::SMALL_DIGIT, 100, 3}));
-  result->AddEntry("びゃく", Entry({Type::SMALL_DIGIT, 100, 3}));
-  result->AddEntry("びゃっ", Entry({Type::SMALL_DIGIT, 100, 3}));
-  result->AddEntry("ぴゃく", Entry({Type::SMALL_DIGIT, 100, 3}));
-  result->AddEntry("ぴゃっ", Entry({Type::SMALL_DIGIT, 100, 3}));
+  result.AddEntry("じゅう", Entry({Type::SMALL_DIGIT, 10, 2, "", true}));
+  result.AddEntry("じゅー", Entry({Type::SMALL_DIGIT, 10, 2, "", true}));
+  result.AddEntry("じゅっ", Entry({Type::SMALL_DIGIT, 10, 2}));
+  result.AddEntry("ひゃく", Entry({Type::SMALL_DIGIT, 100, 3}));
+  result.AddEntry("ひゃっ", Entry({Type::SMALL_DIGIT, 100, 3}));
+  result.AddEntry("びゃく", Entry({Type::SMALL_DIGIT, 100, 3}));
+  result.AddEntry("びゃっ", Entry({Type::SMALL_DIGIT, 100, 3}));
+  result.AddEntry("ぴゃく", Entry({Type::SMALL_DIGIT, 100, 3}));
+  result.AddEntry("ぴゃっ", Entry({Type::SMALL_DIGIT, 100, 3}));
   // "戦", etc
-  result->AddEntry("せん", Entry({Type::SMALL_DIGIT, 1000, 4, "", true}));
+  result.AddEntry("せん", Entry({Type::SMALL_DIGIT, 1000, 4, "", true}));
   // "膳"
-  result->AddEntry("ぜん", Entry({Type::SMALL_DIGIT, 1000, 4, "", true}));
+  result.AddEntry("ぜん", Entry({Type::SMALL_DIGIT, 1000, 4, "", true}));
 
   // big digit
-  result->AddEntry("まん", Entry({Type::BIG_DIGIT, 10000, 5, "万"}));
-  result->AddEntry("おく", Entry({Type::BIG_DIGIT, -1, 9, "億"}));
-  result->AddEntry("おっ", Entry({Type::BIG_DIGIT, -1, 9, "億"}));
+  result.AddEntry("まん", Entry({Type::BIG_DIGIT, 10000, 5, "万"}));
+  result.AddEntry("おく", Entry({Type::BIG_DIGIT, -1, 9, "億"}));
+  result.AddEntry("おっ", Entry({Type::BIG_DIGIT, -1, 9, "億"}));
   // "町", etc
-  result->AddEntry("ちょう", Entry({Type::BIG_DIGIT, -1, 13, "兆", true}));
+  result.AddEntry("ちょう", Entry({Type::BIG_DIGIT, -1, 13, "兆", true}));
   // "系", etc
-  result->AddEntry("けい", Entry({Type::BIG_DIGIT, -1, 17, "京", true}));
-  result->AddEntry("がい", Entry({Type::BIG_DIGIT, -1, 21, "垓"}));
+  result.AddEntry("けい", Entry({Type::BIG_DIGIT, -1, 17, "京", true}));
+  result.AddEntry("がい", Entry({Type::BIG_DIGIT, -1, 21, "垓"}));
 
   // spacial cases
   // conflict with "にち"
-  result->AddEntry("にちょう",
-                   Entry({Type::UNIT_AND_BIG_DIGIT, 2, 13, "兆", true, 3}));
-  result->AddEntry("にちょうめ",
-                   Entry({Type::UNIT_AND_STOP_DECODING, 2, -1, "", false, 3}));
-  result->AddEntry("にちゃん",
-                   Entry({Type::UNIT_AND_STOP_DECODING, 2, -1, "", false, 3}));
+  result.AddEntry("にちょう",
+                  Entry({Type::UNIT_AND_BIG_DIGIT, 2, 13, "兆", true, 3}));
+  result.AddEntry("にちょうめ",
+                  Entry({Type::UNIT_AND_STOP_DECODING, 2, -1, "", false, 3}));
+  result.AddEntry("にちゃん",
+                  Entry({Type::UNIT_AND_STOP_DECODING, 2, -1, "", false, 3}));
   // サンチーム (currency) v.s. 3チーム
-  result->AddEntry("さんちーむ",
-                   Entry({Type::UNIT_AND_STOP_DECODING, 3, -1, "", true, 6}));
+  result.AddEntry("さんちーむ",
+                  Entry({Type::UNIT_AND_STOP_DECODING, 3, -1, "", true, 6}));
 
   // number suffix conflicting with the other entries
   constexpr absl::string_view kSuffixEntries[] = {
@@ -188,18 +186,11 @@ std::unique_ptr<const Trie<Entry>> CreateDefaultEntries() {
       "ちょうめ",
   };
   for (const auto &key : kSuffixEntries) {
-    result->AddEntry(key, Entry());
+    result.AddEntry(key, Entry());
   }
   return result;
 }
 
-const Trie<Entry> &InitEntries() {
-  // Returns a singleton enries.
-  static const absl::NoDestructor<std::unique_ptr<const Trie<Entry>>>
-      kDefaultEntries(CreateDefaultEntries());
-  return **kDefaultEntries;
-}
-
 }  // namespace
 
 std::ostream &operator<<(std::ostream &os, const NumberDecoderResult &r) {
diff --git a/src/prediction/number_decoder.h b/src/prediction/number_decoder.h
index cb294da..c5a45b2 100644
--- a/src/prediction/number_decoder.h
+++ b/src/prediction/number_decoder.h
@@ -175,7 +175,7 @@ class NumberDecoder {
                            number_decoder_internal::State &state,
                            std::vector<Result> &results) const;
 
-  const Trie<number_decoder_internal::Entry> &entries_;
+  Trie<number_decoder_internal::Entry> entries_;
 };
 
 }  // namespace mozc
diff --git a/src/prediction/prediction_test.gyp b/src/prediction/prediction_test.gyp
index 921a85f..08ba591 100644
--- a/src/prediction/prediction_test.gyp
+++ b/src/prediction/prediction_test.gyp
@@ -60,12 +60,12 @@
         '<(mozc_oss_src_dir)/data_manager/testing/mock_data_manager.gyp:mock_data_manager',
         '<(mozc_oss_src_dir)/dictionary/dictionary.gyp:dictionary',
         '<(mozc_oss_src_dir)/dictionary/dictionary.gyp:suffix_dictionary',
-        '<(mozc_oss_src_dir)/dictionary/pos_matcher.gyp:pos_matcher',
+        '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:pos_matcher',
         '<(mozc_oss_src_dir)/dictionary/system/system_dictionary.gyp:system_dictionary',
         '<(mozc_oss_src_dir)/dictionary/system/system_dictionary.gyp:value_dictionary',
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:commands_proto',
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:config_proto',
-        '<(mozc_oss_src_dir)/request/request.gyp:request_test_util',
+        '<(mozc_oss_src_dir)/request/request.gyp:request_test_util',	
         '<(mozc_oss_src_dir)/storage/storage.gyp:storage',
         '<(mozc_oss_src_dir)/testing/testing.gyp:gtest_main',
         '<(mozc_oss_src_dir)/testing/testing.gyp:mozctest',
diff --git a/src/prediction/predictor.cc b/src/prediction/predictor.cc
index e4ae774..58e7a95 100644
--- a/src/prediction/predictor.cc
+++ b/src/prediction/predictor.cc
@@ -57,82 +57,32 @@
 namespace mozc::prediction {
 namespace {
 
-constexpr int kPredictionSizeForDesktop = 100;
-
-// On mixed conversion mode PREDICTION (including PARTIAL_PREDICTION) behaves
-// like as conversion so the limit is same as conversion's one.
-constexpr int kPredictionSizeForMixedConersion = 200;
-
-bool IsMixedConversionEnabled(const ConversionRequest &request) {
-  return request.request().mixed_conversion();
-}
-
-ConversionRequest GetRequestForMixedConversion(
-    const ConversionRequest &request) {
-  DCHECK(request.HasConverterHistorySegments());
-  ConversionRequest::Options options = request.options();
-  switch (request.request_type()) {
-    case ConversionRequest::SUGGESTION: {
-      options.max_user_history_prediction_candidates_size = 3;
-      options.max_user_history_prediction_candidates_size_for_zero_query = 4;
-      options.max_dictionary_prediction_candidates_size = 20;
-      break;
-    }
-    case ConversionRequest::PARTIAL_SUGGESTION: {
-      options.max_dictionary_prediction_candidates_size = 20;
-      break;
-    }
-    case ConversionRequest::PARTIAL_PREDICTION: {
-      options.max_dictionary_prediction_candidates_size =
-          kPredictionSizeForMixedConersion;
-      break;
-    }
-    case ConversionRequest::PREDICTION: {
-      options.max_user_history_prediction_candidates_size = 3;
-      options.max_user_history_prediction_candidates_size_for_zero_query = 4;
-      options.max_dictionary_prediction_candidates_size =
-          kPredictionSizeForMixedConersion;
-      break;
-    }
-    default:
-      DLOG(ERROR) << "Unexpected request type: " << request.request_type();
+constexpr int kPredictionSize = 100;
+// On Mobile mode PREDICTION (including PARTIAL_PREDICTION) behaves like as
+// conversion so the limit is same as conversion's one.
+constexpr int kMobilePredictionSize = 200;
+
+size_t GetHistoryPredictionSizeFromRequest(const ConversionRequest &request) {
+  if (!request.request().zero_query_suggestion()) {
+    return 2;
   }
-  return ConversionRequestBuilder()
-      .SetConversionRequestView(request)
-      .SetOptions(std::move(options))
-      .Build();
-}
-
-// Fills empty lid and rid of candidates with the candidates of the same value.
-void MaybeFillFallbackPos(absl::Span<Result> results) {
-  absl::flat_hash_map<absl::string_view, Result *> posless_results;
-  for (Result &result : results) {
-    // Candidates with empty POS come before candidates with filled POS.
-    if (result.lid == 0 || result.rid == 0) {
-      posless_results[result.value] = &result;
-      continue;
-    }
-    if (!posless_results.contains(result.value)) {
-      continue;
-    }
-    Result *posless_result = posless_results[result.value];
-    if (posless_result->lid == 0) {
-      posless_result->lid = result.lid;
-    }
-    if (posless_result->rid == 0) {
-      posless_result->rid = result.rid;
-    }
-    if (posless_result->lid != 0 && posless_result->rid != 0) {
-      posless_results.erase(result.value);
-    }
+  if (request.request().has_decoder_experiment_params() &&
+      request.request()
+          .decoder_experiment_params()
+          .has_mobile_history_prediction_size()) {
+    return request.request()
+        .decoder_experiment_params()
+        .mobile_history_prediction_size();
   }
+  return 3;
 }
 
 }  // namespace
 
-Predictor::Predictor(std::unique_ptr<PredictorInterface> dictionary_predictor,
-                     std::unique_ptr<PredictorInterface> user_history_predictor,
-                     const ConverterInterface &converter)
+BasePredictor::BasePredictor(
+    std::unique_ptr<PredictorInterface> dictionary_predictor,
+    std::unique_ptr<PredictorInterface> user_history_predictor,
+    const ConverterInterface &converter)
     : dictionary_predictor_(std::move(dictionary_predictor)),
       user_history_predictor_(std::move(user_history_predictor)),
       converter_(converter) {
@@ -140,72 +90,70 @@ Predictor::Predictor(std::unique_ptr<PredictorInterface> dictionary_predictor,
   DCHECK(user_history_predictor_);
 }
 
-std::vector<Result> Predictor::Predict(const ConversionRequest &request) const {
-  DCHECK(request.request_type() == ConversionRequest::PREDICTION ||
-         request.request_type() == ConversionRequest::SUGGESTION ||
-         request.request_type() == ConversionRequest::PARTIAL_PREDICTION ||
-         request.request_type() == ConversionRequest::PARTIAL_SUGGESTION);
-  DCHECK(request.HasConverterHistorySegments());
-
-  if (request.request_type() == ConversionRequest::CONVERSION) {
-    return {};
-  }
-
-  if (request.config().presentation_mode()) {
-    return {};
-  }
-
-  // TODO(taku): Introduces independent sub predictors for desktop and mixed
-  // conversion.
-  return IsMixedConversionEnabled(request) ? PredictForMixedConversion(request)
-                                           : PredictForDesktop(request);
-}
-
-void Predictor::Finish(const ConversionRequest &request,
-                       absl::Span<const Result> results, uint32_t revert_id) {
+void BasePredictor::Finish(const ConversionRequest &request,
+                           absl::Span<const Result> results,
+                           uint32_t revert_id) {
   user_history_predictor_->Finish(request, results, revert_id);
 }
 
 // Since DictionaryPredictor is immutable, no need
 // to call DictionaryPredictor::Revert/Clear*/Finish methods.
-void Predictor::Revert(uint32_t revert_id) {
+void BasePredictor::Revert(uint32_t revert_id) {
   user_history_predictor_->Revert(revert_id);
 }
 
-bool Predictor::ClearAllHistory() {
+bool BasePredictor::ClearAllHistory() {
   return user_history_predictor_->ClearAllHistory();
 }
 
-bool Predictor::ClearUnusedHistory() {
+bool BasePredictor::ClearUnusedHistory() {
   return user_history_predictor_->ClearUnusedHistory();
 }
 
-bool Predictor::ClearHistoryEntry(const absl::string_view key,
-                                  const absl::string_view value) {
+bool BasePredictor::ClearHistoryEntry(const absl::string_view key,
+                                      const absl::string_view value) {
   return user_history_predictor_->ClearHistoryEntry(key, value);
 }
 
-bool Predictor::Wait() { return user_history_predictor_->Wait(); }
+bool BasePredictor::Wait() { return user_history_predictor_->Wait(); }
 
-bool Predictor::Sync() { return user_history_predictor_->Sync(); }
+bool BasePredictor::Sync() { return user_history_predictor_->Sync(); }
 
-bool Predictor::Reload() { return user_history_predictor_->Reload(); }
+bool BasePredictor::Reload() { return user_history_predictor_->Reload(); }
 
 // static
-std::unique_ptr<PredictorInterface> Predictor::CreatePredictor(
+std::unique_ptr<PredictorInterface> DesktopPredictor::CreateDesktopPredictor(
     std::unique_ptr<PredictorInterface> dictionary_predictor,
     std::unique_ptr<PredictorInterface> user_history_predictor,
     const ConverterInterface &converter) {
-  return std::make_unique<Predictor>(std::move(dictionary_predictor),
-                                     std::move(user_history_predictor),
-                                     converter);
+  return std::make_unique<DesktopPredictor>(std::move(dictionary_predictor),
+                                            std::move(user_history_predictor),
+                                            converter);
 }
 
-std::vector<Result> Predictor::PredictForDesktop(
+DesktopPredictor::DesktopPredictor(
+    std::unique_ptr<PredictorInterface> dictionary_predictor,
+    std::unique_ptr<PredictorInterface> user_history_predictor,
+    const ConverterInterface &converter)
+    : BasePredictor(std::move(dictionary_predictor),
+                    std::move(user_history_predictor), converter),
+      predictor_name_("DesktopPredictor") {}
+
+DesktopPredictor::~DesktopPredictor() = default;
+
+std::vector<Result> DesktopPredictor::Predict(
     const ConversionRequest &request) const {
-  DCHECK(!IsMixedConversionEnabled(request));
+  DCHECK(request.request_type() == ConversionRequest::PREDICTION ||
+         request.request_type() == ConversionRequest::SUGGESTION ||
+         request.request_type() == ConversionRequest::PARTIAL_PREDICTION ||
+         request.request_type() == ConversionRequest::PARTIAL_SUGGESTION);
+  DCHECK(request.HasConverterHistorySegments());
 
-  int prediction_size = kPredictionSizeForDesktop;
+  if (request.config().presentation_mode()) {
+    return {};
+  }
+
+  int prediction_size = kPredictionSize;
   if (request.request_type() == ConversionRequest::SUGGESTION) {
     prediction_size =
         std::clamp<int>(request.config().suggestions_size(), 1, 9);
@@ -250,12 +198,103 @@ std::vector<Result> Predictor::PredictForDesktop(
   return results;
 }
 
-std::vector<Result> Predictor::PredictForMixedConversion(
+// static
+std::unique_ptr<PredictorInterface> MobilePredictor::CreateMobilePredictor(
+    std::unique_ptr<PredictorInterface> dictionary_predictor,
+    std::unique_ptr<PredictorInterface> user_history_predictor,
+    const ConverterInterface &converter) {
+  return std::make_unique<MobilePredictor>(std::move(dictionary_predictor),
+                                           std::move(user_history_predictor),
+                                           converter);
+}
+
+MobilePredictor::MobilePredictor(
+    std::unique_ptr<PredictorInterface> dictionary_predictor,
+    std::unique_ptr<PredictorInterface> user_history_predictor,
+    const ConverterInterface &converter)
+    : BasePredictor(std::move(dictionary_predictor),
+                    std::move(user_history_predictor), converter),
+      predictor_name_("MobilePredictor") {}
+
+MobilePredictor::~MobilePredictor() = default;
+
+ConversionRequest MobilePredictor::GetRequestForPredict(
+    const ConversionRequest &request) {
+  DCHECK(request.HasConverterHistorySegments());
+  ConversionRequest::Options options = request.options();
+  size_t history_prediction_size = GetHistoryPredictionSizeFromRequest(request);
+  switch (request.request_type()) {
+    case ConversionRequest::SUGGESTION: {
+      options.max_user_history_prediction_candidates_size =
+          history_prediction_size;
+      options.max_user_history_prediction_candidates_size_for_zero_query = 4;
+      options.max_dictionary_prediction_candidates_size = 20;
+      break;
+    }
+    case ConversionRequest::PARTIAL_SUGGESTION: {
+      options.max_dictionary_prediction_candidates_size = 20;
+      break;
+    }
+    case ConversionRequest::PARTIAL_PREDICTION: {
+      options.max_dictionary_prediction_candidates_size = kMobilePredictionSize;
+      break;
+    }
+    case ConversionRequest::PREDICTION: {
+      options.max_user_history_prediction_candidates_size =
+          history_prediction_size;
+      options.max_user_history_prediction_candidates_size_for_zero_query = 4;
+      options.max_dictionary_prediction_candidates_size = kMobilePredictionSize;
+      break;
+    }
+    default:
+      DLOG(ERROR) << "Unexpected request type: " << request.request_type();
+  }
+  return ConversionRequestBuilder()
+      .SetConversionRequestView(request)
+      .SetOptions(std::move(options))
+      .Build();
+}
+
+namespace {
+// Fills empty lid and rid of candidates with the candidates of the same value.
+void MaybeFillFallbackPos(absl::Span<Result> results) {
+  absl::flat_hash_map<absl::string_view, Result *> posless_results;
+  for (Result &result : results) {
+    // Candidates with empty POS come before candidates with filled POS.
+    if (result.lid == 0 || result.rid == 0) {
+      posless_results[result.value] = &result;
+      continue;
+    }
+    if (!posless_results.contains(result.value)) {
+      continue;
+    }
+    Result *posless_result = posless_results[result.value];
+    if (posless_result->lid == 0) {
+      posless_result->lid = result.lid;
+    }
+    if (posless_result->rid == 0) {
+      posless_result->rid = result.rid;
+    }
+    if (posless_result->lid != 0 && posless_result->rid != 0) {
+      posless_results.erase(result.value);
+    }
+  }
+}
+}  // namespace
+
+std::vector<Result> MobilePredictor::Predict(
     const ConversionRequest &request) const {
-  DCHECK(IsMixedConversionEnabled(request));
+  DCHECK(request.request_type() == ConversionRequest::PREDICTION ||
+         request.request_type() == ConversionRequest::SUGGESTION ||
+         request.request_type() == ConversionRequest::PARTIAL_PREDICTION ||
+         request.request_type() == ConversionRequest::PARTIAL_SUGGESTION);
+  DCHECK(request.HasConverterHistorySegments());
+
+  if (request.config().presentation_mode()) {
+    return {};
+  }
 
-  const ConversionRequest request_for_predict =
-      GetRequestForMixedConversion(request);
+  const ConversionRequest request_for_predict = GetRequestForPredict(request);
 
   DCHECK(request_for_predict.HasConverterHistorySegments());
 
diff --git a/src/prediction/predictor.h b/src/prediction/predictor.h
index 13528a5..d5c4dfb 100644
--- a/src/prediction/predictor.h
+++ b/src/prediction/predictor.h
@@ -44,21 +44,12 @@
 
 namespace mozc::prediction {
 
-class Predictor : public PredictorInterface {
+class BasePredictor : public PredictorInterface {
  public:
   // Initializes the composite of predictor with given sub-predictors.
-  Predictor(std::unique_ptr<PredictorInterface> dictionary_predictor,
-            std::unique_ptr<PredictorInterface> user_history_predictor,
-            const ConverterInterface &converter);
-
-  static std::unique_ptr<PredictorInterface> CreatePredictor(
-      std::unique_ptr<PredictorInterface> dictionary_predictor,
-      std::unique_ptr<PredictorInterface> user_history_predictor,
-      const ConverterInterface &converter);
-
-  std::vector<Result> Predict(const ConversionRequest &request) const;
-
-  absl::string_view GetPredictorName() const override { return "Predictor"; }
+  BasePredictor(std::unique_ptr<PredictorInterface> dictionary_predictor,
+                std::unique_ptr<PredictorInterface> user_history_predictor,
+                const ConverterInterface &converter);
 
   // Hook(s) for all mutable operations.
   void Finish(const ConversionRequest &request,
@@ -86,41 +77,62 @@ class Predictor : public PredictorInterface {
   // Waits for syncer to complete.
   bool Wait() override;
 
- private:
-  std::vector<Result> PredictForDesktop(const ConversionRequest &request) const;
-
-  std::vector<Result> PredictForMixedConversion(
-      const ConversionRequest &request) const;
-
+ protected:
   std::unique_ptr<PredictorInterface> dictionary_predictor_;
   std::unique_ptr<PredictorInterface> user_history_predictor_;
 
+ private:
   const ConverterInterface &converter_;
 };
 
-// Alias for backward compatibility.
-class DesktopPredictor : public Predictor {
+class DesktopPredictor : public BasePredictor {
  public:
   static std::unique_ptr<PredictorInterface> CreateDesktopPredictor(
       std::unique_ptr<PredictorInterface> dictionary_predictor,
       std::unique_ptr<PredictorInterface> user_history_predictor,
-      const ConverterInterface &converter) {
-    return Predictor::CreatePredictor(std::move(dictionary_predictor),
-                                      std::move(user_history_predictor),
-                                      converter);
+      const ConverterInterface &converter);
+
+  DesktopPredictor(std::unique_ptr<PredictorInterface> dictionary_predictor,
+                   std::unique_ptr<PredictorInterface> user_history_predictor,
+                   const ConverterInterface &converter);
+  ~DesktopPredictor() override;
+
+  std::vector<Result> Predict(const ConversionRequest &request) const override;
+
+  absl::string_view GetPredictorName() const override {
+    return predictor_name_;
   }
+
+ private:
+  const std::string predictor_name_;
 };
 
-class MobilePredictor : public Predictor {
+// TODO(taku): Renamed it to more general name, e.g. UnifiedDecoer
+// as we would like to use the same and unified decoder for desktop and
+// mobile.
+class MobilePredictor : public BasePredictor {
  public:
   static std::unique_ptr<PredictorInterface> CreateMobilePredictor(
       std::unique_ptr<PredictorInterface> dictionary_predictor,
       std::unique_ptr<PredictorInterface> user_history_predictor,
-      const ConverterInterface &converter) {
-    return Predictor::CreatePredictor(std::move(dictionary_predictor),
-                                      std::move(user_history_predictor),
-                                      converter);
+      const ConverterInterface &converter);
+
+  MobilePredictor(std::unique_ptr<PredictorInterface> dictionary_predictor,
+                  std::unique_ptr<PredictorInterface> user_history_predictor,
+                  const ConverterInterface &converter);
+  ~MobilePredictor() override;
+
+  std::vector<Result> Predict(const ConversionRequest &request) const override;
+
+  absl::string_view GetPredictorName() const override {
+    return predictor_name_;
   }
+
+  static ConversionRequest GetRequestForPredict(
+      const ConversionRequest &request);
+
+ private:
+  const std::string predictor_name_;
 };
 
 }  // namespace mozc::prediction
diff --git a/src/prediction/predictor_test.cc b/src/prediction/predictor_test.cc
index 60ac923..be30bac 100644
--- a/src/prediction/predictor_test.cc
+++ b/src/prediction/predictor_test.cc
@@ -148,7 +148,7 @@ class MockPredictor : public PredictorInterface {
 
 }  // namespace
 
-class MixedDecodingPredictorTest : public ::testing::Test {
+class MobilePredictorTest : public ::testing::Test {
  protected:
   void SetUp() override {
     config_ = std::make_unique<config::Config>();
@@ -179,9 +179,9 @@ class MixedDecodingPredictorTest : public ::testing::Test {
   commands::Context context_;
 };
 
-TEST_F(MixedDecodingPredictorTest, CallPredictorsForMobileSuggestion) {
+TEST_F(MobilePredictorTest, CallPredictorsForMobileSuggestion) {
   MockConverter converter;
-  auto predictor = std::make_unique<Predictor>(
+  auto predictor = std::make_unique<MobilePredictor>(
       std::make_unique<CheckCandSizeDictionaryPredictor>(20),
       std::make_unique<CheckCandSizeUserHistoryPredictor>(3, 4), converter);
   const ConversionRequest convreq =
@@ -189,9 +189,9 @@ TEST_F(MixedDecodingPredictorTest, CallPredictorsForMobileSuggestion) {
   EXPECT_FALSE(predictor->Predict(convreq).empty());
 }
 
-TEST_F(MixedDecodingPredictorTest, CallPredictorsForMobilePartialSuggestion) {
+TEST_F(MobilePredictorTest, CallPredictorsForMobilePartialSuggestion) {
   MockConverter converter;
-  auto predictor = std::make_unique<Predictor>(
+  auto predictor = std::make_unique<MobilePredictor>(
       std::make_unique<CheckCandSizeDictionaryPredictor>(20),
       // We don't call history predictor
       std::make_unique<CheckCandSizeUserHistoryPredictor>(-1, -1), converter);
@@ -200,9 +200,9 @@ TEST_F(MixedDecodingPredictorTest, CallPredictorsForMobilePartialSuggestion) {
   EXPECT_FALSE(predictor->Predict(convreq).empty());
 }
 
-TEST_F(MixedDecodingPredictorTest, CallPredictorsForMobilePrediction) {
+TEST_F(MobilePredictorTest, CallPredictorsForMobilePrediction) {
   MockConverter converter;
-  auto predictor = std::make_unique<Predictor>(
+  auto predictor = std::make_unique<MobilePredictor>(
       std::make_unique<CheckCandSizeDictionaryPredictor>(200),
       std::make_unique<CheckCandSizeUserHistoryPredictor>(3, 4), converter);
   const ConversionRequest convreq =
@@ -210,14 +210,14 @@ TEST_F(MixedDecodingPredictorTest, CallPredictorsForMobilePrediction) {
   EXPECT_FALSE(predictor->Predict(convreq).empty());
 }
 
-TEST_F(MixedDecodingPredictorTest, CallPredictorsForMobilePartialPrediction) {
+TEST_F(MobilePredictorTest, CallPredictorsForMobilePartialPrediction) {
   MockConverter converter;
   std::unique_ptr<engine::Modules> modules =
       engine::ModulesPresetBuilder()
           .PresetDictionary(std::make_unique<MockDictionary>())
           .Build(std::make_unique<testing::MockDataManager>())
           .value();
-  auto predictor = std::make_unique<Predictor>(
+  auto predictor = std::make_unique<MobilePredictor>(
       std::make_unique<CheckCandSizeDictionaryPredictor>(200),
       std::make_unique<UserHistoryPredictor>(*modules), converter);
   const ConversionRequest convreq =
@@ -225,7 +225,7 @@ TEST_F(MixedDecodingPredictorTest, CallPredictorsForMobilePartialPrediction) {
   EXPECT_FALSE(predictor->Predict(convreq).empty());
 }
 
-TEST_F(MixedDecodingPredictorTest, CallPredictForRequestMobile) {
+TEST_F(MobilePredictorTest, CallPredictForRequestMobile) {
   auto predictor1 = std::make_unique<MockPredictor>();
   auto predictor2 = std::make_unique<MockPredictor>();
   const std::vector<Result> results(2);
@@ -237,7 +237,7 @@ TEST_F(MixedDecodingPredictorTest, CallPredictForRequestMobile) {
       .WillOnce(Return(results));
 
   MockConverter converter;
-  auto predictor = std::make_unique<Predictor>(
+  auto predictor = std::make_unique<MobilePredictor>(
       std::move(predictor1), std::move(predictor2), converter);
   const ConversionRequest convreq =
       CreateConversionRequest(ConversionRequest::SUGGESTION);
@@ -276,7 +276,7 @@ class PredictorTest : public ::testing::Test {
 
 TEST_F(PredictorTest, AllPredictorsReturnTrue) {
   MockConverter converter;
-  auto predictor = std::make_unique<Predictor>(
+  auto predictor = std::make_unique<DesktopPredictor>(
       std::make_unique<NullPredictor>(true),
       std::make_unique<NullPredictor>(true), converter);
   const ConversionRequest convreq =
@@ -285,7 +285,7 @@ TEST_F(PredictorTest, AllPredictorsReturnTrue) {
 
 TEST_F(PredictorTest, MixedReturnValue) {
   MockConverter converter;
-  auto predictor = std::make_unique<Predictor>(
+  auto predictor = std::make_unique<DesktopPredictor>(
       std::make_unique<NullPredictor>(true),
       std::make_unique<NullPredictor>(false), converter);
   const ConversionRequest convreq =
@@ -295,7 +295,7 @@ TEST_F(PredictorTest, MixedReturnValue) {
 
 TEST_F(PredictorTest, AllPredictorsReturnFalse) {
   MockConverter converter;
-  auto predictor = std::make_unique<Predictor>(
+  auto predictor = std::make_unique<DesktopPredictor>(
       std::make_unique<NullPredictor>(false),
       std::make_unique<NullPredictor>(false), converter);
   const ConversionRequest convreq =
@@ -307,7 +307,7 @@ TEST_F(PredictorTest, CallPredictorsForSuggestion) {
   MockConverter converter;
   const int suggestions_size =
       config::ConfigHandler::DefaultConfig().suggestions_size();
-  auto predictor = std::make_unique<Predictor>(
+  auto predictor = std::make_unique<DesktopPredictor>(
       // -1 as UserHistoryPredictor returns 1 result.
       std::make_unique<CheckCandSizeDictionaryPredictor>(suggestions_size - 1),
       std::make_unique<CheckCandSizeUserHistoryPredictor>(suggestions_size,
@@ -321,7 +321,7 @@ TEST_F(PredictorTest, CallPredictorsForSuggestion) {
 TEST_F(PredictorTest, CallPredictorsForPrediction) {
   MockConverter converter;
   constexpr int kPredictionSize = 100;
-  auto predictor = std::make_unique<Predictor>(
+  auto predictor = std::make_unique<DesktopPredictor>(
       // -1 as UserHistoryPredictor returns 1 result.
       std::make_unique<CheckCandSizeDictionaryPredictor>(kPredictionSize - 1),
       std::make_unique<CheckCandSizeUserHistoryPredictor>(kPredictionSize,
@@ -344,7 +344,7 @@ TEST_F(PredictorTest, CallPredictForRequest) {
       .WillOnce(Return(results));
 
   MockConverter converter;
-  auto predictor = std::make_unique<Predictor>(
+  auto predictor = std::make_unique<DesktopPredictor>(
       std::move(predictor1), std::move(predictor2), converter);
   const ConversionRequest convreq =
       CreateConversionRequest(ConversionRequest::SUGGESTION);
@@ -357,7 +357,7 @@ TEST_F(PredictorTest, DisableAllSuggestion) {
   const auto *pred1 = predictor1.get();  // Keep the reference
   const auto *pred2 = predictor2.get();  // Keep the reference
   MockConverter converter;
-  auto predictor = std::make_unique<Predictor>(
+  auto predictor = std::make_unique<DesktopPredictor>(
       std::move(predictor1), std::move(predictor2), converter);
   config_->set_presentation_mode(true);
   const ConversionRequest convreq1 =
@@ -375,7 +375,7 @@ TEST_F(PredictorTest, DisableAllSuggestion) {
   EXPECT_TRUE(pred2->predict_called());
 }
 
-TEST_F(MixedDecodingPredictorTest, FillPos) {
+TEST_F(MobilePredictorTest, FillPos) {
   auto mock_dictionary_predictor = std::make_unique<MockPredictor>();
   auto mock_history_predictor = std::make_unique<MockPredictor>();
   auto add_candidate = [](absl::string_view key, absl::string_view value,
@@ -402,9 +402,9 @@ TEST_F(MixedDecodingPredictorTest, FillPos) {
       .WillOnce(Return(predictor_results));
 
   MockConverter converter;
-  auto predictor =
-      std::make_unique<Predictor>(std::move(mock_dictionary_predictor),
-                                  std::move(mock_history_predictor), converter);
+  auto predictor = std::make_unique<MobilePredictor>(
+      std::move(mock_dictionary_predictor), std::move(mock_history_predictor),
+      converter);
 
   const ConversionRequest convreq =
       CreateConversionRequest(ConversionRequest::SUGGESTION);
diff --git a/src/prediction/result.cc b/src/prediction/result.cc
index 4831397..4322822 100644
--- a/src/prediction/result.cc
+++ b/src/prediction/result.cc
@@ -31,9 +31,9 @@
 
 #include <tuple>
 
-#include "absl/base/nullability.h"
 #include "absl/log/log.h"
 #include "absl/strings/string_view.h"
+#include "base/absl_nullability.h"
 #include "base/strings/unicode.h"
 #include "composer/query.h"
 #include "converter/candidate.h"
@@ -131,39 +131,5 @@ void PopulateTypeCorrectedQuery(
   result->wcost += adjustment;
 }
 
-std::string GetPredictionTypeDebugString(PredictionTypes types) {
-  std::string debug_desc;
-  if (types & PredictionType::UNIGRAM) {
-    debug_desc.append(1, 'U');
-  }
-  if (types & PredictionType::BIGRAM) {
-    debug_desc.append(1, 'B');
-  }
-  if (types & PredictionType::REALTIME_TOP) {
-    debug_desc.append("R1");
-  } else if (types & PredictionType::REALTIME) {
-    debug_desc.append(1, 'R');
-  }
-  if (types & PredictionType::SUFFIX) {
-    debug_desc.append(1, 'S');
-  }
-  if (types & PredictionType::ENGLISH) {
-    debug_desc.append(1, 'E');
-  }
-  if (types & PredictionType::TYPING_CORRECTION) {
-    debug_desc.append(1, 'T');
-  }
-  if (types & PredictionType::TYPING_COMPLETION) {
-    debug_desc.append(1, 'C');
-  }
-  if (types & PredictionType::SUPPLEMENTAL_MODEL) {
-    debug_desc.append(1, 'X');
-  }
-  if (types & PredictionType::KEY_EXPANDED_IN_DICTIONARY) {
-    debug_desc.append(1, 'K');
-  }
-  return debug_desc;
-}
-
 }  // namespace prediction
 }  // namespace mozc
diff --git a/src/prediction/result.h b/src/prediction/result.h
index 25bc063..1fcabdf 100644
--- a/src/prediction/result.h
+++ b/src/prediction/result.h
@@ -36,11 +36,11 @@
 #include <utility>
 #include <vector>
 
-#include "absl/base/nullability.h"
 #include "absl/strings/str_format.h"
 #include "absl/strings/str_join.h"
 #include "absl/strings/str_split.h"
 #include "absl/strings/string_view.h"
+#include "base/absl_nullability.h"
 #include "composer/query.h"
 #include "dictionary/dictionary_token.h"
 #include "prediction/zero_query_dict.h"
@@ -124,6 +124,7 @@ struct Result {
   // "わたしの|なまえは|なかのです", " 私の|名前は|中野です",
   // |inner_segment_boundary| have [(4,2), (4, 3), (5, 4)].
   std::vector<uint32_t> inner_segment_boundary;
+  uint16_t zero_query_type = 0;
   size_t consumed_key_size = 0;
   // The total penalty added to this result.
   int penalty = 0;
@@ -153,12 +154,14 @@ struct Result {
     absl::Format(
         &sink,
         "key: %s, value: %s, types: %d, wcost: %d, cost: %d, cost_before: %d, "
-        "lid: %d, rid: %d, attrs: %d, bdd: %s, consumed_key_size: %d, penalty: "
-        "%d, tc_adjustment: %d, removed: %v",
+        "lid: %d, "
+        "rid: %d, attrs: %d, bdd: %s, srcinfo: %d, "
+        "consumed_key_size: %d, penalty: %d, tc_adjustment: %d, removed: %v",
         r.key, r.value, r.types, r.wcost, r.cost, r.cost_before_rescoring,
         r.lid, r.rid, r.candidate_attributes,
-        absl::StrJoin(r.inner_segment_boundary, ","), r.consumed_key_size,
-        r.penalty, r.typing_correction_adjustment, r.removed);
+        absl::StrJoin(r.inner_segment_boundary, ","), r.zero_query_type,
+        r.consumed_key_size, r.penalty, r.typing_correction_adjustment,
+        r.removed);
 #ifndef NDEBUG
     sink.Append(", log:\n");
     for (absl::string_view line : absl::StrSplit(r.log, '\n')) {
@@ -208,9 +211,6 @@ void PopulateTypeCorrectedQuery(
     const composer::TypeCorrectedQuery &typing_corrected_result,
     Result *absl_nonnull result);
 
-// Makes debug string from `types`.
-std::string GetPredictionTypeDebugString(PredictionTypes types);
-
 #ifndef NDEBUG
 #define MOZC_WORD_LOG(result, ...)                                  \
   {                                                                 \
diff --git a/src/prediction/user_history_predictor.cc b/src/prediction/user_history_predictor.cc
index c5336e0..3013e87 100644
--- a/src/prediction/user_history_predictor.cc
+++ b/src/prediction/user_history_predictor.cc
@@ -83,17 +83,19 @@ using ::mozc::composer::TypeCorrectedQuery;
 
 // Finds suggestion candidates from the most recent 3000 history in LRU.
 // We don't check all history, since suggestion is called every key event
-constexpr size_t kDefaultMaxSuggestionTrial = 3000;
+constexpr size_t kMaxSuggestionTrial = 3000;
 
 // Finds suffix matches of history_segments from the most recent 500 histories
 // in LRU.
 constexpr size_t kMaxPrevValueTrial = 500;
 
-// On-memory LRU cache size.
+// Cache size
 // Typically memory/storage footprint becomes kLruCacheSize * 70 bytes.
-// Note that actual entries serialized to the disk may be smaller
-// than this size.
+#ifdef __ANDROID__
+constexpr size_t kLruCacheSize = 4000;
+#else   // __ANDROID__
 constexpr size_t kLruCacheSize = 10000;
+#endif  // __ANDROID__
 
 // Don't save key/value that are
 // longer than kMaxCandidateSize to avoid memory explosion
@@ -115,6 +117,8 @@ constexpr absl::string_view kEmojiDescription = "絵文字";
 
 constexpr size_t kRevertCacheSize = 16;
 
+constexpr absl::Duration k62Days = absl::Hours(62 * 24);
+
 // TODO(peria, hidehiko): Unify this checker and IsEmojiCandidate in
 //     EmojiRewriter.  If you make similar functions before the merging in
 //     case, put a similar note to avoid twisted dependency.
@@ -230,11 +234,20 @@ bool UserHistoryStorage::Load() {
     return false;
   }
 
+  const int num_deleted = DeleteEntriesUntouchedFor62Days();
+  LOG_IF(INFO, num_deleted > 0)
+      << num_deleted << " old entries were not loaded "
+      << proto_.entries_size();
+
   MOZC_VLOG(1) << "Loaded user history, size=" << proto_.entries_size();
   return true;
 }
 
 bool UserHistoryStorage::Save() {
+  const int num_deleted = DeleteEntriesUntouchedFor62Days();
+  LOG_IF(INFO, num_deleted > 0)
+      << num_deleted << " old entries were removed before save";
+
   std::string output;
   if (!proto_.AppendToString(&output)) {
     LOG(ERROR) << "AppendToString failed";
@@ -256,6 +269,37 @@ bool UserHistoryStorage::Save() {
   return true;
 }
 
+int UserHistoryStorage::DeleteEntriesBefore(uint64_t timestamp) {
+  // Partition entries so that [0, new_size) is kept and [new_size, size) is
+  // deleted.
+  int i = 0;
+  int new_size = proto_.entries_size();
+  while (i < new_size) {
+    if (proto_.entries(i).last_access_time() >= timestamp) {
+      ++i;
+      continue;
+    }
+    // Swap this entry (to be deleted) and the last entry (not yet checked) for
+    // batch deletion.
+    --new_size;
+    if (i != new_size) {
+      proto_.mutable_entries()->SwapElements(i, new_size);
+    }
+  }
+  if (new_size == proto_.entries_size()) {
+    return 0;
+  }
+  const int num_deleted = proto_.entries_size() - new_size;
+  proto_.mutable_entries()->DeleteSubrange(new_size, num_deleted);
+  return num_deleted;
+}
+
+int UserHistoryStorage::DeleteEntriesUntouchedFor62Days() {
+  const absl::Time now = Clock::GetAbslTime();
+  const absl::Time timestamp = std::max(now - k62Days, absl::UnixEpoch());
+  return DeleteEntriesBefore(absl::ToUnixSeconds(timestamp));
+}
+
 bool UserHistoryPredictor::EntryPriorityQueue::Push(Entry *entry) {
   DCHECK(entry);
   if (!seen_.insert(absl::HashOf(entry->value())).second) {
@@ -286,6 +330,7 @@ UserHistoryPredictor::EntryPriorityQueue::NewEntry() {
 UserHistoryPredictor::UserHistoryPredictor(const engine::Modules &modules)
     : dictionary_(modules.GetDictionary()),
       user_dictionary_(modules.GetUserDictionary()),
+      predictor_name_("UserHistoryPredictor"),
       updated_(false),
       dic_(new DicCache(UserHistoryPredictor::cache_size())),
       modules_(modules),
@@ -327,7 +372,10 @@ bool UserHistoryPredictor::CheckSyncerAndDelete() const {
   return true;
 }
 
-bool UserHistoryPredictor::Sync() { return AsyncSave(); }
+bool UserHistoryPredictor::Sync() {
+  return AsyncSave();
+  // return Save();   blocking version
+}
 
 bool UserHistoryPredictor::Reload() {
   WaitForSyncer();
@@ -403,27 +451,10 @@ bool UserHistoryPredictor::Save() {
 
   UserHistoryStorage history(filename);
 
-  // Copy the current values to avoid these values from being updated in
-  // the actual copy operations.
-  const int store_size = cache_store_size_.load();
-  const absl::Duration lifetime_days = entry_lifetime_days_as_duration();
-  auto &proto = history.GetProto();
-
-  const absl::Time now = Clock::GetAbslTime();
-  for (const DicElement &elm : *dic_) {
-    if (store_size > 0 && proto.entries_size() >= store_size) {
-      break;
-    }
-    if (absl::FromUnixSeconds(elm.value.last_access_time()) + lifetime_days <
-        now) {
-      continue;
-    }
-    *proto.add_entries() = elm.value;
+  for (const DicElement *elm = dic_->Tail(); elm != nullptr; elm = elm->prev) {
+    *history.GetProto().add_entries() = elm->value;
   }
 
-  // Reverse the contents to keep the LRU order when loading.
-  absl::c_reverse(*proto.mutable_entries());
-
   if (!history.Save()) {
     LOG(ERROR) << "UserHistoryStorage::Save() failed";
     return false;
@@ -1124,9 +1155,6 @@ std::vector<Result> UserHistoryPredictor::Predict(
 
   const auto &params = request.request().decoder_experiment_params();
 
-  SetEntryLifetimeDays(params.user_history_entry_lifetime_days());
-  SetCacheStoreSize(params.user_history_cache_store_size());
-
   const bool is_zero_query =
       request.request().zero_query_suggestion() && is_empty_input;
   size_t max_prediction_size =
@@ -1226,10 +1254,8 @@ const UserHistoryPredictor::Entry *UserHistoryPredictor::LookupPrevEntry(
 
   // Check the timestamp of prev_entry.
   const absl::Time now = Clock::GetAbslTime();
-  const absl::Duration lifetime_days = entry_lifetime_days_as_duration();
   if (prev_entry != nullptr &&
-      absl::FromUnixSeconds(prev_entry->last_access_time()) + lifetime_days <
-          now) {
+      absl::FromUnixSeconds(prev_entry->last_access_time()) + k62Days < now) {
     updated_ = true;  // We found an entry to be deleted at next save.
     return nullptr;
   }
@@ -1299,12 +1325,6 @@ UserHistoryPredictor::GetEntry_QueueFromHistoryDictionary(
   EntryPriorityQueue entry_queue;
   const absl::Time now = Clock::GetAbslTime();
   int trial = 0;
-  int max_trial = request.request()
-                      .decoder_experiment_params()
-                      .user_history_max_suggestion_trial();
-  if (max_trial <= 0) max_trial = kDefaultMaxSuggestionTrial;
-  const absl::Duration lifetime_days = entry_lifetime_days_as_duration();
-
   for (const DicElement &elm : *dic_) {
     // already found enough entry_queue.
     if (entry_queue.size() >= max_entry_queue_size) {
@@ -1314,13 +1334,12 @@ UserHistoryPredictor::GetEntry_QueueFromHistoryDictionary(
     if (!IsValidEntryIgnoringRemovedField(elm.value)) {
       continue;
     }
-    if (absl::FromUnixSeconds(elm.value.last_access_time()) + lifetime_days <
-        now) {
+    if (absl::FromUnixSeconds(elm.value.last_access_time()) + k62Days < now) {
       updated_ = true;  // We found an entry to be deleted at next save.
       continue;
     }
     if (request.request_type() == ConversionRequest::SUGGESTION &&
-        trial++ >= max_trial) {
+        trial++ >= kMaxSuggestionTrial) {
       MOZC_VLOG(2) << "too many trials";
       break;
     }
diff --git a/src/prediction/user_history_predictor.h b/src/prediction/user_history_predictor.h
index cc46824..b5432a8 100644
--- a/src/prediction/user_history_predictor.h
+++ b/src/prediction/user_history_predictor.h
@@ -68,6 +68,14 @@ class UserHistoryStorage {
   // Saves history into encrypted file.
   bool Save();
 
+  // Deletes entries before the given timestamp.  Returns the number of deleted
+  // entries.
+  int DeleteEntriesBefore(uint64_t timestamp);
+
+  // Deletes entries that are not accessed for 62 days.  Returns the number of
+  // deleted entries.
+  int DeleteEntriesUntouchedFor62Days();
+
   mozc::user_history_predictor::UserHistory &GetProto() { return proto_; }
   const mozc::user_history_predictor::UserHistory &GetProto() const {
     return proto_;
@@ -122,7 +130,7 @@ class UserHistoryPredictor : public PredictorInterface {
   static std::string GetUserHistoryFileName();
 
   absl::string_view GetPredictorName() const override {
-    return "UserHistoryPredictor";
+    return predictor_name_;
   }
 
   // From user_history_predictor.proto
@@ -442,34 +450,15 @@ class UserHistoryPredictor : public PredictorInterface {
   void MaybeRemoveUnselectedHistory(absl::Span<const Result> results,
                                     RevertEntries *revert_entries);
 
-  // Default entry lifetime period.
-  // Entries will be automatically purged after this period.
-  static constexpr int kDefaultEntryLifetimeDays = 62;
-
-  void SetEntryLifetimeDays(int days) const {
-    entry_lifetime_days_.store(days <= 0 ? kDefaultEntryLifetimeDays : days);
-  }
-
-  void SetCacheStoreSize(int size) const { cache_store_size_.store(size); }
-
   const dictionary::DictionaryInterface &dictionary_;
   const dictionary::UserDictionaryInterface &user_dictionary_;
+  const std::string predictor_name_;
 
   mutable std::atomic<bool> updated_;
   std::unique_ptr<DicCache> dic_;
   mutable std::optional<BackgroundFuture<void>> sync_;
   const engine::Modules &modules_;
 
-  mutable std::atomic<int> entry_lifetime_days_ = kDefaultEntryLifetimeDays;
-
-  absl::Duration entry_lifetime_days_as_duration() const {
-    return absl::Hours(24 * entry_lifetime_days_.load());
-  }
-
-  // The maximum entries size serialized to the file.
-  // When zero, all entries in the on-memory LRU are stored.
-  mutable std::atomic<int> cache_store_size_ = 0;
-
   // Internal LRU cache to store dic_key/Entry to be reverted.
   storage::LruCache<uint64_t, RevertEntries> revert_cache_;
 };
diff --git a/src/prediction/user_history_predictor_test.cc b/src/prediction/user_history_predictor_test.cc
index 124f561..954b52e 100644
--- a/src/prediction/user_history_predictor_test.cc
+++ b/src/prediction/user_history_predictor_test.cc
@@ -119,11 +119,6 @@ class UserHistoryPredictorTestPeer
   PEER_METHOD(LookupEntry);
   PEER_METHOD(RemoveNgramChain);
   PEER_METHOD(WaitForSyncer);
-  PEER_METHOD(Save);
-  PEER_METHOD(SetEntryLifetimeDays);
-  PEER_METHOD(SetCacheStoreSize);
-  PEER_VARIABLE(cache_store_size_);
-  PEER_VARIABLE(entry_lifetime_days_);
   PEER_VARIABLE(dic_);
   PEER_DECLARE(MatchType);
   PEER_DECLARE(RemoveNgramChainResult);
@@ -2725,6 +2720,68 @@ TEST_F(UserHistoryPredictorTest, UserHistoryStorage) {
   EXPECT_OK(FileUtil::UnlinkIfExists(filename));
 }
 
+TEST_F(UserHistoryPredictorTest, UserHistoryStorageContainingOldEntries) {
+  ScopedClockMock clock(absl::FromUnixSeconds(1));
+  TempDirectory temp_dir = testing::MakeTempDirectoryOrDie();
+
+  // Create a history proto containing old entries (timestamp = 1).
+  user_history_predictor::UserHistory history;
+  for (int i = 0; i < 10; ++i) {
+    auto *entry = history.add_entries();
+    entry->set_key(absl::StrFormat("old_key%d", i));
+    entry->set_value(absl::StrFormat("old_value%d", i));
+    entry->set_last_access_time(absl::ToUnixSeconds(clock->GetAbslTime()));
+  }
+  clock->Advance(absl::Hours(24 * 63));  // Advance clock for 63 days.
+  for (int i = 0; i < 10; ++i) {
+    auto *entry = history.add_entries();
+    entry->set_key(absl::StrFormat("new_key%d", i));
+    entry->set_value(absl::StrFormat("new_value%d", i));
+    entry->set_last_access_time(absl::ToUnixSeconds(clock->GetAbslTime()));
+  }
+
+  // Test Load().
+  {
+    const std::string filename =
+        FileUtil::JoinPath(temp_dir.path(), "testload");
+    // Write directly to the file to keep old entries for testing.
+    storage::EncryptedStringStorage file_storage(filename);
+    ASSERT_TRUE(file_storage.Save(history.SerializeAsString()));
+
+    UserHistoryStorage storage(filename);
+    ASSERT_TRUE(storage.Load());
+    // Only the new entries are loaded.
+    EXPECT_EQ(storage.GetProto().entries_size(), 10);
+    for (const auto &entry : storage.GetProto().entries()) {
+      EXPECT_TRUE(entry.key().starts_with("new_"));
+      EXPECT_TRUE(entry.value().starts_with("new_"));
+    }
+    EXPECT_OK(FileUtil::Unlink(filename));
+  }
+
+  // Test Save().
+  {
+    const std::string filename =
+        FileUtil::JoinPath(temp_dir.path(), "testsave");
+    UserHistoryStorage storage(filename);
+    storage.GetProto() = history;
+    ASSERT_TRUE(storage.Save());
+
+    // Directly open the file to check the actual entries written.
+    storage::EncryptedStringStorage file_storage(filename);
+    std::string content;
+    ASSERT_TRUE(file_storage.Load(&content));
+    user_history_predictor::UserHistory modified_history;
+    ASSERT_TRUE(modified_history.ParseFromString(content));
+    EXPECT_EQ(modified_history.entries_size(), 10);
+    for (const auto &entry : storage.GetProto().entries()) {
+      EXPECT_TRUE(entry.key().starts_with("new_"));
+      EXPECT_TRUE(entry.value().starts_with("new_"));
+    }
+    EXPECT_OK(FileUtil::Unlink(filename));
+  }
+}
+
 TEST_F(UserHistoryPredictorTest, UserHistoryStorageContainingInvalidEntries) {
   // This test checks invalid entries are not loaded into dic_.
   ScopedClockMock clock(absl::FromUnixSeconds(1));
@@ -4583,101 +4640,6 @@ TEST_F(UserHistoryPredictorTest, PunctuationLinkDesktop) {
   }
 }
 
-TEST_F(UserHistoryPredictorTest, EntriesMaxTrialSize) {
-  UserHistoryPredictor *predictor = GetUserHistoryPredictorWithClearedHistory();
-  UserHistoryPredictorTestPeer predictor_peer(*predictor);
-
-  // Insert one entry per day.
-  for (int i = 0; i < 30; ++i) {
-    Segments segments;
-    const ConversionRequest convreq = SetUpInputForConversion(
-        absl::StrFormat("わたしのなまえ%2d", i), &composer_, &segments);
-    AddCandidate(absl::StrFormat("私の名前%2d", i), &segments);
-    predictor->Finish(convreq, Converter::MakeLearningResults(segments),
-                      segments.revert_id());
-  }
-
-  for (int trial : {10, 20}) {
-    request_.mutable_decoder_experiment_params()
-        ->set_user_history_max_suggestion_trial(trial);
-    for (int i = 29; i >= 0; --i) {
-      Segments segments;
-      const ConversionRequest convreq = SetUpInputForSuggestion(
-          absl::StrFormat("わたしのなまえ%2d", i), &composer_, &segments);
-      const std::vector<Result> results = predictor->Predict(convreq);
-      const int lookup_trial = 29 - i;
-      if (lookup_trial < trial) {
-        EXPECT_FALSE(results.empty());
-      } else {
-        EXPECT_TRUE(results.empty());
-      }
-    }
-  }
-
-  request_.mutable_decoder_experiment_params()
-      ->set_user_history_max_suggestion_trial(0);
-}
-
-TEST_F(UserHistoryPredictorTest, EntriesAreDeletedAtSync) {
-  // mode 0 -> delete by lifetime
-  // mode 1 -> delete by cache size.
-
-  for (const int mode : {0, 1}) {
-    for (const int limit : {10, 20, 30, 40}) {
-      ScopedClockMock clock(absl::FromUnixSeconds(1));
-      UserHistoryPredictor *predictor =
-          GetUserHistoryPredictorWithClearedHistory();
-      UserHistoryPredictorTestPeer predictor_peer(*predictor);
-
-      if (mode == 0) {
-        predictor_peer.SetEntryLifetimeDays(limit);
-        EXPECT_EQ(predictor_peer.entry_lifetime_days_(), limit);
-      } else {
-        predictor_peer.SetCacheStoreSize(limit);
-        EXPECT_EQ(predictor_peer.cache_store_size_(), limit);
-      }
-
-      // Insert one entry per day.
-      for (int i = 0; i < 50; ++i) {
-        Segments segments;
-        const ConversionRequest convreq = SetUpInputForConversion(
-            absl::StrFormat("わたしのなまえ%2d", i), &composer_, &segments);
-        AddCandidate(absl::StrFormat("私の名前%2d", i), &segments);
-        predictor->Finish(convreq, Converter::MakeLearningResults(segments),
-                          segments.revert_id());
-        if (mode == 0) {
-          clock->Advance(absl::Hours(24));  // advance one day.
-        }
-      }
-
-      predictor_peer.Save();
-
-      auto lookup_key = [&](absl::string_view key) -> std::string {
-        Segments segments;
-        const ConversionRequest convreq =
-            SetUpInputForPrediction(key, &composer_, &segments);
-        const std::vector<Result> results = predictor->Predict(convreq);
-        return results.empty() ? "" : results[0].value;
-      };
-
-      const int deleted = 50 - limit;
-      for (int i = 0; i < deleted; ++i) {
-        EXPECT_EQ(lookup_key(absl::StrFormat("わたしのなまえ%2d", i)), "");
-      }
-
-      for (int i = deleted; i < limit; ++i) {
-        EXPECT_EQ(lookup_key(absl::StrFormat("わたしのなまえ%2d", i)),
-                  absl::StrFormat("私の名前%2d", i));
-      }
-
-      predictor_peer.SetEntryLifetimeDays(0);
-      predictor_peer.SetCacheStoreSize(0);
-      EXPECT_EQ(predictor_peer.entry_lifetime_days_(), 62);
-      EXPECT_EQ(predictor_peer.cache_store_size_(), 0);
-    }
-  }
-}
-
 TEST_F(UserHistoryPredictorTest, 62DayOldEntriesAreDeletedAtSync) {
   ScopedClockMock clock(absl::FromUnixSeconds(1));
 
diff --git a/src/protocol/commands.proto b/src/protocol/commands.proto
index 45abe0e..aa9096e 100644
--- a/src/protocol/commands.proto
+++ b/src/protocol/commands.proto
@@ -546,13 +546,15 @@ message Capability {
       [default = NO_TEXT_DELETION_CAPABILITY];
 }
 
-// Next ID: 111
+// Next ID: 108
 // Bundles together some Android experiment flags so that they can be easily
 // retrieved throughout the native code.  These flags are generally specific to
 // the decoder, and are made available when the decoder is initialized.
 message DecoderExperimentParams {
   reserved 1;
 
+  optional int32 mobile_history_prediction_size = 2;
+
   enum VariationCharacterType {
     NO_VARIATION = 0;
     // Standardized variation sequences for Japanese.
@@ -634,25 +636,13 @@ message DecoderExperimentParams {
     // Filter all bigram candidates.
     FILTER_ALL = 2;
   }
+  optional int32 bigram_nwp_filtering_mode = 106 [default = 0];
 
   // Threshold for suffix NWP transition cost.
   // If the transition cost is greater than this value, the candidate will be
   // filtered.
   // The candidate will not be filtered if this value is zero.
   optional int32 suffix_nwp_transition_cost_threshold = 107 [default = 0];
-
-  // How many initial LRU entries to look up.
-  // We use a simple linear-search on LRU.
-  // When zero, default value (3000) is used.
-  optional int32 user_history_max_suggestion_trial = 108 [ default = 0];
-
-  // The maximum lifetime of the entries.
-  // When zero, default value (62) is used.
-  optional int32 user_history_entry_lifetime_days = 109 [ default = 0];
-
-  // The maximum size of entries actually saved to disk.
-  // When zero, store all entries in the on-memory LRU.
-  optional int32 user_history_cache_store_size = 110 [ default = 0];
 }
 
 // Clients' request to the server.
diff --git a/src/request/BUILD.bazel b/src/request/BUILD.bazel
index 3afc139..3d1f29c 100644
--- a/src/request/BUILD.bazel
+++ b/src/request/BUILD.bazel
@@ -81,6 +81,7 @@ mozc_cc_library(
     visibility = [
         "//:__subpackages__",
         "//converter:__pkg__",
+        "//dictionary:__subpackages__",
         "//prediction:__pkg__",
         "//rewriter:__pkg__",
     ],
diff --git a/src/rewriter/date_rewriter.cc b/src/rewriter/date_rewriter.cc
index e85171c..b3bb8bb 100644
--- a/src/rewriter/date_rewriter.cc
+++ b/src/rewriter/date_rewriter.cc
@@ -869,9 +869,9 @@ std::vector<std::string> DateRewriter::ConvertDateWithYear(uint32_t year,
 }
 
 namespace {
-absl::CivilMinute GetCivilMinuteWithDiff(int type, int diff,
-                                         absl::TimeZone tz) {
+absl::CivilMinute GetCivilMinuteWithDiff(int type, int diff) {
   const absl::Time at = Clock::GetAbslTime();
+  const absl::TimeZone &tz = Clock::GetTimeZone();
 
   if (type == DATE) {
     const absl::CivilDay c_day = absl::ToCivilDay(at, tz) + diff;
@@ -898,10 +898,10 @@ absl::CivilMinute GetCivilMinuteWithDiff(int type, int diff,
 std::vector<std::string> GetConversions(const DateRewriter::DateData &data,
                                         const absl::string_view extra_format) {
   std::vector<std::string> results;
-  const absl::TimeZone tz = Clock::GetTimeZone();
-  const absl::CivilMinute cm = GetCivilMinuteWithDiff(data.type, data.diff, tz);
+  const absl::CivilMinute cm = GetCivilMinuteWithDiff(data.type, data.diff);
 
   if (!extra_format.empty()) {
+    const absl::TimeZone &tz = Clock::GetTimeZone();
     const absl::Time at = absl::FromCivil(cm, tz);
     results.push_back(absl::FormatTime(extra_format, at, tz));
   }
diff --git a/src/rewriter/rewriter.gyp b/src/rewriter/rewriter.gyp
index 71c279b..d586955 100644
--- a/src/rewriter/rewriter.gyp
+++ b/src/rewriter/rewriter.gyp
@@ -95,7 +95,7 @@
         '<(mozc_oss_src_dir)/converter/immutable_converter.gyp:immutable_converter',
         '<(mozc_oss_src_dir)/data_manager/data_manager_base.gyp:serialized_dictionary',
         '<(mozc_oss_src_dir)/dictionary/dictionary.gyp:dictionary',
-        '<(mozc_oss_src_dir)/dictionary/pos_matcher.gyp:pos_matcher',
+        '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:pos_matcher',
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:commands_proto',
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:config_proto',
         '<(mozc_oss_src_dir)/request/request.gyp:conversion_request',
diff --git a/src/rewriter/rewriter_base.gyp b/src/rewriter/rewriter_base.gyp
index 443ae5b..ea8d8fe 100644
--- a/src/rewriter/rewriter_base.gyp
+++ b/src/rewriter/rewriter_base.gyp
@@ -40,7 +40,7 @@
       'target_name': 'gen_rewriter_files',
       'type': 'none',
       'dependencies': [
-        '<(mozc_oss_src_dir)/dictionary/pos_matcher.gyp:pos_util',
+        '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:pos_util',
         'gen_usage_rewriter_dictionary_main#host',
       ],
       'toolsets': ['host'],
@@ -130,8 +130,8 @@
         '<(mozc_oss_src_dir)/base/base.gyp:serialized_string_array',
         '<(mozc_oss_src_dir)/data_manager/data_manager_base.gyp:data_manager',
         '<(mozc_oss_src_dir)/data_manager/data_manager_base.gyp:serialized_dictionary',
+        '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:pos_matcher',
         '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:user_pos',
-        '<(mozc_oss_src_dir)/dictionary/pos_matcher.gyp:pos_matcher',
       ],
     },
     {
diff --git a/src/rewriter/rewriter_test.gyp b/src/rewriter/rewriter_test.gyp
index 00c4860..c9aeea9 100644
--- a/src/rewriter/rewriter_test.gyp
+++ b/src/rewriter/rewriter_test.gyp
@@ -124,7 +124,7 @@
         '<(mozc_oss_src_dir)/config/config.gyp:config_handler',
         '<(mozc_oss_src_dir)/converter/converter_base.gyp:segments',
         '<(mozc_oss_src_dir)/data_manager/testing/mock_data_manager.gyp:mock_data_manager',
-        '<(mozc_oss_src_dir)/dictionary/pos_matcher.gyp:pos_matcher',
+        '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:pos_matcher',
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:commands_proto',
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:config_proto',
         '<(mozc_oss_src_dir)/request/request.gyp:conversion_request',
diff --git a/src/rewriter/single_kanji_rewriter.cc b/src/rewriter/single_kanji_rewriter.cc
index 4e34222..567f994 100644
--- a/src/rewriter/single_kanji_rewriter.cc
+++ b/src/rewriter/single_kanji_rewriter.cc
@@ -123,12 +123,7 @@ bool SingleKanjiRewriter::Rewrite(const ConversionRequest &request,
   if (request.request().mixed_conversion() &&
       request.request_type() != ConversionRequest::CONVERSION) {
     MOZC_VLOG(2) << "single kanji prediction is enabled";
-    // Single kanji entries are populated in the predictor when mixed conversion
-    // mode, so we only sets the description of single kanji.
-    for (Segment &segment : segments->conversion_segments()) {
-      AddDescriptionForExistingCandidates(&segment);
-    }
-    return true;
+    return false;
   }
 
   bool modified = false;
diff --git a/src/rewriter/single_kanji_rewriter_test.cc b/src/rewriter/single_kanji_rewriter_test.cc
index ac864c6..6acdf6e 100644
--- a/src/rewriter/single_kanji_rewriter_test.cc
+++ b/src/rewriter/single_kanji_rewriter_test.cc
@@ -224,47 +224,23 @@ TEST_F(SingleKanjiRewriterTest, InsertionPositionTest) {
 
 TEST_F(SingleKanjiRewriterTest, AddDescriptionTest) {
   const SingleKanjiRewriter rewriter(data_manager_);
-
   Segments segments;
+  Segment *segment = segments.add_segment();
 
-  auto init_segment = [&segments]() {
-    segments.Clear();
-    Segment *segment = segments.add_segment();
-
-    segment->set_key("あ");
-    {
-      converter::Candidate *candidate = segment->add_candidate();
-      candidate->key = segment->key();
-      candidate->content_key = segment->key();
-      candidate->value = "亞";  // variant of "亜".
-      candidate->content_value = candidate->value;
-    }
-    return segment;
-  };
-
-  // desktop
+  segment->set_key("あ");
   {
-    Segment *segment = init_segment();
-    EXPECT_EQ(segment->candidates_size(), 1);
-    EXPECT_TRUE(segment->candidate(0).description.empty());
-    EXPECT_TRUE(rewriter.Rewrite(default_request_, &segments));
-    EXPECT_LT(1, segment->candidates_size());  // Some candidates were inserted.
-    EXPECT_EQ(segment->candidate(0).description, "亜の旧字体");
+    converter::Candidate *candidate = segment->add_candidate();
+    candidate->key = segment->key();
+    candidate->content_key = segment->key();
+    candidate->value = "亞";  // variant of "亜".
+    candidate->content_value = candidate->value;
   }
 
-  // Only sets the description in mixed conversion mode.
-  {
-    commands::Request request;
-    request_test_util::FillMobileRequest(&request);
-    Segment *segment = init_segment();
-    const ConversionRequest convreq =
-        ConvReq(request, ConversionRequest::PREDICTION);
-    EXPECT_EQ(segment->candidates_size(), 1);
-    EXPECT_TRUE(segment->candidate(0).description.empty());
-    EXPECT_TRUE(rewriter.Rewrite(convreq, &segments));
-    EXPECT_EQ(1, segment->candidates_size());  // No candidates were inserted.
-    EXPECT_EQ(segment->candidate(0).description, "亜の旧字体");
-  }
+  EXPECT_EQ(segment->candidates_size(), 1);
+  EXPECT_TRUE(segment->candidate(0).description.empty());
+  EXPECT_TRUE(rewriter.Rewrite(default_request_, &segments));
+  EXPECT_LT(1, segment->candidates_size());  // Some candidates were inserted.
+  EXPECT_EQ(segment->candidate(0).description, "亜の旧字体");
 }
 
 TEST_F(SingleKanjiRewriterTest, TriggerConditionForPrediction) {
@@ -279,7 +255,7 @@ TEST_F(SingleKanjiRewriterTest, TriggerConditionForPrediction) {
     const ConversionRequest convreq =
         ConvReq(request, ConversionRequest::PREDICTION);
     ASSERT_TRUE(rewriter.capability(convreq) & RewriterInterface::PREDICTION);
-    EXPECT_TRUE(rewriter.Rewrite(convreq, &segments));
+    EXPECT_FALSE(rewriter.Rewrite(convreq, &segments));
   }
 
   {
diff --git a/src/session/BUILD.bazel b/src/session/BUILD.bazel
index a03b7cb..a86d6b0 100644
--- a/src/session/BUILD.bazel
+++ b/src/session/BUILD.bazel
@@ -48,7 +48,12 @@ mozc_cc_library(
     name = "session",
     srcs = ["session.cc"],
     hdrs = ["session.h"],
-    visibility = ["//evaluation/candidates_diff_checker:__pkg__"],
+    visibility = [
+        "//android/jni:__pkg__",
+        "//evaluation/candidates_diff_checker:__pkg__",
+        "//ios:__pkg__",
+        "//server:__pkg__",
+    ],
     deps = [
         ":ime_context",
         ":key_event_transformer",
@@ -152,6 +157,8 @@ mozc_cc_library(
     visibility = [
         "//android/jni:__pkg__",
         "//ios:__pkg__",
+        "//server:__pkg__",
+        "//unix/fcitx5:__pkg__",
     ],
     deps = [
         ":keymap",
@@ -349,6 +356,7 @@ mozc_cc_library(
     hdrs = ["key_info_util.h"],
     visibility = [
         "//client:__pkg__",
+        "//unix/fcitx5:__pkg__",
         "//win32/base:__pkg__",
     ],
     deps = [
@@ -406,7 +414,10 @@ mozc_cc_library(
         ":session_stress_test_data",
     ],
     hdrs = ["random_keyevents_generator.h"],
-    visibility = ["//client:__pkg__"],
+    visibility = [
+        "//client:__pkg__",
+        "//server:__pkg__",
+    ],
     deps = [
         ":keymap",
         "//base:japanese_util",
diff --git a/src/session/session.gyp b/src/session/session.gyp
index 9b562e9..af7ae97 100644
--- a/src/session/session.gyp
+++ b/src/session/session.gyp
@@ -48,7 +48,7 @@
         '<(mozc_oss_src_dir)/composer/composer.gyp:key_parser',
         '<(mozc_oss_src_dir)/config/config.gyp:config_handler',
         '<(mozc_oss_src_dir)/converter/converter_base.gyp:segments',
-        '<(mozc_oss_src_dir)/dictionary/pos_matcher.gyp:pos_matcher',
+        '<(mozc_oss_src_dir)/dictionary/dictionary_base.gyp:pos_matcher',
         '<(mozc_oss_src_dir)/engine/engine.gyp:engine_converter',
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:commands_proto',
         '<(mozc_oss_src_dir)/protocol/protocol.gyp:config_proto',
diff --git a/src/unix/fcitx/BUILD.bazel b/src/unix/fcitx/BUILD.bazel
new file mode 100644
index 0000000..76beb76
--- /dev/null
+++ b/src/unix/fcitx/BUILD.bazel
@@ -0,0 +1,102 @@
+load(
+    "//:build_defs.bzl",
+    "mozc_cc_binary",
+    "mozc_cc_library",
+)
+
+package(default_visibility = ["//:__subpackages__"])
+
+mozc_cc_library(
+    name = "mozc_connection",
+    srcs = ["mozc_connection.cc"],
+    hdrs = ["mozc_connection.h"],
+    deps = [
+        ":fcitx_key_util",
+        ":surrounding_text_util",
+        "//base:port",
+        "//base:util",
+        "//base:vlog",
+        "//client",
+        "//protocol:commands_cc_proto",
+        "@com_google_absl//absl/log:check",
+        "@fcitx",
+    ],
+)
+
+mozc_cc_library(
+    name = "fcitx_mozc",
+    srcs = [
+        "fcitx_mozc.cc",
+        "mozc_response_parser.cc",
+    ],
+    hdrs = [
+        "fcitx_mozc.h",
+        "mozc_response_parser.h",
+    ],
+    deps = [
+        ":fcitx_key_util",
+        ":mozc_connection",
+        ":surrounding_text_util",
+        "//base:port",
+        "//base:process",
+        "//base:run_level",
+        "//base:util",
+        "//base:vlog",
+        "//client:client_interface",
+        "//protocol:commands_cc_proto",
+        "@com_google_absl//absl/log:check",
+    ],
+)
+
+mozc_cc_library(
+    name = "fcitx_key_util",
+    srcs = [
+        "fcitx_key_event_handler.cc",
+        "fcitx_key_translator.cc",
+    ],
+    hdrs = [
+        "fcitx_key_event_handler.h",
+        "fcitx_key_translator.h",
+    ],
+    deps = [
+        "//base:port",
+        "//base:singleton",
+        "//base:vlog",
+        "//protocol:commands_cc_proto",
+        "//protocol:config_cc_proto",
+        "@com_google_absl//absl/log:check",
+        "@fcitx",
+    ],
+)
+
+mozc_cc_library(
+    name = "surrounding_text_util",
+    srcs = [
+        "surrounding_text_util.cc",
+    ],
+    hdrs = [
+        "surrounding_text_util.h",
+    ],
+    deps = [
+        "//base:port",
+        "//base:util",
+        "//base:vlog",
+        "@com_google_absl//absl/log:check",
+        "@fcitx",
+    ],
+)
+
+mozc_cc_binary(
+    name = "fcitx-mozc.so",
+    srcs = ["eim.cc"],
+    linkshared = 1,
+    linkstatic = 1,
+    local_defines = [
+        'LOCALEDIR=\\"/usr/share/locale\\"',
+    ],
+    deps = [
+        ":fcitx_mozc",
+        "//base:init_mozc",
+        "@fcitx",
+    ],
+)
diff --git a/src/unix/fcitx/eim.cc b/src/unix/fcitx/eim.cc
new file mode 100644
index 0000000..b063c52
--- /dev/null
+++ b/src/unix/fcitx/eim.cc
@@ -0,0 +1,275 @@
+// Copyright 2012~2013, Weng Xuetian <wengxt@gmail.com>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include <fcitx/instance.h>
+#include <fcitx/ime.h>
+#include <fcitx/hook.h>
+#include <fcitx/module.h>
+#include <fcitx/keys.h>
+#include <fcitx-config/xdg.h>
+
+// Resolve macro naming conflict with absl.
+#undef InvokeFunction
+
+#include "fcitx_mozc.h"
+#include "mozc_connection.h"
+#include "mozc_response_parser.h"
+#include "base/init_mozc.h"
+
+typedef struct _FcitxMozcState {
+    mozc::fcitx::FcitxMozc* mozc;
+    int inUsageState;
+} FcitxMozcState;
+
+
+static void* FcitxMozcCreate(FcitxInstance* instance);
+static void FcitxMozcDestroy(void *arg);
+static boolean FcitxMozcInit(void *arg); /**< FcitxMozcInit */
+static void FcitxMozcResetIM(void *arg); /**< FcitxMozcResetIM */
+static void FcitxMozcReset(void *arg); /**< FcitxMozcResetIM */
+static INPUT_RETURN_VALUE FcitxMozcDoInput(void *arg, FcitxKeySym, unsigned int); /**< FcitxMozcDoInput */
+static INPUT_RETURN_VALUE FcitxMozcDoReleaseInput(void *arg, FcitxKeySym, unsigned int); /**< FcitxMozcDoInput */
+static void FcitxMozcSave(void *arg); /**< FcitxMozcSave */
+static void FcitxMozcReloadConfig(void *arg); /**< FcitxMozcReloadConfig */
+
+extern "C" {
+
+FCITX_EXPORT_API
+FcitxIMClass ime = {
+    FcitxMozcCreate,
+    FcitxMozcDestroy
+};
+FCITX_EXPORT_API
+int ABI_VERSION = FCITX_ABI_VERSION;
+
+}
+
+static inline bool CheckLayout(FcitxInstance* instance)
+{
+    char *layout = NULL, *variant = NULL;
+    FcitxModuleFunctionArg args;
+    args.args[0] = &layout;
+    args.args[1] = &variant;
+    bool layout_is_jp = false;
+    FcitxModuleInvokeFunctionByName(instance, "fcitx-xkb", 1, args);
+    if (layout && strcmp(layout, "jp") == 0)
+        layout_is_jp = true;
+
+    fcitx_utils_free(layout);
+    fcitx_utils_free(variant);
+
+
+    return layout_is_jp;
+}
+
+static void* FcitxMozcCreate(FcitxInstance* instance)
+{
+    FcitxMozcState* mozcState = (FcitxMozcState*) fcitx_utils_malloc0(sizeof(FcitxMozcState));
+    bindtextdomain("fcitx-mozc", LOCALEDIR);
+    bind_textdomain_codeset("fcitx-mozc", "UTF-8");
+
+    int argc = 1;
+    char argv0[] = "fcitx_mozc";
+    char *_argv[] = {  argv0 };
+    char **argv = _argv;
+    mozc::InitMozc(argv[0], &argc, &argv);
+    mozcState->mozc = new mozc::fcitx::FcitxMozc(
+        instance,
+        mozc::fcitx::MozcConnection::CreateMozcConnection(),
+        new mozc::fcitx::MozcResponseParser
+    );
+
+    mozcState->mozc->SetCompositionMode(mozc::commands::HIRAGANA);
+
+    FcitxIMEventHook hk;
+    hk.arg = mozcState;
+    hk.func = FcitxMozcReset;
+
+    FcitxInstanceRegisterResetInputHook(instance, hk);
+
+    FcitxIMIFace iface;
+    memset(&iface, 0, sizeof(FcitxIMIFace));
+    iface.Init = FcitxMozcInit;
+    iface.ResetIM = FcitxMozcResetIM;
+    iface.DoInput = FcitxMozcDoInput;
+    iface.DoReleaseInput = FcitxMozcDoReleaseInput;
+    iface.ReloadConfig = FcitxMozcReloadConfig;
+    iface.Save = FcitxMozcSave;
+
+
+    FcitxInstanceRegisterIMv2(
+        instance,
+        mozcState,
+        "mozc",
+        "Mozc",
+        mozcState->mozc->GetIconFile("mozc.png").c_str(),
+        iface,
+        1,
+        "ja"
+    );
+
+    return mozcState;
+}
+
+static void FcitxMozcDestroy(void *arg)
+{
+    FcitxMozcState* mozcState = (FcitxMozcState*) arg;
+    delete mozcState->mozc;
+    free(mozcState);
+}
+
+static const FcitxHotkey MOZC_CTRL_ALT_H[2] = {
+    {NULL, FcitxKey_H, FcitxKeyState_Ctrl_Alt},
+    {NULL, FcitxKey_None, 0}
+};
+
+INPUT_RETURN_VALUE FcitxMozcDoInput(void* arg, FcitxKeySym _sym, unsigned int _state)
+{
+    FcitxMozcState* mozcState = (FcitxMozcState*) arg;
+    FcitxInstance* instance = mozcState->mozc->GetInstance();
+    FcitxInputState* input = FcitxInstanceGetInputState(mozcState->mozc->GetInstance());
+
+    if (mozcState->inUsageState) {
+        if (FcitxHotkeyIsHotKey(_sym, _state, FCITX_ESCAPE)) {
+            mozcState->inUsageState = false;
+            // send a dummy key to let server send us the candidate info back without side effect
+            mozcState->mozc->process_key_event(FcitxKey_VoidSymbol, 0, 0, CheckLayout(instance), false);
+            return IRV_DISPLAY_CANDWORDS;
+        } else {
+            return IRV_DO_NOTHING;
+        }
+    }
+
+    if (FcitxHotkeyIsHotKey(_sym, _state, MOZC_CTRL_ALT_H)) {
+        std::pair< std::string, std::string > usage = mozcState->mozc->GetUsage();
+        if (usage.first.size() != 0 || usage.second.size() != 0) {
+            mozcState->inUsageState = true;
+            FcitxCandidateWordList* candList = FcitxInputStateGetCandidateList(mozcState->mozc->GetInputState());
+
+            // clear preedit, but keep client preedit
+            FcitxMessages* preedit = FcitxInputStateGetPreedit(input);
+            FcitxMessagesSetMessageCount(preedit, 0);
+            FcitxInputStateSetShowCursor(input, false);
+
+            // clear aux
+            FcitxMessages* auxUp = FcitxInputStateGetAuxUp(input);
+            FcitxMessages* auxDown = FcitxInputStateGetAuxDown(input);
+            FcitxMessagesSetMessageCount(auxUp, 0);
+            FcitxMessagesSetMessageCount(auxDown, 0);
+
+            // clear candidate table
+            FcitxCandidateWordReset(candList);
+            FcitxCandidateWordSetPageSize(candList, 9);
+            FcitxCandidateWordSetLayoutHint(candList, CLH_Vertical);
+            FcitxCandidateWordSetChoose(candList, "\0\0\0\0\0\0\0\0\0\0");
+            FcitxMessagesAddMessageAtLast(preedit, MSG_TIPS, "%s [%s]", usage.first.c_str(), _("Press Escape to go back"));
+
+            UT_array* lines = fcitx_utils_split_string(usage.second.c_str(), '\n');
+            utarray_foreach(line, lines, char*) {
+                FcitxCandidateWord candWord;
+                candWord.callback = NULL;
+                candWord.extraType = MSG_OTHER;
+                candWord.strExtra = NULL;
+                candWord.priv = NULL;
+                candWord.strWord = strdup(*line);
+                candWord.wordType = MSG_OTHER;
+                candWord.owner = NULL;
+                FcitxCandidateWordAppend(candList, &candWord);
+            }
+            utarray_free(lines);
+            return IRV_DISPLAY_MESSAGE;
+        }
+    }
+
+    FCITX_UNUSED(_sym);
+    FCITX_UNUSED(_state);
+    FcitxKeySym sym = (FcitxKeySym) FcitxInputStateGetKeySym(input);
+    uint32_t keycode = FcitxInputStateGetKeyCode(input);
+    uint32_t state = FcitxInputStateGetKeyState(input);
+    bool result = mozcState->mozc->process_key_event(sym, keycode, state, CheckLayout(instance), false);
+    if (!result)
+        return IRV_TO_PROCESS;
+    else
+        return IRV_DISPLAY_CANDWORDS;
+}
+
+INPUT_RETURN_VALUE FcitxMozcDoReleaseInput(void* arg, FcitxKeySym _sym, unsigned int _state)
+{
+    FcitxMozcState* mozcState = (FcitxMozcState*) arg;
+    FcitxInstance* instance = mozcState->mozc->GetInstance();
+    FcitxInputState* input = FcitxInstanceGetInputState(mozcState->mozc->GetInstance());
+    FCITX_UNUSED(_sym);
+    FCITX_UNUSED(_state);
+
+    if (mozcState->inUsageState) {
+        return IRV_DONOT_PROCESS;
+    }
+
+    FcitxKeySym sym = (FcitxKeySym) FcitxInputStateGetKeySym(input);
+    uint32_t keycode = FcitxInputStateGetKeyCode(input);
+    uint32_t state = FcitxInputStateGetKeyState(input);
+    bool result = mozcState->mozc->process_key_event(sym, keycode, state, CheckLayout(instance), true);
+    if (!result)
+        return IRV_TO_PROCESS;
+    else
+        return IRV_DISPLAY_CANDWORDS;
+}
+
+
+
+boolean FcitxMozcInit(void* arg)
+{
+    FcitxMozcState* mozcState = (FcitxMozcState*) arg;
+    mozcState->mozc->init();
+    return true;
+}
+
+void FcitxMozcReloadConfig(void* arg)
+{
+
+}
+
+void FcitxMozcSave(void* arg)
+{
+    FCITX_UNUSED(arg);
+}
+
+void FcitxMozcResetIM(void* arg)
+{
+    FcitxMozcState* mozcState = (FcitxMozcState*) arg;
+    mozcState->inUsageState = false;
+    mozcState->mozc->resetim();
+}
+
+void FcitxMozcReset(void* arg)
+{
+    FcitxMozcState* mozcState = (FcitxMozcState*) arg;
+    mozcState->mozc->reset();
+
+}
diff --git a/src/unix/fcitx/fcitx-mozc.conf b/src/unix/fcitx/fcitx-mozc.conf
new file mode 100644
index 0000000..65d0e11
--- /dev/null
+++ b/src/unix/fcitx/fcitx-mozc.conf
@@ -0,0 +1,11 @@
+[Addon]
+Name=fcitx-mozc
+GeneralName=Mozc
+Comment=Mozc support for Fcitx
+Category=InputMethod
+Enabled=True
+Library=fcitx-mozc.so
+Type=SharedLibrary
+SubConfig=
+IMRegisterMethod=ConfigFile
+LoadLocal=True
diff --git a/src/unix/fcitx/fcitx.gyp b/src/unix/fcitx/fcitx.gyp
new file mode 100644
index 0000000..7fedaa0
--- /dev/null
+++ b/src/unix/fcitx/fcitx.gyp
@@ -0,0 +1,110 @@
+#
+# Copyright (c) 2010-2012 fcitx Project http://code.google.com/p/fcitx/
+#
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+# 3. Neither the name of authors nor the names of its contributors
+#    may be used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+# SUCH DAMAGE.
+#
+
+{
+  'variables': {
+    'use_fcitx%': 'YES',
+    'relative_dir': 'unix/fcitx',
+    'gen_out_dir': '<(SHARED_INTERMEDIATE_DIR)/<(relative_dir)',
+    'pkg_config_libs': [
+      'fcitx',
+      'fcitx-config',
+      'fcitx-utils',
+    ],
+    'fcitx_dep_include_dirs': [
+    ],
+    'fcitx_dependencies': [
+        '../../base/base.gyp:base',
+        '../../client/client.gyp:client',
+        '../../ipc/ipc.gyp:ipc',
+        '../../protocol/protocol.gyp:commands_proto',
+    ],
+  },
+  'conditions': [['use_fcitx=="YES"', {
+  'targets': [
+    {
+      'target_name': 'gen_fcitx_mozc_i18n',
+      'type': 'none',
+      'actions': [
+        {
+          'action_name': 'gen_fcitx_mozc_i18n',
+          'inputs': [
+            './gen_fcitx_mozc_i18n.sh'
+          ],
+          'outputs': [
+            '<(gen_out_dir)/po/zh_CN.mo',
+            '<(gen_out_dir)/po/zh_TW.mo',
+            '<(gen_out_dir)/po/ja.mo',
+            '<(gen_out_dir)/po/de.mo',
+          ],
+          'action': [
+            'sh',
+            './gen_fcitx_mozc_i18n.sh',
+            '<(gen_out_dir)/po',
+          ],
+        }],
+    },
+    {
+      'target_name': 'fcitx-mozc',
+      'product_prefix': '',
+      'type': 'loadable_module',
+      'sources': [
+        'fcitx_mozc.cc',
+        'fcitx_key_translator.cc',
+        'fcitx_key_event_handler.cc',
+        'mozc_connection.cc',
+        'mozc_response_parser.cc',
+        'surrounding_text_util.cc',
+        'eim.cc',
+      ],
+      'dependencies': [
+        '<@(fcitx_dependencies)',
+        'gen_fcitx_mozc_i18n',
+      ],
+      'cflags': [
+        '<!@(pkg-config --cflags <@(pkg_config_libs))',
+      ],
+      'include_dirs': [
+        '<@(fcitx_dep_include_dirs)',
+      ],
+      'defines': [
+        'LOCALEDIR="<!@(fcitx4-config --prefix)/share/locale/"',
+      ],
+    },
+  ],
+  }, {
+  'targets': [
+    {
+      'target_name': 'no_fcitx_dummy',
+      'type': 'none',
+    }
+  ]}
+  ]],
+}
diff --git a/src/unix/fcitx/fcitx_key_event_handler.cc b/src/unix/fcitx/fcitx_key_event_handler.cc
new file mode 100644
index 0000000..2b07f5c
--- /dev/null
+++ b/src/unix/fcitx/fcitx_key_event_handler.cc
@@ -0,0 +1,244 @@
+// Copyright 2010-2012, Google Inc.
+// Copyright 2012~2013, Weng Xuetian <wengxt@gmail.com>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "unix/fcitx/fcitx_key_event_handler.h"
+
+#include <map>
+
+#include "absl/log/check.h"
+#include "base/vlog.h"
+#include "base/singleton.h"
+
+namespace mozc {
+namespace fcitx {
+
+namespace {
+// TODO(hsumita): Removes this class, and moves |data_| into member
+// variables of KeyEventhandler.
+class AdditionalModifiersData {
+ public:
+  AdditionalModifiersData() {
+    data_[commands::KeyEvent::LEFT_ALT] = commands::KeyEvent::ALT;
+    data_[commands::KeyEvent::RIGHT_ALT] = commands::KeyEvent::ALT;
+    data_[commands::KeyEvent::LEFT_CTRL] = commands::KeyEvent::CTRL;
+    data_[commands::KeyEvent::RIGHT_CTRL] = commands::KeyEvent::CTRL;
+    data_[commands::KeyEvent::LEFT_SHIFT] = commands::KeyEvent::SHIFT;
+    data_[commands::KeyEvent::RIGHT_SHIFT] = commands::KeyEvent::SHIFT;
+  }
+  const std::map<uint32_t, commands::KeyEvent::ModifierKey> &data() {
+    return data_;
+  }
+
+ private:
+  std::map<uint32_t, commands::KeyEvent::ModifierKey> data_;
+};
+
+// TODO(hsumita): Moves this function into member functions of
+// KeyEventHandler.
+void AddAdditionalModifiers(
+    std::set<commands::KeyEvent::ModifierKey> *modifier_keys_set) {
+  DCHECK(modifier_keys_set);
+
+  const std::map<uint32_t, commands::KeyEvent::ModifierKey> &data =
+      Singleton<AdditionalModifiersData>::get()->data();
+
+  // Adds MODIFIER if there are (LEFT|RIGHT)_MODIFIER like LEFT_SHIFT.
+  for (std::set<commands::KeyEvent::ModifierKey>::const_iterator it =
+           modifier_keys_set->begin(); it != modifier_keys_set->end(); ++it) {
+    std::map<uint32_t, commands::KeyEvent::ModifierKey>::const_iterator item =
+        data.find(*it);
+    if (item != data.end()) {
+      modifier_keys_set->insert(item->second);
+    }
+  }
+}
+
+bool IsModifierToBeSentOnKeyUp(const commands::KeyEvent &key_event) {
+  if (key_event.modifier_keys_size() == 0) {
+    return false;
+  }
+
+  if (key_event.modifier_keys_size() == 1 &&
+      key_event.modifier_keys(0) == commands::KeyEvent::CAPS) {
+    return false;
+  }
+
+  return true;
+}
+}  // namespace
+
+KeyEventHandler::KeyEventHandler() : key_translator_(new KeyTranslator) {
+  Clear();
+}
+
+bool KeyEventHandler::GetKeyEvent(
+    FcitxKeySym keyval, uint32_t keycode, uint32_t modifiers,
+    config::Config::PreeditMethod preedit_method,
+    bool layout_is_jp, bool is_key_up, commands::KeyEvent *key) {
+  DCHECK(key);
+  key->Clear();
+
+  if (!key_translator_->Translate(
+          keyval, keycode, modifiers, preedit_method, layout_is_jp, key)) {
+    LOG(ERROR) << "Translate failed";
+    return false;
+  }
+
+  return ProcessModifiers(is_key_up, keyval, key);
+}
+
+void KeyEventHandler::Clear() {
+  is_non_modifier_key_pressed_ = false;
+  currently_pressed_modifiers_.clear();
+  modifiers_to_be_sent_.clear();
+}
+
+bool KeyEventHandler::ProcessModifiers(bool is_key_up, uint32_t keyval,
+                                       commands::KeyEvent *key_event) {
+  // Manage modifier key event.
+  // Modifier key event is sent on key up if non-modifier key has not been
+  // pressed since key down of modifier keys and no modifier keys are pressed
+  // anymore.
+  // Following examples are expected behaviors.
+  //
+  // E.g.) Shift key is special. If Shift + printable key is pressed, key event
+  //       does NOT have shift modifiers. It is handled by KeyTranslator class.
+  //    <Event from ibus> <Event to server>
+  //     Shift down      | None
+  //     "a" down        | A
+  //     "a" up          | None
+  //     Shift up        | None
+  //
+  // E.g.) Usual key is sent on key down.  Modifier keys are not sent if usual
+  //       key is sent.
+  //    <Event from ibus> <Event to server>
+  //     Ctrl down       | None
+  //     "a" down        | Ctrl+a
+  //     "a" up          | None
+  //     Ctrl up         | None
+  //
+  // E.g.) Modifier key is sent on key up.
+  //    <Event from ibus> <Event to server>
+  //     Shift down      | None
+  //     Shift up        | Shift
+  //
+  // E.g.) Multiple modifier keys are sent on the last key up.
+  //    <Event from ibus> <Event to server>
+  //     Shift down      | None
+  //     Control down    | None
+  //     Shift up        | None
+  //     Control up      | Control+Shift
+  //
+  // Essentialy we cannot handle modifier key evnet perfectly because
+  // - We cannot get current keyboard status with ibus. If some modifiers
+  //   are pressed or released without focusing the target window, we
+  //   cannot handle it.
+  // E.g.)
+  //    <Event from ibus> <Event to server>
+  //     Ctrl down       | None
+  //     (focuses out, Ctrl up, focuses in)
+  //     Shift down      | None
+  //     Shift up        | None (But we should send Shift key)
+  // To avoid a inconsistent state as much as possible, we clear states
+  // when key event without modifier keys is sent.
+
+  const bool is_modifier_only =
+      !(key_event->has_key_code() || key_event->has_special_key());
+
+  // We may get only up/down key event when a user moves a focus.
+  // This code handles such situation as much as possible.
+  // This code has a bug. If we send Shift + 'a', KeyTranslator removes a shift
+  // modifier and converts 'a' to 'A'. This codes does NOT consider these
+  // situation since we don't have enough data to handle it.
+  // TODO(hsumita): Moves the logic about a handling of Shift or Caps keys from
+  // KeyTranslator to MozcEngine.
+  if (key_event->modifier_keys_size() == 0) {
+    Clear();
+  }
+
+  if (!currently_pressed_modifiers_.empty() && !is_modifier_only) {
+    is_non_modifier_key_pressed_ = true;
+  }
+  if (is_non_modifier_key_pressed_) {
+    modifiers_to_be_sent_.clear();
+  }
+
+  if (is_key_up) {
+    currently_pressed_modifiers_.erase(keyval);
+    if (!is_modifier_only) {
+      return false;
+    }
+    if (!currently_pressed_modifiers_.empty() ||
+        modifiers_to_be_sent_.empty()) {
+      is_non_modifier_key_pressed_ = false;
+      return false;
+    }
+    if (is_non_modifier_key_pressed_) {
+      return false;
+    }
+    DCHECK(!is_non_modifier_key_pressed_);
+
+    // Modifier key event fires
+    key_event->mutable_modifier_keys()->Clear();
+    for (std::set<commands::KeyEvent::ModifierKey>::const_iterator it =
+             modifiers_to_be_sent_.begin();
+         it != modifiers_to_be_sent_.end();
+         ++it) {
+      key_event->add_modifier_keys(*it);
+    }
+    modifiers_to_be_sent_.clear();
+  } else if (is_modifier_only) {
+    // TODO(hsumita): Supports a key sequence below.
+    // - Ctrl down
+    // - a down
+    // - Alt down
+    // We should add Alt key to |currently_pressed_modifiers|, but current
+    // implementation does NOT do it.
+    if (currently_pressed_modifiers_.empty() ||
+        !modifiers_to_be_sent_.empty()) {
+      for (size_t i = 0; i < key_event->modifier_keys_size(); ++i) {
+        modifiers_to_be_sent_.insert(key_event->modifier_keys(i));
+      }
+      AddAdditionalModifiers(&modifiers_to_be_sent_);
+    }
+    currently_pressed_modifiers_.insert(keyval);
+    return false;
+  }
+
+  // Clear modifier data just in case if |key| has no modifier keys.
+  if (!IsModifierToBeSentOnKeyUp(*key_event)) {
+    Clear();
+  }
+
+  return true;
+}
+
+}  // namespace ibus
+}  // namespace mozc
diff --git a/src/unix/fcitx/fcitx_key_event_handler.h b/src/unix/fcitx/fcitx_key_event_handler.h
new file mode 100644
index 0000000..d11a440
--- /dev/null
+++ b/src/unix/fcitx/fcitx_key_event_handler.h
@@ -0,0 +1,79 @@
+// Copyright 2010-2012, Google Inc.
+// Copyright 2012~2013, Weng Xuetian <wengxt@gmail.com>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MOZC_UNIX_FCITX_KEY_EVENT_HANDLER_H_
+#define MOZC_UNIX_FCITX_KEY_EVENT_HANDLER_H_
+
+#include <set>
+#include <memory>
+#include <cstdint>
+
+#include "base/port.h"
+#include "protocol/config.pb.h"
+#include "protocol/commands.pb.h"
+#include "unix/fcitx/fcitx_key_translator.h"
+
+namespace mozc {
+namespace fcitx {
+
+class KeyEventHandler {
+ public:
+  KeyEventHandler();
+  KeyEventHandler(const KeyEventHandler &) = delete;
+
+  // Converts a key event came from fcitx to commands::KeyEvent. This is a
+  // stateful method. It stores modifier keys states since ibus doesn't send
+  // an enough information about the modifier keys.
+  bool GetKeyEvent(FcitxKeySym keyval, uint32_t keycode, uint32_t modifiers,
+                   config::Config::PreeditMethod preedit_method,
+                   bool layout_is_jp, bool is_key_up, commands::KeyEvent *key);
+
+  // Clears states.
+  void Clear();
+
+ private:
+
+  // Manages modifier keys. Returns false if it should not be sent to server.
+  bool ProcessModifiers(bool is_key_up, uint32_t keyval,
+                        commands::KeyEvent *key_event);
+
+  std::unique_ptr<KeyTranslator> key_translator_;
+  // Non modifier key is pressed or not after all keys are released.
+  bool is_non_modifier_key_pressed_;
+  // Currently pressed modifier keys.  It is set of keyval.
+  std::set<uint32_t> currently_pressed_modifiers_;
+  // Pending modifier keys.
+  std::set<commands::KeyEvent::ModifierKey> modifiers_to_be_sent_;
+};
+
+}  // namespace fcitx
+}  // namespace mozc
+
+#endif  // MOZC_UNIX_FCITX_KEY_EVENT_HANDLER_H_
diff --git a/src/unix/fcitx/fcitx_key_translator.cc b/src/unix/fcitx/fcitx_key_translator.cc
new file mode 100644
index 0000000..c8fdfeb
--- /dev/null
+++ b/src/unix/fcitx/fcitx_key_translator.cc
@@ -0,0 +1,421 @@
+// Copyright 2010-2012, Google Inc.
+// Copyright 2012~2013, Weng Xuetian <wengxt@gmail.com>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "unix/fcitx/fcitx_key_translator.h"
+
+#include <map>
+#include <set>
+#include <string>
+
+#include "absl/log/check.h"
+#include "base/vlog.h"
+
+namespace mozc {
+namespace {
+static const auto kSpecialKeyMap =
+    new std::map<uint32_t, commands::KeyEvent::SpecialKey>({
+        {FcitxKey_space, commands::KeyEvent::SPACE},
+        {FcitxKey_Return, commands::KeyEvent::ENTER},
+        {FcitxKey_Left, commands::KeyEvent::LEFT},
+        {FcitxKey_Right, commands::KeyEvent::RIGHT},
+        {FcitxKey_Up, commands::KeyEvent::UP},
+        {FcitxKey_Down, commands::KeyEvent::DOWN},
+        {FcitxKey_Escape, commands::KeyEvent::ESCAPE},
+        {FcitxKey_Delete, commands::KeyEvent::DEL},
+        {FcitxKey_BackSpace, commands::KeyEvent::BACKSPACE},
+        {FcitxKey_Insert, commands::KeyEvent::INSERT},
+        {FcitxKey_Henkan, commands::KeyEvent::HENKAN},
+        {FcitxKey_Muhenkan, commands::KeyEvent::MUHENKAN},
+        {FcitxKey_Hiragana, commands::KeyEvent::KANA},
+        {FcitxKey_Hiragana_Katakana, commands::KeyEvent::KANA},
+        {FcitxKey_Katakana, commands::KeyEvent::KATAKANA},
+        {FcitxKey_Zenkaku, commands::KeyEvent::HANKAKU},
+        {FcitxKey_Hankaku, commands::KeyEvent::HANKAKU},
+        {FcitxKey_Zenkaku_Hankaku, commands::KeyEvent::HANKAKU},
+        {FcitxKey_Eisu_toggle, commands::KeyEvent::EISU},
+        {FcitxKey_Home, commands::KeyEvent::HOME},
+        {FcitxKey_End, commands::KeyEvent::END},
+        {FcitxKey_Tab, commands::KeyEvent::TAB},
+        {FcitxKey_F1, commands::KeyEvent::F1},
+        {FcitxKey_F2, commands::KeyEvent::F2},
+        {FcitxKey_F3, commands::KeyEvent::F3},
+        {FcitxKey_F4, commands::KeyEvent::F4},
+        {FcitxKey_F5, commands::KeyEvent::F5},
+        {FcitxKey_F6, commands::KeyEvent::F6},
+        {FcitxKey_F7, commands::KeyEvent::F7},
+        {FcitxKey_F8, commands::KeyEvent::F8},
+        {FcitxKey_F9, commands::KeyEvent::F9},
+        {FcitxKey_F10, commands::KeyEvent::F10},
+        {FcitxKey_F11, commands::KeyEvent::F11},
+        {FcitxKey_F12, commands::KeyEvent::F12},
+        {FcitxKey_F13, commands::KeyEvent::F13},
+        {FcitxKey_F14, commands::KeyEvent::F14},
+        {FcitxKey_F15, commands::KeyEvent::F15},
+        {FcitxKey_F16, commands::KeyEvent::F16},
+        {FcitxKey_F17, commands::KeyEvent::F17},
+        {FcitxKey_F18, commands::KeyEvent::F18},
+        {FcitxKey_F19, commands::KeyEvent::F19},
+        {FcitxKey_F20, commands::KeyEvent::F20},
+        {FcitxKey_F21, commands::KeyEvent::F21},
+        {FcitxKey_F22, commands::KeyEvent::F22},
+        {FcitxKey_F23, commands::KeyEvent::F23},
+        {FcitxKey_F24, commands::KeyEvent::F24},
+        {FcitxKey_Page_Up, commands::KeyEvent::PAGE_UP},
+        {FcitxKey_Page_Down, commands::KeyEvent::PAGE_DOWN},
+
+        // Keypad (10-key).
+        {FcitxKey_KP_0, commands::KeyEvent::NUMPAD0},
+        {FcitxKey_KP_1, commands::KeyEvent::NUMPAD1},
+        {FcitxKey_KP_2, commands::KeyEvent::NUMPAD2},
+        {FcitxKey_KP_3, commands::KeyEvent::NUMPAD3},
+        {FcitxKey_KP_4, commands::KeyEvent::NUMPAD4},
+        {FcitxKey_KP_5, commands::KeyEvent::NUMPAD5},
+        {FcitxKey_KP_6, commands::KeyEvent::NUMPAD6},
+        {FcitxKey_KP_7, commands::KeyEvent::NUMPAD7},
+        {FcitxKey_KP_8, commands::KeyEvent::NUMPAD8},
+        {FcitxKey_KP_9, commands::KeyEvent::NUMPAD9},
+        {FcitxKey_KP_Equal, commands::KeyEvent::EQUALS},         // [=]
+        {FcitxKey_KP_Multiply, commands::KeyEvent::MULTIPLY},    // [*]
+        {FcitxKey_KP_Add, commands::KeyEvent::ADD},              // [+]
+        {FcitxKey_KP_Separator, commands::KeyEvent::SEPARATOR},  // enter
+        {FcitxKey_KP_Subtract, commands::KeyEvent::SUBTRACT},    // [-]
+        {FcitxKey_KP_Decimal, commands::KeyEvent::DECIMAL},      // [.]
+        {FcitxKey_KP_Divide, commands::KeyEvent::DIVIDE},        // [/]
+        {FcitxKey_KP_Space, commands::KeyEvent::SPACE},
+        {FcitxKey_KP_Tab, commands::KeyEvent::TAB},
+        {FcitxKey_KP_Enter, commands::KeyEvent::ENTER},
+        {FcitxKey_KP_Home, commands::KeyEvent::HOME},
+        {FcitxKey_KP_Left, commands::KeyEvent::LEFT},
+        {FcitxKey_KP_Up, commands::KeyEvent::UP},
+        {FcitxKey_KP_Right, commands::KeyEvent::RIGHT},
+        {FcitxKey_KP_Down, commands::KeyEvent::DOWN},
+        {FcitxKey_KP_Page_Up, commands::KeyEvent::PAGE_UP},
+        {FcitxKey_KP_Page_Down, commands::KeyEvent::PAGE_DOWN},
+        {FcitxKey_KP_End, commands::KeyEvent::END},
+        {FcitxKey_KP_Delete, commands::KeyEvent::DEL},
+        {FcitxKey_KP_Insert, commands::KeyEvent::INSERT},
+        {FcitxKey_Caps_Lock, commands::KeyEvent::CAPS_LOCK},
+
+        // Shift+TAB.
+        {FcitxKey_ISO_Left_Tab, commands::KeyEvent::TAB},
+
+        // On Linux (X / Wayland), Hangul and Hanja are identical with
+        // ImeOn and ImeOff.
+        // https://github.com/google/mozc/issues/552
+        //
+        // Hangul == Lang1 (USB HID) / ImeOn (Windows) / Kana (macOS)
+        {FcitxKey_Hangul, commands::KeyEvent::ON},
+        // Hanja == Lang2 (USB HID) / ImeOff (Windows) / Eisu (macOS)
+        {FcitxKey_Hangul_Hanja, commands::KeyEvent::OFF},
+
+        // TODO(mazda): Handle following keys?
+        //   - FcitxKey_Kana_Lock? FcitxKey_KEY_Kana_Shift?
+    });
+
+static const auto kIbusModifierMaskMap = new std::map<uint32_t, uint32_t>({
+    {FcitxKey_Shift_L, FcitxKeyState_Shift},
+    {FcitxKey_Shift_R, FcitxKeyState_Shift},
+    {FcitxKey_Control_L, FcitxKeyState_Ctrl},
+    {FcitxKey_Control_R, FcitxKeyState_Ctrl},
+    {FcitxKey_Alt_L, FcitxKeyState_Alt},
+    {FcitxKey_Alt_R, FcitxKeyState_Alt},
+});
+
+// Stores a mapping from ASCII to Kana character. For example, ASCII character
+// '4' is mapped to Japanese 'Hiragana Letter U' (without Shift modifier) and
+// 'Hiragana Letter Small U' (with Shift modifier).
+// TODO(team): Add kana_map_dv to support Dvoraklayout.
+typedef std::map<uint32_t, std::pair<const char*, const char*>> KanaMap;
+static const KanaMap *kKanaJpMap = new KanaMap({
+    {'1', {"ぬ", "ぬ"}},
+    {'!', {"ぬ", "ぬ"}},
+    {'2', {"ふ", "ふ"}},
+    {'\"', {"ふ", "ふ"}},
+    {'3', {"あ", "ぁ"}},
+    {'#', {"あ", "ぁ"}},
+    {'4', {"う", "ぅ"}},
+    {'$', {"う", "ぅ"}},
+    {'5', {"え", "ぇ"}},
+    {'%', {"え", "ぇ"}},
+    {'6', {"お", "ぉ"}},
+    {'&', {"お", "ぉ"}},
+    {'7', {"や", "ゃ"}},
+    {'\'', {"や", "ゃ"}},
+    {'8', {"ゆ", "ゅ"}},
+    {'(', {"ゆ", "ゅ"}},
+    {'9', {"よ", "ょ"}},
+    {')', {"よ", "ょ"}},
+    {'0', {"わ", "を"}},
+    {'-', {"ほ", "ほ"}},
+    {'=', {"ほ", "ほ"}},
+    {'^', {"へ", "を"}},
+    {'~', {"へ", "を"}},
+    {'|', {"ー", "ー"}},
+    {'q', {"た", "た"}},
+    {'Q', {"た", "た"}},
+    {'w', {"て", "て"}},
+    {'W', {"て", "て"}},
+    {'e', {"い", "ぃ"}},
+    {'E', {"い", "ぃ"}},
+    {'r', {"す", "す"}},
+    {'R', {"す", "す"}},
+    {'t', {"か", "か"}},
+    {'T', {"か", "か"}},
+    {'y', {"ん", "ん"}},
+    {'Y', {"ん", "ん"}},
+    {'u', {"な", "な"}},
+    {'U', {"な", "な"}},
+    {'i', {"に", "に"}},
+    {'I', {"に", "に"}},
+    {'o', {"ら", "ら"}},
+    {'O', {"ら", "ら"}},
+    {'p', {"せ", "せ"}},
+    {'P', {"せ", "せ"}},
+    {'@', {"゛", "゛"}},
+    {'`', {"゛", "゛"}},
+    {'[', {"゜", "「"}},
+    {'{', {"゜", "「"}},
+    {'a', {"ち", "ち"}},
+    {'A', {"ち", "ち"}},
+    {'s', {"と", "と"}},
+    {'S', {"と", "と"}},
+    {'d', {"し", "し"}},
+    {'D', {"し", "し"}},
+    {'f', {"は", "は"}},
+    {'F', {"は", "は"}},
+    {'g', {"き", "き"}},
+    {'G', {"き", "き"}},
+    {'h', {"く", "く"}},
+    {'H', {"く", "く"}},
+    {'j', {"ま", "ま"}},
+    {'J', {"ま", "ま"}},
+    {'k', {"の", "の"}},
+    {'K', {"の", "の"}},
+    {'l', {"り", "り"}},
+    {'L', {"り", "り"}},
+    {';', {"れ", "れ"}},
+    {'+', {"れ", "れ"}},
+    {':', {"け", "け"}},
+    {'*', {"け", "け"}},
+    {']', {"む", "」"}},
+    {'}', {"む", "」"}},
+    {'z', {"つ", "っ"}},
+    {'Z', {"つ", "っ"}},
+    {'x', {"さ", "さ"}},
+    {'X', {"さ", "さ"}},
+    {'c', {"そ", "そ"}},
+    {'C', {"そ", "そ"}},
+    {'v', {"ひ", "ひ"}},
+    {'V', {"ひ", "ひ"}},
+    {'b', {"こ", "こ"}},
+    {'B', {"こ", "こ"}},
+    {'n', {"み", "み"}},
+    {'N', {"み", "み"}},
+    {'m', {"も", "も"}},
+    {'M', {"も", "も"}},
+    {',', {"ね", "、"}},
+    {'<', {"ね", "、"}},
+    {'.', {"る", "。"}},
+    {'>', {"る", "。"}},
+    {'/', {"め", "・"}},
+    {'?', {"め", "・"}},
+    {'_', {"ろ", "ろ"}},
+    // A backslash is handled in a special way because it is input by
+    // two different keys (the one next to Backslash and the one next
+    // to Right Shift).
+    {'\\', {"ろ", "ろ"}},
+    {U'¥', {"ー", "ー"}},  // U+00A5
+});
+
+static const KanaMap *kKanaUsMap = new KanaMap({
+    {'`', {"ろ", "ろ"}},  {'~', {"ろ", "ろ"}},  {'1', {"ぬ", "ぬ"}},
+    {'!', {"ぬ", "ぬ"}},  {'2', {"ふ", "ふ"}},  {'@', {"ふ", "ふ"}},
+    {'3', {"あ", "ぁ"}},  {'#', {"あ", "ぁ"}},  {'4', {"う", "ぅ"}},
+    {'$', {"う", "ぅ"}},  {'5', {"え", "ぇ"}},  {'%', {"え", "ぇ"}},
+    {'6', {"お", "ぉ"}},  {'^', {"お", "ぉ"}},  {'7', {"や", "ゃ"}},
+    {'&', {"や", "ゃ"}},  {'8', {"ゆ", "ゅ"}},  {'*', {"ゆ", "ゅ"}},
+    {'9', {"よ", "ょ"}},  {'(', {"よ", "ょ"}},  {'0', {"わ", "を"}},
+    {')', {"わ", "を"}},  {'-', {"ほ", "ー"}},  {'_', {"ほ", "ー"}},
+    {'=', {"へ", "へ"}},  {'+', {"へ", "へ"}},  {'q', {"た", "た"}},
+    {'Q', {"た", "た"}},  {'w', {"て", "て"}},  {'W', {"て", "て"}},
+    {'e', {"い", "ぃ"}},  {'E', {"い", "ぃ"}},  {'r', {"す", "す"}},
+    {'R', {"す", "す"}},  {'t', {"か", "か"}},  {'T', {"か", "か"}},
+    {'y', {"ん", "ん"}},  {'Y', {"ん", "ん"}},  {'u', {"な", "な"}},
+    {'U', {"な", "な"}},  {'i', {"に", "に"}},  {'I', {"に", "に"}},
+    {'o', {"ら", "ら"}},  {'O', {"ら", "ら"}},  {'p', {"せ", "せ"}},
+    {'P', {"せ", "せ"}},  {'[', {"゛", "゛"}},  {'{', {"゛", "゛"}},
+    {']', {"゜", "「"}},  {'}', {"゜", "「"}},  {'\\', {"む", "」"}},
+    {'|', {"む", "」"}},  {'a', {"ち", "ち"}},  {'A', {"ち", "ち"}},
+    {'s', {"と", "と"}},  {'S', {"と", "と"}},  {'d', {"し", "し"}},
+    {'D', {"し", "し"}},  {'f', {"は", "は"}},  {'F', {"は", "は"}},
+    {'g', {"き", "き"}},  {'G', {"き", "き"}},  {'h', {"く", "く"}},
+    {'H', {"く", "く"}},  {'j', {"ま", "ま"}},  {'J', {"ま", "ま"}},
+    {'k', {"の", "の"}},  {'K', {"の", "の"}},  {'l', {"り", "り"}},
+    {'L', {"り", "り"}},  {';', {"れ", "れ"}},  {':', {"れ", "れ"}},
+    {'\'', {"け", "け"}}, {'\"', {"け", "け"}}, {'z', {"つ", "っ"}},
+    {'Z', {"つ", "っ"}},  {'x', {"さ", "さ"}},  {'X', {"さ", "さ"}},
+    {'c', {"そ", "そ"}},  {'C', {"そ", "そ"}},  {'v', {"ひ", "ひ"}},
+    {'V', {"ひ", "ひ"}},  {'b', {"こ", "こ"}},  {'B', {"こ", "こ"}},
+    {'n', {"み", "み"}},  {'N', {"み", "み"}},  {'m', {"も", "も"}},
+    {'M', {"も", "も"}},  {',', {"ね", "、"}},  {'<', {"ね", "、"}},
+    {'.', {"る", "。"}},  {'>', {"る", "。"}},  {'/', {"め", "・"}},
+    {'?', {"め", "・"}},
+});
+
+const char *GetKanaValue(const KanaMap &kana_map, uint32_t keyval, bool is_shift) {
+  KanaMap::const_iterator iter = kana_map.find(keyval);
+  if (iter == kana_map.end()) {
+    return nullptr;
+  }
+  return (is_shift) ? iter->second.second : iter->second.first;
+}
+
+}  // namespace
+
+namespace fcitx {
+
+// TODO(nona): Fix 'Shift-0' behavior b/4338394
+bool KeyTranslator::Translate(FcitxKeySym keyval,
+                              uint32_t keycode,
+                              uint32_t modifiers,
+                              config::Config::PreeditMethod method,
+                              bool layout_is_jp,
+                              commands::KeyEvent *out_event) const {
+  DCHECK(out_event) << "out_event is NULL";
+  out_event->Clear();
+
+  /* this is key we cannot handle, don't process it */
+  if (modifiers & FcitxKeyState_Super)
+    return false;
+
+  // Due to historical reasons, many linux ditributions set Hiragana_Katakana
+  // key as Hiragana key (which is Katkana key with shift modifier). So, we
+  // translate Hiragana_Katanaka key as Hiragana key by mapping table, and
+  // Shift + Hiragana_Katakana key as Katakana key by functionally.
+  // TODO(nona): Fix process modifier to handle right shift
+  if (IsHiraganaKatakanaKeyWithShift(keyval, keycode, modifiers)) {
+    modifiers &= ~FcitxKeyState_Shift;
+    keyval = FcitxKey_Katakana;
+  }
+  std::string kana_key_string;
+  if ((method == config::Config::KANA) && IsKanaAvailable(
+          keyval, keycode, modifiers, layout_is_jp, &kana_key_string)) {
+    out_event->set_key_code(keyval);
+    out_event->set_key_string(kana_key_string);
+  } else if (IsAscii(keyval, keycode, modifiers)) {
+    if (FcitxKeyState_CapsLock & modifiers) {
+      out_event->add_modifier_keys(commands::KeyEvent::CAPS);
+    }
+    out_event->set_key_code(keyval);
+  } else if (auto it = kIbusModifierMaskMap->find(keyval);
+             it != kIbusModifierMaskMap->end()) {
+    // Convert Ibus modifier key to mask (e.g. FcitxKey_Shift_L to FcitxKeyState_Shift)
+    modifiers |= it->second;
+  } else if (auto it = kSpecialKeyMap->find(keyval);
+             it != kSpecialKeyMap->end()) {
+    out_event->set_special_key(it->second);
+  } else {
+    MOZC_VLOG(1) << "Unknown keyval: " << keyval;
+    return false;
+  }
+
+  // Modifier keys
+  if (modifiers & FcitxKeyState_Shift && !IsPrintable(keyval, keycode, modifiers)) {
+    // Only set a SHIFT modifier when `keyval` is a printable key by following
+    // the Mozc's rule.
+    out_event->add_modifier_keys(commands::KeyEvent::SHIFT);
+  }
+  if (modifiers & FcitxKeyState_Ctrl) {
+    out_event->add_modifier_keys(commands::KeyEvent::CTRL);
+  }
+  if (modifiers & FcitxKeyState_Alt) {
+    out_event->add_modifier_keys(commands::KeyEvent::ALT);
+  }
+
+  return true;
+}
+
+bool KeyTranslator::IsHiraganaKatakanaKeyWithShift(uint32_t keyval,
+                                                   uint32_t keycode,
+                                                   uint32_t modifiers) {
+  return ((modifiers & FcitxKeyState_Shift) && (keyval == FcitxKey_Hiragana_Katakana));
+}
+
+bool KeyTranslator::IsKanaAvailable(uint32_t keyval,
+                                    uint32_t keycode,
+                                    uint32_t modifiers,
+                                    bool layout_is_jp,
+                                    std::string *out) const {
+  if ((modifiers & FcitxKeyState_Ctrl) || (modifiers & FcitxKeyState_Alt)) {
+    return false;
+  }
+  const KanaMap &kana_map = layout_is_jp ? *kKanaJpMap : *kKanaUsMap;
+
+  // When a Japanese keyboard is in use, the yen-sign key and the backslash
+  // key generate the same |keyval|. In this case, we have to check |keycode|
+  // to return an appropriate string. See the following IBus issue for
+  // details: https://github.com/ibus/ibus/issues/73
+  // Note the difference(8, evdev offset) of keycode value between ibus/fcitx.
+  // IBUS_bar was wrongly used in mozc (it's a keysym value, not key code, so
+  // the intention is to compare against 124 (a.k.a 124 + 8 here).
+  if (layout_is_jp && keyval == '\\' && keycode == 132) {
+    keyval = U'¥';  // U+00A5
+  }
+
+  const bool is_shift = (modifiers & FcitxKeyState_Shift);
+  const char* kana = GetKanaValue(kana_map, keyval, is_shift);
+
+  if (kana == nullptr) {
+    return false;
+  }
+  if (out) {
+    out->assign(kana);
+  }
+  return true;
+}
+
+// TODO(nona): resolve S-'0' problem (b/4338394).
+// TODO(nona): Current printable detection is weak. To enhance accuracy, use xkb
+// key map
+bool KeyTranslator::IsPrintable(uint32_t keyval, uint32_t keycode, uint32_t modifiers) {
+  if ((modifiers & FcitxKeyState_Ctrl) || (modifiers & FcitxKeyState_Alt)) {
+    return false;
+  }
+  return IsAscii(keyval, keycode, modifiers);
+}
+
+bool KeyTranslator::IsAscii(uint32_t keyval, uint32_t keycode, uint32_t modifiers) {
+  return (keyval > FcitxKey_space &&
+          // Note: Space key (0x20) is a special key in Mozc.
+          keyval <= FcitxKey_asciitilde);  // 0x7e.
+}
+
+}  // namespace fcitx
+}  // namespace mozc
diff --git a/src/unix/fcitx/fcitx_key_translator.h b/src/unix/fcitx/fcitx_key_translator.h
new file mode 100644
index 0000000..ca90895
--- /dev/null
+++ b/src/unix/fcitx/fcitx_key_translator.h
@@ -0,0 +1,93 @@
+// Copyright 2010-2012, Google Inc.
+// Copyright 2012~2023, Weng Xuetian <wengxt@gmail.com>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MOZC_UNIX_FCITX_FCITX_KEY_TRANSLATOR_H_
+#define MOZC_UNIX_FCITX_FCITX_KEY_TRANSLATOR_H_
+
+#include <cstdint>
+#include <map>
+#include <set>
+#include <string>
+
+#include <fcitx-config/hotkey.h>
+
+#include "base/port.h"
+#include "protocol/commands.pb.h"
+#include <fcitx/ime.h>
+
+namespace mozc {
+namespace fcitx {
+
+// This class is responsible for converting key code sent from ibus-daemon
+// (defined in /usr/include/ibus-1.0/ibuskeysyms.h) to a KeyEvent object for
+// the input of session_interface.
+class KeyTranslator {
+public:
+  KeyTranslator() = default;
+  KeyTranslator(const KeyTranslator &) = delete;
+  KeyTranslator &operator=(const KeyTranslator &) = delete;
+  virtual ~KeyTranslator() = default;
+
+  // Converts ibus keycode to Mozc key code and stores them on |out_event|.
+  // Returns true if ibus keycode is successfully converted to Mozc key code.
+  bool Translate(FcitxKeySym keyval,
+                 uint32_t keycode,
+                 uint32_t modifiers,
+                 mozc::config::Config::PreeditMethod method,
+                 bool layout_is_jp,
+                 mozc::commands::KeyEvent *out_event) const;
+
+private:
+  // Returns true iff |keyval| is a key with a kana assigned.
+  bool IsKanaAvailable(uint32_t keyval,
+                       uint32_t keycode,
+                       uint32_t modifiers,
+                       bool layout_is_jp,
+                       std::string *out) const;
+
+  // Returns true iff key is ASCII such as '0', 'A', or '!'.
+  static bool IsAscii(uint32_t keyval,
+                      uint32_t keycode,
+                      uint32_t modifiers);
+
+  // Returns true iff key is printable.
+  static bool IsPrintable(uint32_t keyval, uint32_t keycode, uint32_t modifiers);
+
+  // Returns true iff key is HiraganaKatakana with shift modifier.
+  static bool IsHiraganaKatakanaKeyWithShift(uint32_t keyval,
+                                             uint32_t keycode,
+                                             uint32_t modifiers);
+
+};
+
+}  // namespace fcitx
+}  // namespace mozc
+
+#endif  // MOZC_UNIX_FCITX_FCITX_KEY_TRANSLATOR_H_
diff --git a/src/unix/fcitx/fcitx_mozc.cc b/src/unix/fcitx/fcitx_mozc.cc
new file mode 100644
index 0000000..6b4c155
--- /dev/null
+++ b/src/unix/fcitx/fcitx_mozc.cc
@@ -0,0 +1,553 @@
+// Copyright 2012~2013, Weng Xuetian <wengxt@gmail.com>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "unix/fcitx/fcitx_mozc.h"
+
+#include <string>
+#include <fcitx/context.h>
+#include <fcitx/candidate.h>
+#include <fcitx/module.h>
+#include <fcitx-config/xdg.h>
+
+// Resolve macro naming conflict with absl.
+#undef InvokeFunction
+
+#include "absl/log/check.h"
+#include "base/const.h"
+#include "base/vlog.h"
+#include "base/process.h"
+#include "base/util.h"
+#include "base/file_util.h"
+#include "base/system_util.h"
+#include "unix/fcitx/mozc_connection.h"
+#include "unix/fcitx/mozc_response_parser.h"
+
+#define N_(x) (x)
+
+namespace
+{
+
+static const std::string empty_string;
+
+const struct CompositionMode
+{
+    const char *icon;
+    const char *label;
+    const char *description;
+    mozc::commands::CompositionMode mode;
+} kPropCompositionModes[] =
+{
+    {
+        "mozc-direct.png",
+        "A",
+        N_("Direct"),
+        mozc::commands::DIRECT,
+    }, {
+        "mozc-hiragana.png",
+        "\xe3\x81\x82",  // Hiragana letter A in UTF-8.
+        N_("Hiragana"),
+        mozc::commands::HIRAGANA,
+    }, {
+        "mozc-katakana_full.png",
+        "\xe3\x82\xa2",  // Katakana letter A.
+        N_("Full Katakana"),
+        mozc::commands::FULL_KATAKANA,
+    }, {
+        "mozc-alpha_half.png",
+        "A",
+        N_("Half ASCII"),
+        mozc::commands::HALF_ASCII,
+    }, {
+        "mozc-alpha_full.png",
+        "\xef\xbc\xa1",  // Full width ASCII letter A.
+        N_("Full ASCII"),
+        mozc::commands::FULL_ASCII,
+    }, {
+        "mozc-katakana_half.png",
+        "\xef\xbd\xb1",  // Half width Katakana letter A.
+        N_("Half Katakana"),
+        mozc::commands::HALF_KATAKANA,
+    },
+};
+const size_t kNumCompositionModes = FCITX_ARRAY_SIZE ( kPropCompositionModes );
+
+// This array must correspond with the CompositionMode enum in the
+// mozc/session/command.proto file.
+static_assert (
+    mozc::commands::NUM_OF_COMPOSITIONS == FCITX_ARRAY_SIZE ( kPropCompositionModes ),
+    "number of modes must match" );
+
+}  // namespace
+
+INPUT_RETURN_VALUE FcitxMozcGetCandidateWord(void* arg, FcitxCandidateWord* candWord)
+{
+    mozc::fcitx::FcitxMozc* fcitx_mozc = (mozc::fcitx::FcitxMozc*) arg;
+    fcitx_mozc->select_candidate(candWord);
+
+    return IRV_DISPLAY_CANDWORDS;
+}
+
+
+namespace mozc
+{
+
+namespace fcitx
+{
+
+// For unittests.
+FcitxMozc::FcitxMozc ( FcitxInstance* inst,
+                       MozcConnectionInterface *connection,
+                       MozcResponseParser *parser ) :
+        instance(inst),
+        input(FcitxInstanceGetInputState(inst)),
+        connection_ ( connection ),
+        parser_ ( parser ),
+        composition_mode_ ( mozc::commands::HIRAGANA )
+{
+    // mozc::Logging::SetVerboseLevel(1);
+    MOZC_VLOG ( 1 ) << "FcitxMozc created.";
+    const bool is_vertical = true;
+    parser_->set_use_annotation ( is_vertical );
+    InitializeBar();
+    InitializeMenu();
+    SetCompositionMode( mozc::commands::HIRAGANA );
+}
+
+FcitxMozc::~FcitxMozc()
+{
+    MOZC_VLOG ( 1 ) << "FcitxMozc destroyed.";
+}
+
+// This function is called from SCIM framework when users press or release a
+// key.
+bool FcitxMozc::process_key_event (FcitxKeySym sym, uint32_t keycode, uint32_t state, bool layout_is_jp, bool is_key_up)
+{
+    std::string error;
+    mozc::commands::Output raw_response;
+    if ( !connection_->TrySendKeyEvent (
+                GetInstance(), sym, keycode, state, composition_mode_, layout_is_jp, is_key_up, &raw_response, &error ) )
+    {
+        // TODO(yusukes): Show |error|.
+        return false;  // not consumed.
+    }
+
+    return ParseResponse ( raw_response );
+}
+
+// This function is called from SCIM framework when users click the candidate
+// window.
+void FcitxMozc::select_candidate ( FcitxCandidateWord* candWord )
+{
+    int32_t *id = (int32_t*) candWord->priv;
+
+    if ( *id == kBadCandidateId )
+    {
+        LOG ( ERROR ) << "The clicked candidate doesn't have unique ID.";
+        return;
+    }
+    MOZC_VLOG ( 1 ) << "select_candidate, id=" << *id;
+
+    std::string error;
+    mozc::commands::Output raw_response;
+    if ( !connection_->TrySendClick ( *id, &raw_response, &error ) )
+    {
+        LOG ( ERROR ) << "IPC failed. error=" << error;
+        SetAuxString ( error );
+        DrawAll();
+    }
+    else
+    {
+        ParseResponse ( raw_response );
+    }
+}
+
+// This function is called from SCIM framework.
+void FcitxMozc::resetim()
+{
+    MOZC_VLOG ( 1 ) << "resetim";
+    std::string error;
+    mozc::commands::Output raw_response;
+    if ( connection_->TrySendCommand (
+                mozc::commands::SessionCommand::REVERT, &raw_response, &error ) )
+    {
+        parser_->ParseResponse ( raw_response, this );
+    }
+    ClearAll();  // just in case.
+    DrawAll();
+
+}
+
+void FcitxMozc::reset()
+{
+    FcitxIM* im = FcitxInstanceGetCurrentIM(instance);
+    if (!im || strcmp(im->uniqueName, "mozc") != 0) {
+        FcitxUISetStatusVisable(instance, "mozc-tool", false);
+        FcitxUISetStatusVisable(instance, "mozc-composition-mode", false);
+    }
+    else {
+        FcitxUISetStatusVisable(instance, "mozc-tool", true);
+        FcitxUISetStatusVisable(instance, "mozc-composition-mode", true);
+        connection_->UpdatePreeditMethod();
+    }
+}
+
+bool FcitxMozc::paging(bool prev)
+{
+    MOZC_VLOG ( 1 ) << "paging";
+    std::string error;
+    mozc::commands::SessionCommand::CommandType command =
+        prev ? mozc::commands::SessionCommand::CONVERT_PREV_PAGE
+             : mozc::commands::SessionCommand::CONVERT_NEXT_PAGE;
+    mozc::commands::Output raw_response;
+    if ( connection_->TrySendCommand (
+        command, &raw_response, &error ) )
+    {
+        parser_->ParseResponse ( raw_response, this );
+        return true;
+    }
+    return false;
+}
+
+// This function is called from SCIM framework when the ic gets focus.
+void FcitxMozc::init()
+{
+    MOZC_VLOG ( 1 ) << "init";
+    boolean flag = true;
+    FcitxInstanceSetContext(instance, CONTEXT_DISABLE_AUTOENG, &flag);
+    FcitxInstanceSetContext(instance, CONTEXT_DISABLE_FULLWIDTH, &flag);
+    FcitxInstanceSetContext(instance, CONTEXT_DISABLE_QUICKPHRASE, &flag);
+    FcitxInstanceSetContext(instance, CONTEXT_IM_KEYBOARD_LAYOUT, "jp");
+    FcitxInstanceSetContext(instance, "CONTEXT_DISABLE_AUTO_FIRST_CANDIDATE_HIGHTLIGHT", &flag);
+
+    connection_->UpdatePreeditMethod();
+    DrawAll();
+}
+
+// This function is called when the ic loses focus.
+void FcitxMozc::focus_out()
+{
+    MOZC_VLOG ( 1 ) << "focus_out";
+    std::string error;
+    mozc::commands::Output raw_response;
+    if ( connection_->TrySendCommand (
+                mozc::commands::SessionCommand::REVERT, &raw_response, &error ) )
+    {
+        parser_->ParseResponse ( raw_response, this );
+    }
+    ClearAll();  // just in case.
+    DrawAll();
+    // TODO(yusukes): Call client::SyncData() like ibus-mozc.
+}
+
+
+bool FcitxMozc::ParseResponse ( const mozc::commands::Output &raw_response )
+{
+    ClearAll();
+    const bool consumed = parser_->ParseResponse ( raw_response, this );
+    if ( !consumed )
+    {
+        MOZC_VLOG ( 1 ) << "The input was not consumed by Mozc.";
+    }
+    OpenUrl();
+    DrawAll();
+    return consumed;
+}
+
+void FcitxMozc::SetResultString ( const std::string &result_string )
+{
+    FcitxInstanceCommitString(instance, FcitxInstanceGetCurrentIC(instance), result_string.c_str());
+}
+
+void FcitxMozc::SetPreeditInfo ( const PreeditInfo *preedit_info )
+{
+    preedit_info_.reset ( preedit_info );
+}
+
+void FcitxMozc::SetAuxString ( const std::string &str )
+{
+    aux_ = str;
+}
+
+void FcitxMozc::SetCompositionMode ( mozc::commands::CompositionMode mode )
+{
+    composition_mode_ = mode;
+    DCHECK(composition_mode_ < kNumCompositionModes);
+    if (composition_mode_ < kNumCompositionModes) {
+        FcitxUISetStatusString(instance,
+                               "mozc-composition-mode",
+                               _(kPropCompositionModes[composition_mode_].label),
+                               _(kPropCompositionModes[composition_mode_].description));
+    }
+}
+
+void FcitxMozc::SendCompositionMode(mozc::commands::CompositionMode mode)
+{
+    // Send the SWITCH_INPUT_MODE command.
+    std::string error;
+    mozc::commands::Output raw_response;
+    if (connection_->TrySendCompositionMode(
+            kPropCompositionModes[mode].mode, composition_mode_, &raw_response, &error)) {
+        parser_->ParseResponse(raw_response, this);
+    }
+}
+
+
+void FcitxMozc::SetUrl ( const std::string &url )
+{
+    url_ = url;
+}
+
+void FcitxMozc::ClearAll()
+{
+    SetPreeditInfo ( NULL );
+    SetAuxString ( "" );
+    FcitxCandidateWordReset(FcitxInputStateGetCandidateList(input));
+    url_.clear();
+}
+
+void FcitxMozc::DrawPreeditInfo()
+{
+    FcitxMessages* preedit = FcitxInputStateGetPreedit(input);
+    FcitxMessages* clientpreedit = FcitxInputStateGetClientPreedit(input);
+    FcitxMessagesSetMessageCount(preedit, 0);
+    FcitxMessagesSetMessageCount(clientpreedit, 0);
+    if ( preedit_info_.get() )
+    {
+        MOZC_VLOG ( 1 ) << "DrawPreeditInfo: cursor=" << preedit_info_->cursor_pos;
+
+        FcitxInputContext* ic = FcitxInstanceGetCurrentIC(instance);
+        boolean supportPreedit = FcitxInstanceICSupportPreedit(instance, ic);
+
+        if (!supportPreedit)
+            FcitxInputStateSetShowCursor(input, true);
+
+        for (int i = 0; i < preedit_info_->preedit.size(); i ++) {
+            if (!supportPreedit)
+                FcitxMessagesAddMessageAtLast(preedit, preedit_info_->preedit[i].type, "%s", preedit_info_->preedit[i].str.c_str());
+            FcitxMessagesAddMessageAtLast(clientpreedit, preedit_info_->preedit[i].type, "%s", preedit_info_->preedit[i].str.c_str());
+        }
+        if (!supportPreedit)
+            FcitxInputStateSetCursorPos(input, preedit_info_->cursor_pos);
+        FcitxInputStateSetClientCursorPos(input, preedit_info_->cursor_pos);
+    }
+    else {
+        FcitxInputStateSetShowCursor(input, false);
+    }
+    if ( !aux_.empty() ) {
+        FcitxMessagesAddMessageAtLast(preedit, MSG_TIPS, "%s[%s]", preedit_info_.get() ? " " : "", aux_.c_str());
+    }
+}
+
+void FcitxMozc::DrawAux()
+{
+    FcitxMessages* auxUp = FcitxInputStateGetAuxUp(input);
+    FcitxMessages* auxDown = FcitxInputStateGetAuxDown(input);
+    FcitxMessagesSetMessageCount(auxUp, 0);
+    FcitxMessagesSetMessageCount(auxDown, 0);
+}
+
+void FcitxMozc::DrawAll()
+{
+    DrawPreeditInfo();
+    DrawAux();
+}
+
+void FcitxMozc::OpenUrl()
+{
+    if ( url_.empty() )
+    {
+        return;
+    }
+    mozc::Process::OpenBrowser ( url_ );
+    url_.clear();
+}
+
+static const char* GetCompositionIconName(void* arg)
+{
+    FcitxMozc* mozc = (FcitxMozc*) arg;
+    return mozc->GetCurrentCompositionModeIcon().c_str();
+}
+
+
+static const char* GetMozcToolIcon(void* arg)
+{
+    FcitxMozc* mozc = (FcitxMozc*) arg;
+    return mozc->GetIconFile("mozc-tool.png").c_str();
+}
+
+void FcitxMozc::InitializeBar()
+{
+    MOZC_VLOG ( 1 ) << "Registering properties";
+
+    FcitxUIRegisterComplexStatus(instance, this,
+        "mozc-composition-mode",
+        _("Composition Mode"),
+        _("Composition Mode"),
+        NULL,
+        GetCompositionIconName
+    );
+
+    if ( mozc::FileUtil::FileExists ( mozc::FileUtil::JoinPath (
+                                      mozc::SystemUtil::GetServerDirectory(), mozc::kMozcTool ) ).ok() )
+    {
+        FcitxUIRegisterComplexStatus(instance, this,
+            "mozc-tool",
+            _("Tool"),
+            _("Tool"),
+            NULL,
+            GetMozcToolIcon
+        );
+    }
+    FcitxUISetStatusVisable(instance, "mozc-tool", false);
+    FcitxUISetStatusVisable(instance, "mozc-composition-mode", false);
+}
+
+boolean CompositionMenuAction(struct _FcitxUIMenu *menu, int index)
+{
+    FcitxMozc* mozc = (FcitxMozc*) menu->priv;
+    mozc->SendCompositionMode((mozc::commands::CompositionMode) index);
+    return true;
+}
+
+void UpdateCompositionMenu(struct _FcitxUIMenu *menu)
+{
+    FcitxMozc* mozc = (FcitxMozc*) menu->priv;
+    menu->mark = mozc->GetCompositionMode();
+}
+
+boolean ToolMenuAction(struct _FcitxUIMenu *menu, int index)
+{
+    std::string args;
+    switch(index) {
+        case 0:
+            args = "--mode=config_dialog";
+            break;
+        case 1:
+            args = "--mode=dictionary_tool";
+            break;
+        case 2:
+            args = "--mode=word_register_dialog";
+            break;
+        case 3:
+            args = "--mode=about_dialog";
+            break;
+    }
+    mozc::Process::SpawnMozcProcess("mozc_tool", args);
+    return true;
+}
+
+void UpdateToolMenu(struct _FcitxUIMenu *menu)
+{
+    return;
+}
+
+void FcitxMozc::InitializeMenu()
+{
+    FcitxMenuInit(&this->compositionMenu);
+    compositionMenu.name = strdup(_("Composition Mode"));
+    compositionMenu.candStatusBind = strdup("mozc-composition-mode");
+    compositionMenu.UpdateMenu = UpdateCompositionMenu;
+    compositionMenu.MenuAction = CompositionMenuAction;
+    compositionMenu.priv = this;
+    compositionMenu.isSubMenu = false;
+    int i;
+    for (i = 0; i < kNumCompositionModes; i ++)
+        FcitxMenuAddMenuItem(&compositionMenu, _(kPropCompositionModes[i].description), MENUTYPE_SIMPLE, NULL);
+
+    FcitxUIRegisterMenu(instance, &compositionMenu);
+
+    FcitxMenuInit(&this->toolMenu);
+    toolMenu.name = strdup(_("Mozc Tool"));
+    toolMenu.candStatusBind = strdup("mozc-tool");
+    toolMenu.UpdateMenu = UpdateToolMenu;
+    toolMenu.MenuAction = ToolMenuAction;
+    toolMenu.priv = this;
+    toolMenu.isSubMenu = false;
+    FcitxMenuAddMenuItem(&toolMenu, _("Configuration Tool"), MENUTYPE_SIMPLE, NULL);
+    FcitxMenuAddMenuItem(&toolMenu, _("Dictionary Tool"), MENUTYPE_SIMPLE, NULL);
+    FcitxMenuAddMenuItem(&toolMenu, _("Add Word"), MENUTYPE_SIMPLE, NULL);
+    FcitxMenuAddMenuItem(&toolMenu, _("About Mozc"), MENUTYPE_SIMPLE, NULL);
+    FcitxUIRegisterMenu(instance, &toolMenu);
+}
+
+bool FcitxMozc::SendCommand(const mozc::commands::SessionCommand& session_command, commands::Output* new_output)
+{
+    std::string error;
+    return connection_->TrySendRawCommand(session_command, new_output, &error);
+}
+
+
+FcitxInputState* FcitxMozc::GetInputState()
+{
+    return input;
+}
+
+const std::string& FcitxMozc::GetIconFile(const std::string key)
+{
+    if (iconMap.count(key)) {
+        return iconMap[key];
+    }
+
+    char* retFile;
+    FILE* fp = FcitxXDGGetFileWithPrefix("mozc/icon", key.c_str(), "r", &retFile);
+    if (fp)
+        fclose(fp);
+    if (retFile) {
+        iconMap[key] = std::string(retFile);
+        free(retFile);
+    }
+    else {
+        iconMap[key] = "";
+    }
+    return iconMap[key];
+}
+
+
+const std::string& FcitxMozc::GetCurrentCompositionModeIcon() {
+    DCHECK(composition_mode_ < kNumCompositionModes);
+    if (composition_mode_ < kNumCompositionModes) {
+        return GetIconFile(kPropCompositionModes[composition_mode_].icon);
+    }
+    return empty_string;
+}
+
+void FcitxMozc::SetUsage(const std::string& title_, const std::string& description_)
+{
+    title = title_;
+    description = description_;
+}
+
+std::pair< std::string, std::string > FcitxMozc::GetUsage()
+{
+    return make_pair(title, description);
+}
+
+}  // namespace fcitx
+
+}  // namespace mozc_unix_scim
diff --git a/src/unix/fcitx/fcitx_mozc.h b/src/unix/fcitx/fcitx_mozc.h
new file mode 100644
index 0000000..1bef6b3
--- /dev/null
+++ b/src/unix/fcitx/fcitx_mozc.h
@@ -0,0 +1,176 @@
+// Copyright 2012~2013, Weng Xuetian <wengxt@gmail.com>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MOZC_UNIX_FCITX_FCITX_MOZC_H_
+#define MOZC_UNIX_FCITX_FCITX_MOZC_H_
+
+#include <cstdint>
+#include <memory>
+
+#include <fcitx/instance.h>
+#include <fcitx/candidate.h>
+#include <fcitx-config/hotkey.h>
+#include <libintl.h>
+
+#include "base/port.h"
+#include "base/run_level.h"
+#include "protocol/commands.pb.h"
+#include "client/client_interface.h"
+#include "mozc_connection.h"
+
+#define _(x) dgettext("fcitx-mozc", (x))
+
+INPUT_RETURN_VALUE FcitxMozcGetCandidateWord(void* arg, FcitxCandidateWord* candWord);;
+
+namespace mozc
+{
+
+namespace fcitx
+{
+const int32_t kBadCandidateId = -12345;
+class IMEngineFactory;
+class MozcConnectionInterface;
+class MozcResponseParser;
+class KeyTranslator;
+
+struct PreeditItem {
+        std::string str;
+        FcitxMessageType type;
+};
+
+// Preedit string and its attributes.
+struct PreeditInfo
+{
+    uint32_t cursor_pos;
+    
+    std::vector<PreeditItem> preedit;
+};
+
+class FcitxMozc
+{
+public:
+    // This constructor is used by unittests.
+    FcitxMozc ( FcitxInstance* instance,
+                MozcConnectionInterface *connection,
+                MozcResponseParser *parser );
+    FcitxMozc(const FcitxMozc &) = delete;
+    virtual ~FcitxMozc();
+
+    bool process_key_event (FcitxKeySym sym, uint32_t keycode, uint32_t state, bool layout_is_jp, bool is_key_up);
+    void select_candidate ( FcitxCandidateWord* candWord );
+    void resetim();
+    void reset();
+    void init();
+    void focus_out();
+    bool paging(bool prev);
+
+    // Functions called by the MozcResponseParser class to update UI.
+
+    // Displays a 'result' (aka 'commit string') on FCITX UI.
+    void SetResultString ( const std::string &result_string );
+    // Displays a 'preedit' string on FCITX UI. This function takes ownership
+    // of preedit_info. If the parameter is NULL, hides the string currently
+    // displayed.
+    void SetPreeditInfo ( const PreeditInfo *preedit_info );
+    // Displays an auxiliary message (e.g., an error message, a title of
+    // candidate window). If the string is empty (""), hides the message
+    // currently being displayed.
+    void SetAuxString ( const std::string &str );
+    // Sets a current composition mode (e.g., Hankaku Katakana).
+    void SetCompositionMode ( mozc::commands::CompositionMode mode );
+    
+    void SendCompositionMode ( mozc::commands::CompositionMode mode );
+
+    // Sets the url to be opened by the default browser.
+    void SetUrl ( const std::string &url );
+
+    const std::string& GetIconFile(const std::string key);
+    
+    const std::string& GetCurrentCompositionModeIcon();
+    
+    mozc::commands::CompositionMode GetCompositionMode() { return composition_mode_; }
+    
+    FcitxInstance* GetInstance() { return instance; }
+    
+    FcitxInputState* GetInputState();
+
+    mozc::client::ClientInterface* GetClient() { return connection_->GetClient(); }
+
+    bool SendCommand(const mozc::commands::SessionCommand& session_command, mozc::commands::Output* new_output);
+
+    void SetUsage(const std::string& title, const std::string& description);
+
+    std::pair<std::string, std::string> GetUsage();
+
+    void DrawAll();
+
+private:
+    friend class FcitxMozcTest;
+
+    // Adds Mozc-specific icons to FCITX toolbar.
+    void InitializeBar();
+    
+    void InitializeMenu();
+
+    // Parses the response from mozc_server. Returns whether the server consumes
+    // the input or not (true means 'consumed').
+    bool ParseResponse ( const mozc::commands::Output &request );
+
+    void ClearAll();
+    void DrawPreeditInfo();
+    void DrawAux();
+
+    // Open url_ with a default browser.
+    void OpenUrl();
+
+    FcitxInstance* instance;
+    FcitxInputState* input;
+    const std::unique_ptr<MozcConnectionInterface> connection_;
+    const std::unique_ptr<MozcResponseParser> parser_;
+
+    // Strings and a window currently displayed on FCITX UI.
+    std::unique_ptr<const PreeditInfo> preedit_info_;
+    std::string aux_;  // error tooltip, or candidate window title.
+    std::string url_;  // URL to be opened by a browser.
+    mozc::commands::CompositionMode composition_mode_;
+    
+    std::map<std::string, std::string> iconMap;
+    
+    FcitxUIMenu compositionMenu;
+    FcitxUIMenu toolMenu;
+    std::string description;
+    std::string title;
+};
+
+}  // namespace fcitx
+
+}  // namespace mozc
+
+#endif  // MOZC_UNIX_FCITX_FCITX_MOZC_H_
+
diff --git a/src/unix/fcitx/gen_fcitx_mozc_i18n.sh b/src/unix/fcitx/gen_fcitx_mozc_i18n.sh
new file mode 100755
index 0000000..97ff4a4
--- /dev/null
+++ b/src/unix/fcitx/gen_fcitx_mozc_i18n.sh
@@ -0,0 +1,10 @@
+#!/bin/sh
+
+objdir="$1"
+
+mkdir -p "$1"
+
+for pofile in po/*.po
+do
+    msgfmt "$pofile" -o "$1/`basename ${pofile} .po`.mo"
+done
diff --git a/src/unix/fcitx/mozc.conf b/src/unix/fcitx/mozc.conf
new file mode 100644
index 0000000..ad19230
--- /dev/null
+++ b/src/unix/fcitx/mozc.conf
@@ -0,0 +1,7 @@
+[InputMethod]
+UniqueName=mozc
+Name=Mozc
+IconName=/usr/share/fcitx/mozc/icon/mozc.png
+Priority=1
+LangCode=ja
+Parent=fcitx-mozc
diff --git a/src/unix/fcitx/mozc_connection.cc b/src/unix/fcitx/mozc_connection.cc
new file mode 100755
index 0000000..0adcbb6
--- /dev/null
+++ b/src/unix/fcitx/mozc_connection.cc
@@ -0,0 +1,205 @@
+// Copyright 2010-2012, Google Inc.
+// Copyright 2012~2013, Weng Xuetian <wengxt@gmail.com>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "unix/fcitx/mozc_connection.h"
+
+#include <string>
+
+#include "absl/log/check.h"
+#include "base/vlog.h"
+#include "base/util.h"
+#include "client/client.h"
+#include "protocol/commands.pb.h"
+#include "unix/fcitx/fcitx_key_event_handler.h"
+#include "unix/fcitx/surrounding_text_util.h"
+
+namespace mozc {
+namespace fcitx {
+
+MozcConnectionInterface::~MozcConnectionInterface() {
+}
+
+std::unique_ptr<mozc::client::ClientInterface> CreateAndConfigureClient() {
+  auto client = client::ClientFactory::NewClient();
+  // Currently client capability is fixed.
+  commands::Capability capability;
+  capability.set_text_deletion(commands::Capability::DELETE_PRECEDING_TEXT);
+  client->set_client_capability(capability);
+  return client;
+}
+
+MozcConnection::MozcConnection()
+    : handler_(new KeyEventHandler),
+      preedit_method_(mozc::config::Config::ROMAN) {
+  MOZC_VLOG(1) << "MozcConnection is created";
+  auto client = CreateAndConfigureClient();
+  client_ = std::move(client);
+
+  if (client_->EnsureConnection()) {
+    UpdatePreeditMethod();
+  }
+  MOZC_VLOG(1)
+      << "Current preedit method is "
+      << (preedit_method_ == mozc::config::Config::ROMAN ? "Roman" : "Kana");
+}
+
+MozcConnection::~MozcConnection() {
+  client_->SyncData();
+  MOZC_VLOG(1) << "MozcConnection is destroyed";
+}
+
+void MozcConnection::UpdatePreeditMethod() {
+  mozc::config::Config config;
+  if (!client_->GetConfig(&config)) {
+    LOG(ERROR) << "GetConfig failed";
+    return;
+  }
+  preedit_method_ = config.has_preedit_method() ?
+      config.preedit_method() : config::Config::ROMAN;
+}
+
+bool MozcConnection::TrySendKeyEvent(
+    FcitxInstance* instance,
+    FcitxKeySym sym, uint32_t keycode, uint32_t state,
+    mozc::commands::CompositionMode composition_mode,
+    bool layout_is_jp,
+    bool is_key_up,
+    mozc::commands::Output *out,
+    std::string *out_error) const {
+  DCHECK(out);
+  DCHECK(out_error);
+
+  // Call EnsureConnection just in case MozcConnection::MozcConnection() fails
+  // to establish the server connection.
+  if (!client_->EnsureConnection()) {
+    *out_error = "EnsureConnection failed";
+    MOZC_VLOG(1) << "EnsureConnection failed";
+    return false;
+  }
+
+  mozc::commands::KeyEvent event;
+  if (!handler_->GetKeyEvent(sym, keycode, state, preedit_method_, layout_is_jp, is_key_up, &event))
+      return false;
+
+  if ((composition_mode == mozc::commands::DIRECT) &&
+      !client_->IsDirectModeCommand(event)) {
+    MOZC_VLOG(1) << "In DIRECT mode. Not consumed.";
+    return false;  // not consumed.
+  }
+
+  commands::Context context;
+  SurroundingTextInfo surrounding_text_info;
+  if (GetSurroundingText(instance,
+                         &surrounding_text_info)) {
+    context.set_preceding_text(surrounding_text_info.preceding_text);
+    context.set_following_text(surrounding_text_info.following_text);
+  }
+
+  MOZC_VLOG(1) << "TrySendKeyEvent: " << std::endl << event.DebugString();
+  if (!client_->SendKeyWithContext(event, context, out)) {
+    *out_error = "SendKey failed";
+    MOZC_VLOG(1) << "ERROR";
+    return false;
+  }
+  MOZC_VLOG(1) << "OK: " << std::endl << out->DebugString();
+  return true;
+}
+
+bool MozcConnection::TrySendClick(int32_t unique_id,
+                                  mozc::commands::Output *out,
+                                  std::string *out_error) const {
+  DCHECK(out);
+  DCHECK(out_error);
+
+  mozc::commands::SessionCommand command;
+  command.set_type(mozc::commands::SessionCommand::SELECT_CANDIDATE);
+  command.set_id(unique_id);
+  return TrySendRawCommand(command, out, out_error);
+}
+
+bool MozcConnection::TrySendCompositionMode(
+    mozc::commands::CompositionMode mode,
+    mozc::commands::CompositionMode old_mode,
+    mozc::commands::Output *out,
+    std::string *out_error) const {
+  DCHECK(out);
+  DCHECK(out_error);
+
+  mozc::commands::SessionCommand command;
+  if (mode == mozc::commands::DIRECT) {
+    command.set_type(mozc::commands::SessionCommand::TURN_OFF_IME);
+    command.set_composition_mode(old_mode);
+  } else {
+    command.set_type(mozc::commands::SessionCommand::SWITCH_INPUT_MODE);
+    command.set_composition_mode(mode);
+  }
+  return TrySendRawCommand(command, out, out_error);
+}
+
+bool MozcConnection::TrySendCommand(
+    mozc::commands::SessionCommand::CommandType type,
+    mozc::commands::Output *out,
+    std::string *out_error) const {
+  DCHECK(out);
+  DCHECK(out_error);
+
+  mozc::commands::SessionCommand command;
+  command.set_type(type);
+  return TrySendRawCommand(command, out, out_error);
+}
+
+
+
+bool MozcConnection::TrySendRawCommand(
+    const mozc::commands::SessionCommand& command,
+    mozc::commands::Output *out,
+    std::string *out_error) const {
+  MOZC_VLOG(1) << "TrySendRawCommand: " << std::endl << command.DebugString();
+  if (!client_->SendCommand(command, out)) {
+    *out_error = "SendCommand failed";
+    MOZC_VLOG(1) << "ERROR";
+    return false;
+  }
+  MOZC_VLOG(1) << "OK: " << std::endl << out->DebugString();
+  return true;
+}
+
+mozc::client::ClientInterface* MozcConnection::GetClient()
+{
+    return client_.get();
+}
+
+MozcConnection *MozcConnection::CreateMozcConnection() {
+  return new MozcConnection;
+}
+
+}  // namespace fcitx
+
+}  // namespace mozc
diff --git a/src/unix/fcitx/mozc_connection.h b/src/unix/fcitx/mozc_connection.h
new file mode 100755
index 0000000..cb6ab25
--- /dev/null
+++ b/src/unix/fcitx/mozc_connection.h
@@ -0,0 +1,146 @@
+// Copyright 2010-2012, Google Inc.
+// Copyright 2012~2013, Weng Xuetian <wengxt@gmail.com>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MOZC_UNIX_FCITX_MOZC_CONNECTION_H_
+#define MOZC_UNIX_FCITX_MOZC_CONNECTION_H_
+
+#include <cstdint>
+#include <string>
+#include <memory>
+
+#include <fcitx-config/hotkey.h>
+#include <fcitx/instance.h>
+
+#include "base/port.h"
+#include "protocol/commands.pb.h"
+#include "unix/fcitx/fcitx_key_event_handler.h"
+
+namespace mozc {
+
+namespace client {
+class ClientInterface;
+}  // namespace client
+
+}  // namespace mozc
+
+namespace mozc {
+    
+namespace fcitx {
+
+class KeyTranslator;
+
+// This class is for mozc_response_parser_test.cc.
+class MozcConnectionInterface {
+ public:
+  virtual ~MozcConnectionInterface();
+
+  virtual bool TrySendKeyEvent(FcitxInstance* instance,
+                               FcitxKeySym sym, uint32_t keycode, uint32_t state,
+                               mozc::commands::CompositionMode composition_mode,
+                               bool layout_is_jp,
+                               bool is_key_up,
+                               mozc::commands::Output *out,
+                               std::string *out_error) const = 0;
+  virtual bool TrySendClick(int32_t unique_id,
+                            mozc::commands::Output *out,
+                            std::string *out_error) const = 0;
+  virtual bool TrySendCompositionMode(mozc::commands::CompositionMode mode,
+                                      mozc::commands::CompositionMode old_mode,
+                                      mozc::commands::Output *out,
+                                      std::string *out_error) const = 0;
+  virtual bool TrySendCommand(mozc::commands::SessionCommand::CommandType type,
+                              mozc::commands::Output *out,
+                              std::string *out_error) const = 0;
+
+  virtual bool TrySendRawCommand(const mozc::commands::SessionCommand& command,
+                                 mozc::commands::Output *out,
+                                 std::string *out_error) const = 0;
+  virtual mozc::client::ClientInterface* GetClient() = 0;
+  virtual void UpdatePreeditMethod() = 0;
+};
+
+class MozcConnection : public MozcConnectionInterface {
+ public:
+  MozcConnection(const MozcConnection &) = delete;
+  static const int kNoSession;
+
+  static MozcConnection *CreateMozcConnection();
+  virtual ~MozcConnection();
+
+  // Sends key event to the server. If the IPC succeeds, returns true and the
+  // response is stored on 'out' (and 'out_error' is not modified). If the IPC
+  // fails, returns false and the error message is stored on 'out_error'. In
+  // this case, 'out' is not modified.
+  virtual bool TrySendKeyEvent(FcitxInstance* instance,
+                               FcitxKeySym sym, uint32_t keycode, uint32_t state,
+                               mozc::commands::CompositionMode composition_mode,
+                               bool layout_is_jp,
+                               bool is_key_up,
+                               mozc::commands::Output *out,
+                               std::string *out_error) const;
+
+  // Sends 'mouse click on the candidate window' event to the server.
+  virtual bool TrySendClick(int32_t unique_id,
+                            mozc::commands::Output *out,
+                            std::string *out_error) const;
+
+  // Sends composition mode to the server.
+  virtual bool TrySendCompositionMode(mozc::commands::CompositionMode mode,
+                                      mozc::commands::CompositionMode old_mode,
+                                      mozc::commands::Output *out,
+                                      std::string *out_error) const;
+
+  // Sends a command to the server.
+  virtual bool TrySendCommand(mozc::commands::SessionCommand::CommandType type,
+                              mozc::commands::Output *out,
+                              std::string *out_error) const;
+
+  virtual bool TrySendRawCommand(const mozc::commands::SessionCommand& command,
+                                 mozc::commands::Output *out,
+                                 std::string *out_error) const;
+
+  virtual mozc::client::ClientInterface* GetClient();
+
+  virtual void UpdatePreeditMethod();
+
+ private:
+  friend class MozcConnectionTest;
+  MozcConnection();
+
+  const std::unique_ptr<KeyEventHandler> handler_;
+  mozc::config::Config::PreeditMethod preedit_method_;
+  std::unique_ptr<mozc::client::ClientInterface> client_;
+};
+
+}  // namespace fcitx
+
+}  // namespace mozc
+
+#endif  // MOZC_UNIX_SCIM_MOZC_CONNECTION_H_
diff --git a/src/unix/fcitx/mozc_response_parser.cc b/src/unix/fcitx/mozc_response_parser.cc
new file mode 100755
index 0000000..400374b
--- /dev/null
+++ b/src/unix/fcitx/mozc_response_parser.cc
@@ -0,0 +1,448 @@
+// Copyright 2010-2012, Google Inc.
+// Copyright 2012~2013, Weng Xuetian <wengxt@gmail.com>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "unix/fcitx/mozc_response_parser.h"
+
+#include <string>
+#include <vector>
+
+#include "absl/log/check.h"
+#include "base/vlog.h"
+#include "base/util.h"
+#include "protocol/commands.pb.h"
+#include "unix/fcitx/fcitx_mozc.h"
+#include "unix/fcitx/surrounding_text_util.h"
+#include <fcitx/candidate.h>
+
+namespace {
+
+// Returns a position that determines a preedit cursor position _AND_ top-left
+// position of a candidate window. Note that we can't set these two positions
+// independently. That's a SCIM's limitation.
+uint32_t GetCursorPosition(const mozc::commands::Output &response) {
+    if (!response.has_preedit()) {
+        return 0;
+    }
+    if (response.preedit().has_highlighted_position()) {
+        return response.preedit().highlighted_position();
+    }
+    return response.preedit().cursor();
+}
+
+std::string CreateDescriptionString(const std::string &description) {
+    return " [" + description + "]";
+}
+
+}  // namespace
+
+namespace mozc {
+
+namespace fcitx {
+
+MozcResponseParser::MozcResponseParser()
+        : use_annotation_(false) {
+}
+
+MozcResponseParser::~MozcResponseParser() {
+}
+
+void MozcResponseParser::UpdateDeletionRange(const mozc::commands::Output& response, FcitxMozc* fcitx_mozc) const
+{
+    if (response.has_deletion_range() &&
+        response.deletion_range().offset() <= 0 &&
+        response.deletion_range().offset() + response.deletion_range().length() >= 0) {
+        FcitxInstanceDeleteSurroundingText(fcitx_mozc->GetInstance(),
+                                           FcitxInstanceGetCurrentIC(fcitx_mozc->GetInstance()),
+                                           response.deletion_range().offset(),
+                                           response.deletion_range().length());
+    }
+}
+
+void MozcResponseParser::LaunchTool(const mozc::commands::Output& response, FcitxMozc* fcitx_mozc) const
+{
+    FCITX_UNUSED(fcitx_mozc);
+    if (response.has_launch_tool_mode()) {
+        fcitx_mozc->GetClient()->LaunchToolWithProtoBuf(response);
+    }
+}
+
+void MozcResponseParser::ExecuteCallback(const mozc::commands::Output& response, FcitxMozc* fcitx_mozc) const
+{
+    if (!response.has_callback()) {
+        return;
+    }
+
+    if (!response.callback().has_session_command()) {
+        LOG(ERROR) << "callback does not have session_command";
+        return;
+    }
+
+    const commands::SessionCommand &callback_command =
+        response.callback().session_command();
+
+    if (!callback_command.has_type()) {
+        LOG(ERROR) << "callback_command has no type";
+        return;
+    }
+
+    commands::SessionCommand session_command;
+    session_command.set_type(callback_command.type());
+
+    // TODO(nona): Make a function to handle CONVERT_REVERSE.
+    // Used by CONVERT_REVERSE and/or UNDO
+    // This value represents how many characters are selected as a relative
+    // distance of characters. Positive value represents forward text selection
+    // and negative value represents backword text selection.
+    // Note that you should not allow 0x80000000 for |relative_selected_length|
+    // because you cannot safely use |-relative_selected_length| nor
+    // |abs(relative_selected_length)| in this case due to integer overflow.
+    SurroundingTextInfo surrounding_text_info;
+
+    switch (callback_command.type()) {
+        case commands::SessionCommand::UNDO:
+            break;
+        case commands::SessionCommand::CONVERT_REVERSE: {
+
+            if (!GetSurroundingText(fcitx_mozc->GetInstance(),
+                                    &surrounding_text_info)) {
+                return;
+            }
+
+            session_command.set_text(surrounding_text_info.selection_text);
+            break;
+        }
+        default:
+            return;
+    }
+
+    commands::Output new_output;
+    if (!fcitx_mozc->SendCommand(session_command, &new_output)) {
+        LOG(ERROR) << "Callback Command Failed";
+        return;
+    }
+
+    if (callback_command.type() == commands::SessionCommand::CONVERT_REVERSE) {
+        // We need to remove selected text as a first step of reconversion.
+        commands::DeletionRange *range = new_output.mutable_deletion_range();
+        // Use DeletionRange field to remove the selected text.
+        // For forward selection (that is, |relative_selected_length > 0|), the
+        // offset should be a negative value to delete preceding text.
+        // For backward selection (that is, |relative_selected_length < 0|),
+        // IBus and/or some applications seem to expect |offset == 0| somehow.
+        const int32_t offset = surrounding_text_info.relative_selected_length > 0
+            ? -surrounding_text_info.relative_selected_length  // forward selection
+            : 0;                         // backward selection
+        range->set_offset(offset);
+        range->set_length(abs(surrounding_text_info.relative_selected_length));
+    }
+
+    MOZC_VLOG(1) << "New output" << new_output.DebugString();
+
+    ParseResponse(new_output, fcitx_mozc);
+}
+
+bool MozcResponseParser::ParseResponse(const mozc::commands::Output &response,
+                                       FcitxMozc *fcitx_mozc) const {
+    DCHECK(fcitx_mozc);
+    if (!fcitx_mozc) {
+        return false;
+    }
+
+    fcitx_mozc->SetUsage("", "");
+
+    UpdateDeletionRange(response, fcitx_mozc);
+
+    // We should check the mode field first since the response for a
+    // SWITCH_INPUT_MODE request only contains mode and id fields.
+    if (response.has_mode()) {
+        fcitx_mozc->SetCompositionMode(response.mode());
+    }
+
+    if (!response.consumed()) {
+        // The key was not consumed by Mozc.
+        return false;
+    }
+
+    if (response.has_result()) {
+        const mozc::commands::Result &result = response.result();
+        ParseResult(result, fcitx_mozc);
+    }
+
+    // First, determine the cursor position.
+    if (response.has_preedit()) {
+        const mozc::commands::Preedit &preedit = response.preedit();
+        ParsePreedit(preedit, GetCursorPosition(response), fcitx_mozc);
+    }
+
+    // Then show the candidate window.
+    if (response.has_candidate_window()) {
+        const mozc::commands::CandidateWindow &candidates = response.candidate_window();
+        ParseCandidates(candidates, fcitx_mozc);
+    }
+
+    if (response.has_url()) {
+        const std::string &url = response.url();
+        fcitx_mozc->SetUrl(url);
+    }
+    LaunchTool(response, fcitx_mozc);
+    ExecuteCallback(response, fcitx_mozc);
+
+    return true;  // mozc consumed the key.
+}
+
+void MozcResponseParser::set_use_annotation(bool use_annotation) {
+    use_annotation_ = use_annotation;
+}
+
+void MozcResponseParser::ParseResult(const mozc::commands::Result &result,
+                                     FcitxMozc *fcitx_mozc) const {
+    switch (result.type()) {
+    case mozc::commands::Result::NONE: {
+        fcitx_mozc->SetAuxString("No result");  // not a fatal error.
+        break;
+    }
+    case mozc::commands::Result::STRING: {
+        fcitx_mozc->SetResultString(result.value());
+        break;
+    }
+    }
+}
+
+static boolean FcitxMozcPaging(void* arg, boolean prev)
+{
+    FcitxMozc* mozc = static_cast<FcitxMozc*>(arg);
+    return mozc->paging(prev);
+}
+
+void MozcResponseParser::ParseCandidates(
+    const mozc::commands::CandidateWindow &candidates, FcitxMozc *fcitx_mozc) const {
+    const commands::Footer &footer = candidates.footer();
+    bool hasPrev = false;
+    bool hasNext = false;
+    if (candidates.has_footer()) {
+        std::string auxString;
+        if (footer.has_label()) {
+            // TODO(yusukes,mozc-team): label() is not localized. Currently, it's always
+            // written in Japanese (in UTF-8).
+            auxString += footer.label();
+        } else if (footer.has_sub_label()) {
+            // Windows client shows sub_label() only when label() is not specified. We
+            // follow the policy.
+            auxString += footer.sub_label();
+        }
+
+        if (footer.has_index_visible() && footer.index_visible()) {
+            // Max size of candidates is 200 so 128 is sufficient size for the buffer.
+            char index_buf[128] = {0};
+            const int result = snprintf(index_buf,
+                                        sizeof(index_buf) - 1,
+                                        "%s%d/%d",
+                                        (auxString.empty() ? "" : " "),
+                                        candidates.focused_index() + 1,
+                                        candidates.size());
+            DCHECK_GE(result, 0) << "snprintf in ComposeAuxiliaryText failed";
+            auxString += index_buf;
+
+            if (candidates.candidate_size() > 0) {
+
+                if (candidates.candidate(0).index() > 0) {
+                    hasPrev = true;
+                }
+                if (candidates.candidate(candidates.candidate_size() - 1).index() + 1 < candidates.size()) {
+                    hasNext = true;
+                }
+            }
+        }
+        fcitx_mozc->SetAuxString(auxString);
+    }
+
+    FcitxCandidateWordList* candList = FcitxInputStateGetCandidateList(fcitx_mozc->GetInputState());
+    FcitxCandidateWordReset(candList);
+    FcitxCandidateWordSetPageSize(candList, 9);
+    if (candidates.has_direction() &&
+        candidates.direction() == commands::CandidateWindow::HORIZONTAL) {
+        FcitxCandidateWordSetLayoutHint(candList, CLH_Horizontal);
+    } else {
+        FcitxCandidateWordSetLayoutHint(candList, CLH_Vertical);
+    }
+
+    std::map<int32_t, std::pair<std::string, std::string> > usage_map;
+    if (candidates.has_usages()) {
+        const commands::InformationList& usages = candidates.usages();
+        for (size_t i = 0; i < usages.information().size(); ++i) {
+            const commands::Information& information = usages.information(i);
+            if (!information.has_id() || !information.has_description())
+                continue;
+            usage_map[information.id()].first = information.title();
+            usage_map[information.id()].second = information.description();
+        }
+    }
+
+#define EMPTY_STR_CHOOSE "\0\0\0\0\0\0\0\0\0\0"
+    std::vector<char> choose;
+
+    int focused_index = -1;
+    int local_index = -1;
+    if (candidates.has_focused_index()) {
+        focused_index = candidates.focused_index();
+    }
+    for (int i = 0; i < candidates.candidate_size(); ++i) {
+        const commands::CandidateWindow::Candidate& candidate = candidates.candidate(i);
+        const uint32_t index = candidate.index();
+        FcitxMessageType type;
+        if (focused_index != -1 && index == focused_index) {
+            local_index = i;
+            type = MSG_FIRSTCAND;
+        } else {
+            type = MSG_OTHER;
+        }
+        int32_t* id = (int32_t*) fcitx_utils_malloc0(sizeof(int32_t));
+        FcitxCandidateWord candWord;
+        candWord.callback = FcitxMozcGetCandidateWord;
+        candWord.extraType = MSG_OTHER;
+        candWord.strExtra = NULL;
+        candWord.priv = id;
+        candWord.strWord = NULL;
+        candWord.wordType = type;
+        candWord.owner = fcitx_mozc;
+
+        std::string value;
+        if (use_annotation_ &&
+                candidate.has_annotation() &&
+                candidate.annotation().has_prefix()) {
+            value = candidate.annotation().prefix();
+        }
+        value += candidate.value();
+        if (use_annotation_ &&
+                candidate.has_annotation() &&
+                candidate.annotation().has_suffix()) {
+            value += candidate.annotation().suffix();
+        }
+        if (use_annotation_ &&
+                candidate.has_annotation() &&
+                candidate.annotation().has_description()) {
+            // Display descriptions ([HALF][KATAKANA], [GREEK], [Black square], etc).
+            value += CreateDescriptionString(
+                         candidate.annotation().description());
+        }
+
+        if (use_annotation_ && focused_index != -1 && index == focused_index) {
+            local_index = i;
+            type = MSG_FIRSTCAND;
+
+            if (candidate.has_information_id()) {
+                std::map<int32_t, std::pair<std::string, std::string> >::iterator it =
+                    usage_map.find(candidate.information_id());
+                if (it != usage_map.end()) {
+                    fcitx_mozc->SetUsage(it->second.first, it->second.second);
+                }
+                value += CreateDescriptionString(_("Press Ctrl+Alt+H to show usages."));
+            }
+        }
+
+        if (candidate.has_annotation() &&
+            candidate.annotation().has_shortcut()) {
+            choose.push_back(candidate.annotation().shortcut().c_str()[0]);
+        }
+
+        candWord.strWord = strdup(value.c_str());
+
+        if (candidate.has_id()) {
+            const int32_t cid = candidate.id();
+            DCHECK_NE(kBadCandidateId, cid) << "Unexpected id is passed.";
+            *id = cid;
+        } else {
+            // The parent node of the cascading window does not have an id since the
+            // node does not contain a candidate word.
+            *id = kBadCandidateId;
+        }
+        FcitxCandidateWordAppend(candList, &candWord);
+    }
+
+    while (choose.size() < 10) {
+        choose.push_back('\0');
+    }
+
+    if (footer.has_index_visible() && footer.index_visible())
+        FcitxCandidateWordSetChoose(candList, choose.data());
+    else
+        FcitxCandidateWordSetChoose(candList, EMPTY_STR_CHOOSE);
+    FcitxCandidateWordSetFocus(candList, local_index);
+    FcitxCandidateWordSetOverridePaging(candList, hasPrev, hasNext, FcitxMozcPaging, fcitx_mozc, NULL);
+}
+
+static int GetRawCursorPos(const char * str, int upos)
+{
+    unsigned int i;
+    int pos = 0;
+    for (i = 0; i < upos; i++) {
+        pos += fcitx_utf8_char_len(fcitx_utf8_get_nth_char((char*)str, i));
+    }
+    return pos;
+}
+
+
+void MozcResponseParser::ParsePreedit(const mozc::commands::Preedit &preedit,
+                                      uint32_t position,
+                                      FcitxMozc *fcitx_mozc) const {
+    PreeditInfo *info = new PreeditInfo;
+    std::string s;
+
+    for (int i = 0; i < preedit.segment_size(); ++i) {
+        const mozc::commands::Preedit_Segment &segment = preedit.segment(i);
+        const std::string &str = segment.value();
+        FcitxMessageType type = MSG_INPUT;
+
+        switch (segment.annotation()) {
+        case mozc::commands::Preedit_Segment::NONE:
+            type = (FcitxMessageType) (MSG_INPUT | MSG_NOUNDERLINE);
+            break;
+        case mozc::commands::Preedit_Segment::UNDERLINE:
+            type = (FcitxMessageType) (MSG_TIPS);
+            break;
+        case mozc::commands::Preedit_Segment::HIGHLIGHT:
+            type = (FcitxMessageType) (MSG_CODE | MSG_NOUNDERLINE | MSG_HIGHLIGHT);
+            break;
+        }
+        s += str;
+
+        PreeditItem item;
+        item.type = type;
+        item.str = str;
+        info->preedit.push_back(item);
+    }
+    info->cursor_pos = GetRawCursorPos(s.c_str(), position);
+
+    fcitx_mozc->SetPreeditInfo(info);
+}
+
+}  // namespace fcitx
+
+}  // namespace mozc
diff --git a/src/unix/fcitx/mozc_response_parser.h b/src/unix/fcitx/mozc_response_parser.h
new file mode 100755
index 0000000..dd66f00
--- /dev/null
+++ b/src/unix/fcitx/mozc_response_parser.h
@@ -0,0 +1,97 @@
+// Copyright 2010-2012, Google Inc.
+// Copyright 2012~2013, Weng Xuetian <wengxt@gmail.com>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MOZC_UNIX_FCITX_MOZC_RESPONSE_PARSER_H_
+#define MOZC_UNIX_FCITX_MOZC_RESPONSE_PARSER_H_
+
+#include <cstdint>
+#include "base/port.h"
+
+namespace mozc
+{
+namespace commands
+{
+
+class CandidateWindow;
+class Input;
+class Output;
+class Preedit;
+class Result;
+
+}  // namespace commands
+}  // namespace mozc
+
+namespace mozc
+{
+
+namespace fcitx
+{
+
+class FcitxMozc;
+
+// This class parses IPC response from mozc_server (mozc::commands::Output) and
+// updates the FCITX UI.
+class MozcResponseParser
+{
+public:
+    MozcResponseParser();
+    MozcResponseParser(const MozcResponseParser &) = delete;
+    ~MozcResponseParser();
+
+    // Parses a response from Mozc server and sets persed information on fcitx_mozc
+    // object. Returns true if response.consumed() is true. fcitx_mozc must be non
+    // NULL. This function does not take ownership of fcitx_mozc.
+    bool ParseResponse ( const mozc::commands::Output &response,
+                         FcitxMozc *fcitx_mozc ) const;
+
+    // Setter for use_annotation_. If use_annotation_ is true, ParseCandidates()
+    // uses annotation infomation.
+    void set_use_annotation ( bool use_annotation );
+
+private:
+    void UpdateDeletionRange(const mozc::commands::Output& response, FcitxMozc* fcitx_mozc) const;
+    void LaunchTool(const mozc::commands::Output& response, FcitxMozc* fcitx_mozc) const;
+    void ExecuteCallback(const mozc::commands::Output& response, FcitxMozc* fcitx_mozc) const;
+    void ParseResult ( const mozc::commands::Result &result,
+                       FcitxMozc *fcitx_mozc ) const;
+    void ParseCandidates ( const mozc::commands::CandidateWindow &candidates,
+                           FcitxMozc *fcitx_mozc ) const;
+    void ParsePreedit ( const mozc::commands::Preedit &preedit,
+                        uint32_t position,
+                        FcitxMozc *fcitx_mozc ) const;
+
+    bool use_annotation_;
+};
+
+}  // namespace fcitx
+
+}  // namespace mozc
+
+#endif  // MOZC_UNIX_FCITX_MOZC_RESPONSE_PARSER_H_
diff --git a/src/unix/fcitx/po/Messages.sh b/src/unix/fcitx/po/Messages.sh
new file mode 100755
index 0000000..be34171
--- /dev/null
+++ b/src/unix/fcitx/po/Messages.sh
@@ -0,0 +1,33 @@
+#!/bin/sh
+
+BASEDIR="../" # root of translatable sources
+PROJECT="fcitx-mozc" # project name
+BUGADDR="fcitx-dev@googlegroups.com" # MSGID-Bugs
+WDIR="`pwd`" # working dir
+
+echo "Preparing rc files"
+
+echo "Done preparing rc files"
+echo "Extracting messages"
+
+# see above on sorting
+
+find "${BASEDIR}" -name '*.cc' -o -name '*.h' -o -name '*.c' | sort > "${WDIR}/infiles.list"
+
+xgettext --from-code=UTF-8 -k_ -kN_ --msgid-bugs-address="${BUGADDR}" --files-from=infiles.list \
+    -D "${BASEDIR}" -D "${WDIR}" -o "${PROJECT}.pot" || \
+    { echo "error while calling xgettext. aborting."; exit 1; }
+echo "Done extracting messages"
+
+echo "Merging translations"
+catalogs=`find . -name '*.po'`
+for cat in $catalogs; do
+    echo "$cat"
+    msgmerge -o "$cat.new" "$cat" "${WDIR}/${PROJECT}.pot"
+    mv "$cat.new" "$cat"
+done
+
+echo "Done merging translations"
+echo "Cleaning up"
+rm "${WDIR}/infiles.list"
+echo "Done"
diff --git a/src/unix/fcitx/po/ca.po b/src/unix/fcitx/po/ca.po
new file mode 100644
index 0000000..ef743e2
--- /dev/null
+++ b/src/unix/fcitx/po/ca.po
@@ -0,0 +1,80 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the PACKAGE package.
+#
+# Translators:
+# Robert Antoni Buj Gelonch <rbuj@fedoraproject.org>, 2017
+# Walter Garcia-Fontes <walter.garcia@upf.edu>, 2017
+msgid ""
+msgstr ""
+"Project-Id-Version: fcitx\n"
+"Report-Msgid-Bugs-To: fcitx-dev@googlegroups.com\n"
+"POT-Creation-Date: 2020-11-11 00:03-0800\n"
+"PO-Revision-Date: 2020-11-10 08:03+0000\n"
+"Last-Translator: csslayer <wengxt@gmail.com>\n"
+"Language-Team: Catalan (http://www.transifex.com/fcitx/fcitx/language/ca/)\n"
+"Language: ca\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+
+#: ../eim.cc:187
+msgid "Press Escape to go back"
+msgstr "Premeu Esc per tornar"
+
+#: ../fcitx_mozc.cc:65
+msgid "Direct"
+msgstr "Directe"
+
+#: ../fcitx_mozc.cc:70
+msgid "Hiragana"
+msgstr "Hiragana"
+
+#: ../fcitx_mozc.cc:75
+msgid "Full Katakana"
+msgstr "Katakana complet"
+
+#: ../fcitx_mozc.cc:80
+msgid "Half ASCII"
+msgstr "ASCII mig"
+
+#: ../fcitx_mozc.cc:85
+msgid "Full ASCII"
+msgstr "ASCII complet"
+
+#: ../fcitx_mozc.cc:90
+msgid "Half Katakana"
+msgstr "Mig katakana"
+
+#: ../fcitx_mozc.cc:406 ../fcitx_mozc.cc:407 ../fcitx_mozc.cc:469
+msgid "Composition Mode"
+msgstr "Mode de composició"
+
+#: ../fcitx_mozc.cc:417 ../fcitx_mozc.cc:418
+msgid "Tool"
+msgstr "Eina"
+
+#: ../fcitx_mozc.cc:482
+msgid "Mozc Tool"
+msgstr "Eina mozc"
+
+#: ../fcitx_mozc.cc:488
+msgid "Configuration Tool"
+msgstr "Eina de configuració"
+
+#: ../fcitx_mozc.cc:489
+msgid "Dictionary Tool"
+msgstr "Eina de diccionari"
+
+#: ../fcitx_mozc.cc:490
+msgid "Add Word"
+msgstr "Afegeix una paraula"
+
+#: ../fcitx_mozc.cc:491
+msgid "About Mozc"
+msgstr "Quant al mozc"
+
+#: ../mozc_response_parser.cc:365
+msgid "Press Ctrl+Alt+H to show usages."
+msgstr "Premeu Ctrl+Alt+H per mostrar els usos."
diff --git a/src/unix/fcitx/po/da.po b/src/unix/fcitx/po/da.po
new file mode 100644
index 0000000..e67d77c
--- /dev/null
+++ b/src/unix/fcitx/po/da.po
@@ -0,0 +1,80 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the PACKAGE package.
+#
+# Translators:
+# scootergrisen, 2017
+# scootergrisen, 2017
+msgid ""
+msgstr ""
+"Project-Id-Version: fcitx\n"
+"Report-Msgid-Bugs-To: fcitx-dev@googlegroups.com\n"
+"POT-Creation-Date: 2020-11-11 00:03-0800\n"
+"PO-Revision-Date: 2020-11-10 08:03+0000\n"
+"Last-Translator: csslayer <wengxt@gmail.com>\n"
+"Language-Team: Danish (http://www.transifex.com/fcitx/fcitx/language/da/)\n"
+"Language: da\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+
+#: ../eim.cc:187
+msgid "Press Escape to go back"
+msgstr "Tryk på Escape for at gå tilbage"
+
+#: ../fcitx_mozc.cc:65
+msgid "Direct"
+msgstr "Direkte"
+
+#: ../fcitx_mozc.cc:70
+msgid "Hiragana"
+msgstr "Hiragana"
+
+#: ../fcitx_mozc.cc:75
+msgid "Full Katakana"
+msgstr "Fuld Katakana"
+
+#: ../fcitx_mozc.cc:80
+msgid "Half ASCII"
+msgstr "Halv ASCII"
+
+#: ../fcitx_mozc.cc:85
+msgid "Full ASCII"
+msgstr "Fuld ASCII"
+
+#: ../fcitx_mozc.cc:90
+msgid "Half Katakana"
+msgstr "Halv Katakana"
+
+#: ../fcitx_mozc.cc:406 ../fcitx_mozc.cc:407 ../fcitx_mozc.cc:469
+msgid "Composition Mode"
+msgstr "Kompositionstilstand"
+
+#: ../fcitx_mozc.cc:417 ../fcitx_mozc.cc:418
+msgid "Tool"
+msgstr "Værktøj"
+
+#: ../fcitx_mozc.cc:482
+msgid "Mozc Tool"
+msgstr "Mozc-værktøj"
+
+#: ../fcitx_mozc.cc:488
+msgid "Configuration Tool"
+msgstr "Konfigurationsværktøj"
+
+#: ../fcitx_mozc.cc:489
+msgid "Dictionary Tool"
+msgstr "Ordbogsværktøj"
+
+#: ../fcitx_mozc.cc:490
+msgid "Add Word"
+msgstr "Tilføj ord"
+
+#: ../fcitx_mozc.cc:491
+msgid "About Mozc"
+msgstr "Om Mozc"
+
+#: ../mozc_response_parser.cc:365
+msgid "Press Ctrl+Alt+H to show usages."
+msgstr "Tryk på Ctrl+Alt+H for at vise anvendelser."
diff --git a/src/unix/fcitx/po/de.po b/src/unix/fcitx/po/de.po
new file mode 100644
index 0000000..c1c17b1
--- /dev/null
+++ b/src/unix/fcitx/po/de.po
@@ -0,0 +1,86 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the PACKAGE package.
+#
+# Translators:
+# csslayer <wengxt@gmail.com>, 2013
+# Lucius Annaeus Seneca, 2013
+# Lucius Annaeus Seneca, 2013
+# mar well <m.wellendorf@gmx.de>, 2013
+# mar well <m.wellendorf@gmx.de>, 2013
+# Seneca, 2013
+# csslayer <wengxt@gmail.com>, 2013
+# csslayer <wengxt@gmail.com>, 2013
+msgid ""
+msgstr ""
+"Project-Id-Version: fcitx\n"
+"Report-Msgid-Bugs-To: fcitx-dev@googlegroups.com\n"
+"POT-Creation-Date: 2020-11-11 00:03-0800\n"
+"PO-Revision-Date: 2020-11-10 08:03+0000\n"
+"Last-Translator: csslayer <wengxt@gmail.com>\n"
+"Language-Team: German (http://www.transifex.com/fcitx/fcitx/language/de/)\n"
+"Language: de\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+
+#: ../eim.cc:187
+msgid "Press Escape to go back"
+msgstr "ESC drücken um zurück zu kehren"
+
+#: ../fcitx_mozc.cc:65
+msgid "Direct"
+msgstr "Direkt"
+
+#: ../fcitx_mozc.cc:70
+msgid "Hiragana"
+msgstr "Hiragana"
+
+#: ../fcitx_mozc.cc:75
+msgid "Full Katakana"
+msgstr "Normalbreite Katakana"
+
+#: ../fcitx_mozc.cc:80
+msgid "Half ASCII"
+msgstr "6-Bit ASCII (Half ASCII)"
+
+#: ../fcitx_mozc.cc:85
+msgid "Full ASCII"
+msgstr "7-Bit ASCII (Full ASCII)"
+
+#: ../fcitx_mozc.cc:90
+msgid "Half Katakana"
+msgstr "Halbbreite Katakana"
+
+#: ../fcitx_mozc.cc:406 ../fcitx_mozc.cc:407 ../fcitx_mozc.cc:469
+msgid "Composition Mode"
+msgstr "Kompositionsmodus"
+
+#: ../fcitx_mozc.cc:417 ../fcitx_mozc.cc:418
+msgid "Tool"
+msgstr "Werkzeug"
+
+#: ../fcitx_mozc.cc:482
+msgid "Mozc Tool"
+msgstr "Mozc Werkzeug"
+
+#: ../fcitx_mozc.cc:488
+msgid "Configuration Tool"
+msgstr "Konfigurationswerkzeug"
+
+#: ../fcitx_mozc.cc:489
+msgid "Dictionary Tool"
+msgstr "Wörterbuchwerkzeug"
+
+#: ../fcitx_mozc.cc:490
+msgid "Add Word"
+msgstr "Wort hinzufügen"
+
+#: ../fcitx_mozc.cc:491
+msgid "About Mozc"
+msgstr "Über Mozc"
+
+#: ../mozc_response_parser.cc:365
+msgid "Press Ctrl+Alt+H to show usages."
+msgstr "Ctrl+Alt+H um die Hilfe anzuzeigen"
diff --git a/src/unix/fcitx/po/fcitx-mozc.pot b/src/unix/fcitx/po/fcitx-mozc.pot
new file mode 100644
index 0000000..56f6c24
--- /dev/null
+++ b/src/unix/fcitx/po/fcitx-mozc.pot
@@ -0,0 +1,78 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the PACKAGE package.
+# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
+#
+#, fuzzy
+msgid ""
+msgstr ""
+"Project-Id-Version: PACKAGE VERSION\n"
+"Report-Msgid-Bugs-To: fcitx-dev@googlegroups.com\n"
+"POT-Creation-Date: 2020-11-11 00:03-0800\n"
+"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
+"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
+"Language-Team: LANGUAGE <LL@li.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=CHARSET\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#: ../eim.cc:187
+msgid "Press Escape to go back"
+msgstr ""
+
+#: ../fcitx_mozc.cc:65
+msgid "Direct"
+msgstr ""
+
+#: ../fcitx_mozc.cc:70
+msgid "Hiragana"
+msgstr ""
+
+#: ../fcitx_mozc.cc:75
+msgid "Full Katakana"
+msgstr ""
+
+#: ../fcitx_mozc.cc:80
+msgid "Half ASCII"
+msgstr ""
+
+#: ../fcitx_mozc.cc:85
+msgid "Full ASCII"
+msgstr ""
+
+#: ../fcitx_mozc.cc:90
+msgid "Half Katakana"
+msgstr ""
+
+#: ../fcitx_mozc.cc:406 ../fcitx_mozc.cc:407 ../fcitx_mozc.cc:469
+msgid "Composition Mode"
+msgstr ""
+
+#: ../fcitx_mozc.cc:417 ../fcitx_mozc.cc:418
+msgid "Tool"
+msgstr ""
+
+#: ../fcitx_mozc.cc:482
+msgid "Mozc Tool"
+msgstr ""
+
+#: ../fcitx_mozc.cc:488
+msgid "Configuration Tool"
+msgstr ""
+
+#: ../fcitx_mozc.cc:489
+msgid "Dictionary Tool"
+msgstr ""
+
+#: ../fcitx_mozc.cc:490
+msgid "Add Word"
+msgstr ""
+
+#: ../fcitx_mozc.cc:491
+msgid "About Mozc"
+msgstr ""
+
+#: ../mozc_response_parser.cc:365
+msgid "Press Ctrl+Alt+H to show usages."
+msgstr ""
diff --git a/src/unix/fcitx/po/ja.po b/src/unix/fcitx/po/ja.po
new file mode 100644
index 0000000..6de66d8
--- /dev/null
+++ b/src/unix/fcitx/po/ja.po
@@ -0,0 +1,87 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the PACKAGE package.
+#
+# Translators:
+# しろう, 2013
+# あわしろいくや <ikunya@gmail.com>, 2013
+# csslayer <wengxt@gmail.com>, 2012-2013
+# あわしろいくや <ikunya@gmail.com>, 2013
+# あわしろいくや <ikunya@gmail.com>, 2012-2013
+# shirou - しろう <shirou.faw@gmail.com>, 2013
+# csslayer <wengxt@gmail.com>, 2013
+# csslayer <wengxt@gmail.com>, 2012
+# csslayer <wengxt@gmail.com>, 2012-2013
+msgid ""
+msgstr ""
+"Project-Id-Version: fcitx\n"
+"Report-Msgid-Bugs-To: fcitx-dev@googlegroups.com\n"
+"POT-Creation-Date: 2020-11-11 00:03-0800\n"
+"PO-Revision-Date: 2020-11-10 08:03+0000\n"
+"Last-Translator: csslayer <wengxt@gmail.com>\n"
+"Language-Team: Japanese (http://www.transifex.com/fcitx/fcitx/language/ja/)\n"
+"Language: ja\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=1; plural=0;\n"
+
+#: ../eim.cc:187
+msgid "Press Escape to go back"
+msgstr "Escキーを押して戻る"
+
+#: ../fcitx_mozc.cc:65
+msgid "Direct"
+msgstr "直接入力"
+
+#: ../fcitx_mozc.cc:70
+msgid "Hiragana"
+msgstr "ひらがな"
+
+#: ../fcitx_mozc.cc:75
+msgid "Full Katakana"
+msgstr "全角カタカナ"
+
+#: ../fcitx_mozc.cc:80
+msgid "Half ASCII"
+msgstr "半角英数"
+
+#: ../fcitx_mozc.cc:85
+msgid "Full ASCII"
+msgstr "全角英数"
+
+#: ../fcitx_mozc.cc:90
+msgid "Half Katakana"
+msgstr "半角カタカナ"
+
+#: ../fcitx_mozc.cc:406 ../fcitx_mozc.cc:407 ../fcitx_mozc.cc:469
+msgid "Composition Mode"
+msgstr "変換モード"
+
+#: ../fcitx_mozc.cc:417 ../fcitx_mozc.cc:418
+msgid "Tool"
+msgstr "ツール"
+
+#: ../fcitx_mozc.cc:482
+msgid "Mozc Tool"
+msgstr "Mozc ツール"
+
+#: ../fcitx_mozc.cc:488
+msgid "Configuration Tool"
+msgstr "設定ツール"
+
+#: ../fcitx_mozc.cc:489
+msgid "Dictionary Tool"
+msgstr "辞書ツール"
+
+#: ../fcitx_mozc.cc:490
+msgid "Add Word"
+msgstr "単語登録"
+
+#: ../fcitx_mozc.cc:491
+msgid "About Mozc"
+msgstr "Mozc について"
+
+#: ../mozc_response_parser.cc:365
+msgid "Press Ctrl+Alt+H to show usages."
+msgstr "Ctrl+Alt+H キーを押して用例を表示"
diff --git a/src/unix/fcitx/po/ko.po b/src/unix/fcitx/po/ko.po
new file mode 100644
index 0000000..8ff2e9b
--- /dev/null
+++ b/src/unix/fcitx/po/ko.po
@@ -0,0 +1,82 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the PACKAGE package.
+#
+# Translators:
+# Bon Keun Seo <scobyseo@gmail.com>, 2017
+# Junghee Lee <daemul72@gmail.com>, 2020
+# Junghee Lee <daemul72@gmail.com>, 2022
+# Junghee Lee <daemul72@gmail.com>, 2020,2022
+msgid ""
+msgstr ""
+"Project-Id-Version: fcitx\n"
+"Report-Msgid-Bugs-To: fcitx-dev@googlegroups.com\n"
+"POT-Creation-Date: 2022-04-10 20:28+0000\n"
+"PO-Revision-Date: 2012-03-06 06:51+0000\n"
+"Last-Translator: Junghee Lee <daemul72@gmail.com>, 2022\n"
+"Language-Team: Korean (http://www.transifex.com/fcitx/fcitx/language/ko/)\n"
+"Language: ko\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=1; plural=0;\n"
+
+#: ../eim.cc:187
+msgid "Press Escape to go back"
+msgstr "돌아가려면 Esc 키를 눌러 취소합니다"
+
+#: ../fcitx_mozc.cc:68
+msgid "Direct"
+msgstr "직접입력"
+
+#: ../fcitx_mozc.cc:73
+msgid "Hiragana"
+msgstr "히라가나"
+
+#: ../fcitx_mozc.cc:78
+msgid "Full Katakana"
+msgstr "전각 가타카나"
+
+#: ../fcitx_mozc.cc:83
+msgid "Half ASCII"
+msgstr "반각 아스키"
+
+#: ../fcitx_mozc.cc:88
+msgid "Full ASCII"
+msgstr "전각 아스키"
+
+#: ../fcitx_mozc.cc:93
+msgid "Half Katakana"
+msgstr "반각 가타카나"
+
+#: ../fcitx_mozc.cc:409 ../fcitx_mozc.cc:410 ../fcitx_mozc.cc:472
+msgid "Composition Mode"
+msgstr "조합 모드"
+
+#: ../fcitx_mozc.cc:420 ../fcitx_mozc.cc:421
+msgid "Tool"
+msgstr "도구"
+
+#: ../fcitx_mozc.cc:485
+msgid "Mozc Tool"
+msgstr "Mozc 도구"
+
+#: ../fcitx_mozc.cc:491
+msgid "Configuration Tool"
+msgstr "구성 도구"
+
+#: ../fcitx_mozc.cc:492
+msgid "Dictionary Tool"
+msgstr "사전 도구"
+
+#: ../fcitx_mozc.cc:493
+msgid "Add Word"
+msgstr "단어 추가"
+
+#: ../fcitx_mozc.cc:494
+msgid "About Mozc"
+msgstr "Mozc에 대해"
+
+#: ../mozc_response_parser.cc:365
+msgid "Press Ctrl+Alt+H to show usages."
+msgstr "사용법을 보려면 Ctrl+Alt+H를 누릅니다."
diff --git a/src/unix/fcitx/po/ru.po b/src/unix/fcitx/po/ru.po
new file mode 100644
index 0000000..20bf325
--- /dev/null
+++ b/src/unix/fcitx/po/ru.po
@@ -0,0 +1,83 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the PACKAGE package.
+#
+# Translators:
+# Dmitry <dmitrydmitry761@gmail.com>, 2022,2024
+# TotalCaesar659 <x24cm5b8c54q6szxw@yandex.ru>, 2016
+# TotalCaesar659 <x24cm5b8c54q6szxw@yandex.ru>, 2016
+msgid ""
+msgstr ""
+"Project-Id-Version: fcitx\n"
+"Report-Msgid-Bugs-To: fcitx-dev@googlegroups.com\n"
+"POT-Creation-Date: 2024-04-17 20:27+0000\n"
+"PO-Revision-Date: 2012-03-06 06:51+0000\n"
+"Last-Translator: Dmitry <dmitrydmitry761@gmail.com>, 2022,2024\n"
+"Language-Team: Russian (http://app.transifex.com/fcitx/fcitx/language/ru/)\n"
+"Language: ru\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
+"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
+"(n%100>=11 && n%100<=14)? 2 : 3);\n"
+
+#: ../eim.cc:191
+msgid "Press Escape to go back"
+msgstr "Нажмите  для перехода назад"
+
+#: ../fcitx_mozc.cc:69
+msgid "Direct"
+msgstr "Прямой"
+
+#: ../fcitx_mozc.cc:74
+msgid "Hiragana"
+msgstr "Хирагана"
+
+#: ../fcitx_mozc.cc:79
+msgid "Full Katakana"
+msgstr "Полная катакана"
+
+#: ../fcitx_mozc.cc:84
+msgid "Half ASCII"
+msgstr "Полуширинная ASCII"
+
+#: ../fcitx_mozc.cc:89
+msgid "Full ASCII"
+msgstr "Полноширинная ASCII"
+
+#: ../fcitx_mozc.cc:94
+msgid "Half Katakana"
+msgstr "Полуширинная Катакана"
+
+#: ../fcitx_mozc.cc:410 ../fcitx_mozc.cc:411 ../fcitx_mozc.cc:473
+msgid "Composition Mode"
+msgstr "Режим композиции"
+
+#: ../fcitx_mozc.cc:421 ../fcitx_mozc.cc:422
+msgid "Tool"
+msgstr "Инструмент"
+
+#: ../fcitx_mozc.cc:486
+msgid "Mozc Tool"
+msgstr "Инструмент Mozc"
+
+#: ../fcitx_mozc.cc:492
+msgid "Configuration Tool"
+msgstr "Инструмент настройки"
+
+#: ../fcitx_mozc.cc:493
+msgid "Dictionary Tool"
+msgstr "Инструмент словаря"
+
+#: ../fcitx_mozc.cc:494
+msgid "Add Word"
+msgstr "Добавить слово"
+
+#: ../fcitx_mozc.cc:495
+msgid "About Mozc"
+msgstr "О Mozc"
+
+#: ../mozc_response_parser.cc:366
+msgid "Press Ctrl+Alt+H to show usages."
+msgstr "Нажмите Ctrl+Alt+H, чтобы показать использование."
diff --git a/src/unix/fcitx/po/zh_CN.po b/src/unix/fcitx/po/zh_CN.po
new file mode 100644
index 0000000..799ee99
--- /dev/null
+++ b/src/unix/fcitx/po/zh_CN.po
@@ -0,0 +1,85 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the PACKAGE package.
+#
+# Translators:
+# csslayer <wengxt@gmail.com>, 2012-2013
+# csslayer <wengxt@gmail.com>, 2013
+# csslayer <wengxt@gmail.com>, 2012
+# wwj402 <wwj402@gmail.com>, 2013
+# wwj402 <wwj402@gmail.com>, 2013
+# csslayer <wengxt@gmail.com>, 2012-2013
+msgid ""
+msgstr ""
+"Project-Id-Version: fcitx\n"
+"Report-Msgid-Bugs-To: fcitx-dev@googlegroups.com\n"
+"POT-Creation-Date: 2020-11-11 00:03-0800\n"
+"PO-Revision-Date: 2020-11-10 08:03+0000\n"
+"Last-Translator: csslayer <wengxt@gmail.com>\n"
+"Language-Team: Chinese (China) (http://www.transifex.com/fcitx/fcitx/"
+"language/zh_CN/)\n"
+"Language: zh_CN\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=1; plural=0;\n"
+
+#: ../eim.cc:187
+msgid "Press Escape to go back"
+msgstr "按下 Escape 返回"
+
+#: ../fcitx_mozc.cc:65
+msgid "Direct"
+msgstr "直接键盘输入"
+
+#: ../fcitx_mozc.cc:70
+msgid "Hiragana"
+msgstr "平假名"
+
+#: ../fcitx_mozc.cc:75
+msgid "Full Katakana"
+msgstr "全角片假名"
+
+#: ../fcitx_mozc.cc:80
+msgid "Half ASCII"
+msgstr "半角 ASCII"
+
+#: ../fcitx_mozc.cc:85
+msgid "Full ASCII"
+msgstr "全角 ASCII"
+
+#: ../fcitx_mozc.cc:90
+msgid "Half Katakana"
+msgstr "半角片假名"
+
+#: ../fcitx_mozc.cc:406 ../fcitx_mozc.cc:407 ../fcitx_mozc.cc:469
+msgid "Composition Mode"
+msgstr "编辑模式"
+
+#: ../fcitx_mozc.cc:417 ../fcitx_mozc.cc:418
+msgid "Tool"
+msgstr "工具"
+
+#: ../fcitx_mozc.cc:482
+msgid "Mozc Tool"
+msgstr "Mozc 工具"
+
+#: ../fcitx_mozc.cc:488
+msgid "Configuration Tool"
+msgstr "配置工具"
+
+#: ../fcitx_mozc.cc:489
+msgid "Dictionary Tool"
+msgstr "词典工具"
+
+#: ../fcitx_mozc.cc:490
+msgid "Add Word"
+msgstr "添加单词"
+
+#: ../fcitx_mozc.cc:491
+msgid "About Mozc"
+msgstr "关于 Mozc"
+
+#: ../mozc_response_parser.cc:365
+msgid "Press Ctrl+Alt+H to show usages."
+msgstr "按下 Ctrl+Alt+H 显示用法。"
diff --git a/src/unix/fcitx/po/zh_TW.po b/src/unix/fcitx/po/zh_TW.po
new file mode 100644
index 0000000..2c83dfe
--- /dev/null
+++ b/src/unix/fcitx/po/zh_TW.po
@@ -0,0 +1,84 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the PACKAGE package.
+#
+# Translators:
+# Alisha <alisha.4m@gmail.com>, 2012
+# csslayer <wengxt@gmail.com>, 2012-2013
+# csslayer <wengxt@gmail.com>, 2013
+# csslayer <wengxt@gmail.com>, 2012
+# csslayer <wengxt@gmail.com>, 2012-2013
+msgid ""
+msgstr ""
+"Project-Id-Version: fcitx\n"
+"Report-Msgid-Bugs-To: fcitx-dev@googlegroups.com\n"
+"POT-Creation-Date: 2020-11-11 00:03-0800\n"
+"PO-Revision-Date: 2020-11-10 08:03+0000\n"
+"Last-Translator: csslayer <wengxt@gmail.com>\n"
+"Language-Team: Chinese (Taiwan) (http://www.transifex.com/fcitx/fcitx/"
+"language/zh_TW/)\n"
+"Language: zh_TW\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=1; plural=0;\n"
+
+#: ../eim.cc:187
+msgid "Press Escape to go back"
+msgstr "按下 Escape 返回"
+
+#: ../fcitx_mozc.cc:65
+msgid "Direct"
+msgstr "直接鍵盤輸入"
+
+#: ../fcitx_mozc.cc:70
+msgid "Hiragana"
+msgstr "平假名"
+
+#: ../fcitx_mozc.cc:75
+msgid "Full Katakana"
+msgstr "全形片假名"
+
+#: ../fcitx_mozc.cc:80
+msgid "Half ASCII"
+msgstr "半形 ASCII"
+
+#: ../fcitx_mozc.cc:85
+msgid "Full ASCII"
+msgstr "全形 ASCII"
+
+#: ../fcitx_mozc.cc:90
+msgid "Half Katakana"
+msgstr "半形片假名"
+
+#: ../fcitx_mozc.cc:406 ../fcitx_mozc.cc:407 ../fcitx_mozc.cc:469
+msgid "Composition Mode"
+msgstr "編輯模式"
+
+#: ../fcitx_mozc.cc:417 ../fcitx_mozc.cc:418
+msgid "Tool"
+msgstr "工具"
+
+#: ../fcitx_mozc.cc:482
+msgid "Mozc Tool"
+msgstr "Mozc 工具"
+
+#: ../fcitx_mozc.cc:488
+msgid "Configuration Tool"
+msgstr "設定工具"
+
+#: ../fcitx_mozc.cc:489
+msgid "Dictionary Tool"
+msgstr "字典工具"
+
+#: ../fcitx_mozc.cc:490
+msgid "Add Word"
+msgstr "添加單詞"
+
+#: ../fcitx_mozc.cc:491
+msgid "About Mozc"
+msgstr "關於 Mozc"
+
+#: ../mozc_response_parser.cc:365
+msgid "Press Ctrl+Alt+H to show usages."
+msgstr "按下 Ctrl+Alt+H 顯示用法。"
diff --git a/src/unix/fcitx/surrounding_text_util.cc b/src/unix/fcitx/surrounding_text_util.cc
new file mode 100644
index 0000000..4cfbd85
--- /dev/null
+++ b/src/unix/fcitx/surrounding_text_util.cc
@@ -0,0 +1,244 @@
+// Copyright 2010-2013, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "unix/fcitx/surrounding_text_util.h"
+
+#include <limits>
+#include <string>
+#include <fcitx/instance.h>
+#include <fcitx/module/clipboard/fcitx-clipboard.h>
+
+#ifdef InvokeFunction
+#undef InvokeFunction
+#endif
+
+#include "absl/log/check.h"
+#include "base/port.h"
+#include "base/vlog.h"
+#include "base/util.h"
+
+namespace mozc {
+namespace fcitx {
+
+bool SurroundingTextUtil::GetSafeDelta(unsigned int from, unsigned int to, int32_t *delta) {
+  DCHECK(delta);
+
+  static_assert(sizeof(int64_t) >= sizeof(unsigned int),
+                "int64 must be sufficient to store a unsigned int value.");
+  static_assert(sizeof(int64_t) == sizeof(llabs(0)),
+                "|llabs(0)| must returns a 64-bit integer.");
+  const int64_t kInt32AbsMax =
+      llabs(static_cast<int64_t>(std::numeric_limits<int32_t>::max()));
+  const int64_t kInt32AbsMin =
+      llabs(static_cast<int64_t>(std::numeric_limits<int32_t>::min()));
+  const int64_t kInt32SafeAbsMax =
+      std::min(kInt32AbsMax, kInt32AbsMin);
+
+  const int64_t diff = static_cast<int64_t>(from) - static_cast<int64_t>(to);
+  if (llabs(diff) > kInt32SafeAbsMax) {
+    return false;
+  }
+
+  *delta = static_cast<int32_t>(diff);
+  return true;
+}
+
+namespace {
+
+// Moves |iter| with |skip_count| characters.
+// Returns false if |iter| reaches to the end before skipping
+// |skip_count| characters.
+bool Skip(ConstChar32Iterator *iter, size_t skip_count) {
+  for (size_t i = 0; i < skip_count; ++i) {
+    if (iter->Done()) {
+      return false;
+    }
+    iter->Next();
+  }
+  return true;
+}
+
+// Returns true if |prefix_iter| is the prefix of |iter|.
+// Returns false if |prefix_iter| is an empty sequence.
+// Otherwise returns false.
+// This function receives ConstChar32Iterator as pointer because
+// ConstChar32Iterator is defined as non-copyable.
+bool StartsWith(ConstChar32Iterator *iter,
+                ConstChar32Iterator *prefix_iter) {
+  if (iter->Done() || prefix_iter->Done()) {
+    return false;
+  }
+
+  while (true) {
+    if (iter->Get() != prefix_iter->Get()) {
+      return false;
+    }
+    prefix_iter->Next();
+    if (prefix_iter->Done()) {
+      return true;
+    }
+    iter->Next();
+    if (iter->Done()) {
+      return false;
+    }
+  }
+}
+
+
+// Returns true if |surrounding_text| contains |selected_text|
+// from |cursor_pos| to |*anchor_pos|.
+// Otherwise returns false.
+bool SearchAnchorPosForward(
+    const std::string &surrounding_text,
+    const std::string &selected_text,
+    size_t selected_chars_len,
+    unsigned int cursor_pos,
+    unsigned int *anchor_pos) {
+
+  ConstChar32Iterator iter(surrounding_text);
+  // Move |iter| to cursor pos.
+  if (!Skip(&iter, cursor_pos)) {
+    return false;
+  }
+
+  ConstChar32Iterator sel_iter(selected_text);
+  if (!StartsWith(&iter, &sel_iter)) {
+    return false;
+  }
+  *anchor_pos = cursor_pos + selected_chars_len;
+  return true;
+}
+
+// Returns true if |surrounding_text| contains |selected_text|
+// from |*anchor_pos| to |cursor_pos|.
+// Otherwise returns false.
+bool SearchAnchorPosBackward(
+    const std::string &surrounding_text,
+    const std::string &selected_text,
+    size_t selected_chars_len,
+    unsigned int cursor_pos,
+    unsigned int *anchor_pos) {
+  if (cursor_pos < selected_chars_len) {
+    return false;
+  }
+
+  ConstChar32Iterator iter(surrounding_text);
+  // Skip |iter| to (potential) anchor pos.
+  const unsigned int skip_count = cursor_pos - selected_chars_len;
+  DCHECK_LE(skip_count, cursor_pos);
+  if (!Skip(&iter, skip_count)) {
+    return false;
+  }
+
+  ConstChar32Iterator sel_iter(selected_text);
+  if (!StartsWith(&iter, &sel_iter)) {
+    return false;
+  }
+  *anchor_pos = cursor_pos - selected_chars_len;
+  return true;
+}
+
+}  // namespace
+
+bool SurroundingTextUtil::GetAnchorPosFromSelection(
+    const std::string &surrounding_text,
+    const std::string &selected_text,
+    unsigned int cursor_pos,
+    unsigned int *anchor_pos) {
+  DCHECK(anchor_pos);
+
+  if (surrounding_text.empty()) {
+    return false;
+  }
+
+  if (selected_text.empty()) {
+    return false;
+  }
+
+  const size_t selected_chars_len = Util::CharsLen(selected_text);
+
+  if (SearchAnchorPosForward(surrounding_text, selected_text,
+                             selected_chars_len,
+                             cursor_pos, anchor_pos)) {
+    return true;
+  }
+
+  return SearchAnchorPosBackward(surrounding_text, selected_text,
+                                 selected_chars_len,
+                                 cursor_pos, anchor_pos);
+}
+
+bool GetSurroundingText(FcitxInstance* instance,
+                        SurroundingTextInfo *info) {
+    FcitxInputContext* ic = FcitxInstanceGetCurrentIC(instance);
+    if (!ic || !(ic->contextCaps & CAPACITY_SURROUNDING_TEXT)) {
+        return false;
+    }
+
+    unsigned int cursor_pos = 0;
+    unsigned int anchor_pos = 0;
+    char* str = NULL;
+
+    if (!FcitxInstanceGetSurroundingText(instance, ic, &str, &cursor_pos, &anchor_pos)) {
+        return false;
+    }
+
+    const std::string surrounding_text(str);
+    free(str);
+
+    if (cursor_pos == anchor_pos) {
+        const char* primary = NULL;
+
+        if ((primary = FcitxClipboardGetPrimarySelection(instance, NULL)) != NULL) {
+            unsigned int new_anchor_pos = 0;
+            const std::string primary_text(primary);
+            if (SurroundingTextUtil::GetAnchorPosFromSelection(
+                surrounding_text, primary_text,
+                cursor_pos, &new_anchor_pos)) {
+                anchor_pos = new_anchor_pos;
+            }
+        }
+    }
+
+    if (!SurroundingTextUtil::GetSafeDelta(cursor_pos, anchor_pos,
+                                           &info->relative_selected_length)) {
+        LOG(ERROR) << "Too long text selection.";
+        return false;
+    }
+
+    const size_t selection_start = std::min(cursor_pos, anchor_pos);
+    const size_t selection_length = std::abs(info->relative_selected_length);
+    info->preceding_text = std::string(Util::Utf8SubString(surrounding_text, 0, selection_start));
+    info->selection_text = std::string(Util::Utf8SubString(surrounding_text, selection_start, selection_length));
+    info->following_text = std::string(Util::Utf8SubString(surrounding_text, selection_start + selection_length));
+    return true;
+}
+
+}  // namespace fcitx
+}  // namespace mozc
diff --git a/src/unix/fcitx/surrounding_text_util.h b/src/unix/fcitx/surrounding_text_util.h
new file mode 100644
index 0000000..ce54291
--- /dev/null
+++ b/src/unix/fcitx/surrounding_text_util.h
@@ -0,0 +1,89 @@
+// Copyright 2010-2013, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MOZC_UNIX_FCITX_SURROUNDING_TEXT_URIL_H_
+#define MOZC_UNIX_FCITX_SURROUNDING_TEXT_URIL_H_
+
+#include <cstdint>
+#include <string>
+#include <fcitx/instance.h>
+
+#include "base/port.h"
+
+namespace mozc {
+namespace fcitx {
+
+struct SurroundingTextInfo {
+    SurroundingTextInfo()
+        : relative_selected_length(0) {}
+
+    int32_t relative_selected_length;
+    std::string preceding_text;
+    std::string selection_text;
+    std::string following_text;
+};
+
+class SurroundingTextUtil {
+ public:
+  SurroundingTextUtil() = delete;
+  SurroundingTextUtil(const SurroundingTextUtil &) = delete;
+  SurroundingTextUtil &operator=(const SurroundingTextUtil &) = delete;
+
+  // Calculates |from| - |to| and stores the result into |delta| with
+  // checking integer overflow.
+  // Returns true when neither |abs(delta)| nor |-delta| does not cause
+  // integer overflow, that is, |delta| is in a safe range.
+  // Returns false otherwise.
+  static bool GetSafeDelta(unsigned int from, unsigned int to, int32_t *delta);
+
+  // Returns true if
+  // 1. |surrounding_text| contains |selected_text|
+  //    from |cursor_pos| to |*anchor_pos|.
+  // or,
+  // 2. |surrounding_text| contains |selected_text|
+  //    from |*anchor_pos| to |cursor_pos|.
+  // with calculating |*anchor_pos|,
+  // where |cursor_pos| and |*anchor_pos| are counts of Unicode characters.
+  // When both 1) and 2) are satisfied, this function calculates
+  // |*anchor_pos| for case 1).
+  // Otherwise returns false.
+  static bool GetAnchorPosFromSelection(
+      const std::string &surrounding_text,
+      const std::string &selected_text,
+      unsigned int cursor_pos,
+      unsigned int *anchor_pos);
+};
+
+bool GetSurroundingText(FcitxInstance* instance,
+                        SurroundingTextInfo *info);
+
+}  // namespace fcitx
+}  // namespace mozc
+
+#endif  // MOZC_UNIX_FCITX_SURROUNDING_TEXT_URIL_H_
diff --git a/src/unix/fcitx5/BUILD.bazel b/src/unix/fcitx5/BUILD.bazel
new file mode 100644
index 0000000..1f6cb36
--- /dev/null
+++ b/src/unix/fcitx5/BUILD.bazel
@@ -0,0 +1,182 @@
+load("@bazel_skylib//rules:common_settings.bzl", "bool_flag")
+load(
+    "//:build_defs.bzl",
+    "mozc_cc_binary",
+    "mozc_cc_library",
+)
+
+package(default_visibility = ["//:__subpackages__"])
+
+bool_flag(
+    name = "use_server",
+    build_setting_default = True,
+)
+
+config_setting(
+    name = "without_server",
+    flag_values = {
+        ":use_server": "False",
+    },
+)
+
+mozc_cc_library(
+    name = "mozc_client_interface",
+    hdrs = [
+        "mozc_client_interface.h",
+    ],
+    deps = [
+        "//protocol:commands_cc_proto",
+        "//protocol:config_cc_proto",
+    ],
+)
+
+mozc_cc_library(
+    name = "mozc_client_pool",
+    srcs = [
+        "mozc_client_pool.cc",
+    ],
+    hdrs = [
+        "mozc_client_pool.h",
+    ],
+    deps = [
+        ":mozc_client_interface",
+        "//protocol:commands_cc_proto",
+        "//protocol:config_cc_proto",
+        "@fcitx5",
+    ],
+)
+
+mozc_cc_library(
+    name = "mozc_direct_client",
+    srcs = [
+        "mozc_direct_client.cc",
+    ],
+    hdrs = [
+        "mozc_direct_client.h",
+    ],
+    deps = [
+        ":mozc_client_interface",
+        "//base:singleton",
+        "//base:vlog",
+        "//config:config_handler",
+        "//data_manager/oss:oss_data_manager",
+        "//engine",
+        "//protocol:commands_cc_proto",
+        "//protocol:config_cc_proto",
+        "//session:key_info_util",
+        "//session:session_handler",
+        "@com_google_absl//absl/log",
+    ],
+)
+
+mozc_cc_library(
+    name = "mozc_ipc_client",
+    srcs = [
+        "mozc_ipc_client.cc",
+    ],
+    hdrs = [
+        "mozc_ipc_client.h",
+    ],
+    deps = [
+        ":mozc_client_interface",
+        "//client",
+        "//protocol:commands_cc_proto",
+        "//protocol:config_cc_proto",
+    ],
+)
+
+mozc_cc_library(
+    name = "i18nwrapper",
+    hdrs = [
+        "i18nwrapper.h",
+    ],
+    deps = [
+        "@fcitx5",
+    ],
+)
+
+mozc_cc_library(
+    name = "mozc_engine",
+    srcs = [
+        "mozc_engine.cc",
+        "mozc_response_parser.cc",
+        "mozc_state.cc",
+    ],
+    hdrs = [
+        "mozc_engine.h",
+        "mozc_response_parser.h",
+        "mozc_state.h",
+    ],
+    deps = [
+        ":fcitx_key_util",
+        ":i18nwrapper",
+        ":mozc_client_pool",
+        ":surrounding_text_util",
+        "//base:init_mozc",
+        "//base:port",
+        "//base:process",
+        "//base:run_level",
+        "//base:util",
+        "//base:vlog",
+        "//protocol:candidate_window_cc_proto",
+        "//protocol:commands_cc_proto",
+        "@fcitx5",
+    ] + select({
+        ":without_server": [
+            ":mozc_direct_client",
+        ],
+        "//conditions:default": [
+            ":mozc_ipc_client",
+        ],
+    }),
+)
+
+mozc_cc_library(
+    name = "fcitx_key_util",
+    srcs = [
+        "fcitx_key_event_handler.cc",
+        "fcitx_key_translator.cc",
+    ],
+    hdrs = [
+        "fcitx_key_event_handler.h",
+        "fcitx_key_translator.h",
+    ],
+    deps = [
+        "//base:port",
+        "//base:singleton",
+        "//base:vlog",
+        "//protocol:commands_cc_proto",
+        "//protocol:config_cc_proto",
+        "@com_google_absl//absl/log:check",
+        "@fcitx5",
+    ],
+)
+
+mozc_cc_library(
+    name = "surrounding_text_util",
+    srcs = [
+        "surrounding_text_util.cc",
+    ],
+    hdrs = [
+        "surrounding_text_util.h",
+    ],
+    deps = [
+        "//base:port",
+        "//base:util",
+        "//base:vlog",
+        "@com_google_absl//absl/log:check",
+        "@fcitx5",
+    ],
+)
+
+mozc_cc_binary(
+    name = "fcitx5-mozc.so",
+    srcs = [
+        "mozc_engine_factory.cc",
+    ],
+    linkshared = 1,
+    linkstatic = 1,
+    deps = [
+        ":mozc_engine",
+    ],
+)
diff --git a/src/unix/fcitx5/Messages.sh b/src/unix/fcitx5/Messages.sh
new file mode 100755
index 0000000..e705349
--- /dev/null
+++ b/src/unix/fcitx5/Messages.sh
@@ -0,0 +1,3 @@
+#!/bin/bash
+
+gen_pot cxx:desktop:appdata fcitx5-mozc po .
diff --git a/src/unix/fcitx5/fcitx5.gyp b/src/unix/fcitx5/fcitx5.gyp
new file mode 100644
index 0000000..28ce73f
--- /dev/null
+++ b/src/unix/fcitx5/fcitx5.gyp
@@ -0,0 +1,118 @@
+#
+# Copyright (c) 2010-2017 fcitx Project http://github.com/fcitx/
+#
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+# 3. Neither the name of authors nor the names of its contributors
+#    may be used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+# SUCH DAMAGE.
+#
+
+{
+  'variables': {
+    'use_fcitx5%': 'YES',
+    'relative_dir': 'unix/fcitx5',
+    'gen_out_dir': '<(SHARED_INTERMEDIATE_DIR)/<(relative_dir)',
+    'fcitx_dependencies': [
+        '../../base/base.gyp:base',
+        '../../client/client.gyp:client',
+        '../../ipc/ipc.gyp:ipc',
+        '../../protocol/protocol.gyp:commands_proto',
+    ],
+  },
+  'conditions': [['use_fcitx5=="YES"', {
+  'targets': [
+    {
+      # Meta target to set up build environment for fcitx5. Required 'cflags'
+      # and 'link_settings' will be automatically injected into any target
+      # which directly or indirectly depends on this target.
+      'target_name': 'fcitx5_build_environment',
+      'type': 'none',
+      'variables': {
+        'target_libs': [
+          'Fcitx5Core',
+          'Fcitx5Config',
+          'Fcitx5Utils',
+          'Fcitx5Module',
+        ],
+      },
+      'all_dependent_settings': {
+        'cflags': [
+          '<!@(pkg-config --cflags <@(target_libs))',
+        ],
+        'link_settings': {
+          'libraries': [
+            '<!@(pkg-config --libs-only-l <@(target_libs))',
+          ],
+          'ldflags': [
+            '<!@(pkg-config --libs-only-L <@(target_libs))',
+          ],
+        },
+      },
+    },
+    {
+      'target_name': 'fcitx5-mozc',
+      'product_prefix': '',
+      'type': 'loadable_module',
+      'sources': [
+        'fcitx_key_translator.cc',
+        'fcitx_key_event_handler.cc',
+        'surrounding_text_util.cc',
+        'mozc_ipc_client.cc',
+        'mozc_response_parser.cc',
+        'mozc_engine.cc',
+        'mozc_engine_factory.cc',
+        'mozc_state.cc',
+        'mozc_client_pool.cc',
+      ],
+      'dependencies': [
+        '<@(fcitx_dependencies)',
+        'fcitx5_build_environment',
+      ],
+      'cflags_cc': [
+        '-std=c++17',
+      ],
+      'cflags_cc!': [
+        '-std=gnu++0x'
+      ],
+      'cflags!': [
+        '-fno-exceptions',
+      ],
+      'ldflags': [
+        '-Wl,--no-undefined',
+        '-Wl,--as-needed',
+      ],
+      'defines': [
+        'FCITX_GETTEXT_DOMAIN="fcitx5-mozc"',
+      ],
+    },
+  ],
+  }, {
+  'targets': [
+    {
+      'target_name': 'no_fcitx5_dummy',
+      'type': 'none',
+    }
+  ]}
+  ]],
+}
diff --git a/src/unix/fcitx5/fcitx_key_event_handler.cc b/src/unix/fcitx5/fcitx_key_event_handler.cc
new file mode 100644
index 0000000..3370a67
--- /dev/null
+++ b/src/unix/fcitx5/fcitx_key_event_handler.cc
@@ -0,0 +1,273 @@
+// Copyright 2010-2012, Google Inc.
+// Copyright 2012-2017, Weng Xuetian <wengxt@gmail.com>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "unix/fcitx5/fcitx_key_event_handler.h"
+
+#include <fcitx-utils/charutils.h>
+#include <fcitx-utils/key.h>
+#include <fcitx-utils/utf8.h>
+
+#include <cstdint>
+#include <map>
+#include <memory>
+#include <set>
+#include <string>
+
+#include "absl/log/check.h"
+#include "absl/log/log.h"
+#include "base/singleton.h"
+#include "protocol/commands.pb.h"
+#include "protocol/config.pb.h"
+#include "unix/fcitx5/fcitx_key_translator.h"
+
+namespace fcitx {
+
+namespace {
+// TODO(hsumita): Removes this class, and moves |data_| into member
+// variables of KeyEventhandler.
+class AdditionalModifiersData {
+ public:
+  AdditionalModifiersData() {
+    data_[mozc::commands::KeyEvent::LEFT_ALT] = mozc::commands::KeyEvent::ALT;
+    data_[mozc::commands::KeyEvent::RIGHT_ALT] = mozc::commands::KeyEvent::ALT;
+    data_[mozc::commands::KeyEvent::LEFT_CTRL] = mozc::commands::KeyEvent::CTRL;
+    data_[mozc::commands::KeyEvent::RIGHT_CTRL] =
+        mozc::commands::KeyEvent::CTRL;
+    data_[mozc::commands::KeyEvent::LEFT_SHIFT] =
+        mozc::commands::KeyEvent::SHIFT;
+    data_[mozc::commands::KeyEvent::RIGHT_SHIFT] =
+        mozc::commands::KeyEvent::SHIFT;
+  }
+  const std::map<uint32_t, mozc::commands::KeyEvent::ModifierKey> &data() {
+    return data_;
+  }
+
+ private:
+  std::map<uint32_t, mozc::commands::KeyEvent::ModifierKey> data_;
+};
+
+// TODO(hsumita): Moves this function into member functions of
+// KeyEventHandler.
+void AddAdditionalModifiers(
+    std::set<mozc::commands::KeyEvent::ModifierKey> *modifier_keys_set) {
+  DCHECK(modifier_keys_set);
+
+  const std::map<uint32_t, mozc::commands::KeyEvent::ModifierKey> &data =
+      mozc::Singleton<AdditionalModifiersData>::get()->data();
+
+  // Adds MODIFIER if there are (LEFT|RIGHT)_MODIFIER like LEFT_SHIFT.
+  for (auto it = modifier_keys_set->begin(); it != modifier_keys_set->end();
+       ++it) {
+    auto item = data.find(*it);
+    if (item != data.end()) {
+      modifier_keys_set->insert(item->second);
+    }
+  }
+}
+
+bool IsModifierToBeSentOnKeyUp(const mozc::commands::KeyEvent &key_event) {
+  if (key_event.modifier_keys_size() == 0) {
+    return false;
+  }
+
+  if (key_event.modifier_keys_size() == 1 &&
+      key_event.modifier_keys(0) == mozc::commands::KeyEvent::CAPS) {
+    return false;
+  }
+
+  return true;
+}
+}  // namespace
+
+KeyEventHandler::KeyEventHandler()
+    : key_translator_(std::make_unique<KeyTranslator>()) {
+  Clear();
+}
+
+bool KeyEventHandler::GetKeyEvent(
+    KeySym keyval, uint32_t keycode, KeyStates modifiers,
+    mozc::config::Config::PreeditMethod preedit_method, bool layout_is_jp,
+    bool is_key_up, mozc::commands::KeyEvent *key) {
+  DCHECK(key);
+  key->Clear();
+
+  if (!key_translator_->Translate(keyval, keycode, modifiers, preedit_method,
+                                  layout_is_jp, key)) {
+    LOG(ERROR) << "Translate failed";
+    return false;
+  }
+
+  return ProcessModifiers(is_key_up, keyval, key);
+}
+
+bool KeyEventHandler::GetKeyEvent(
+    const std::string &composeString,
+    mozc::config::Config::PreeditMethod preedit_method, bool layout_is_jp,
+    mozc::commands::KeyEvent *key) {
+  key->Clear();
+  auto length = utf8::length(composeString);
+  if (length == 1) {
+    auto chr = utf8::getChar(composeString);
+    // For ascii key & yen, use the regular key event conversion.
+    if ((chr >= 0x20 && chr <= 0x7e) || chr == 0xa5) {
+      return GetKeyEvent(static_cast<KeySym>(chr), 0, KeyStates(),
+                         preedit_method, layout_is_jp, false, key);
+    }
+  }
+  key->set_key_string(composeString);
+  return true;
+}
+
+void KeyEventHandler::Clear() {
+  is_non_modifier_key_pressed_ = false;
+  currently_pressed_modifiers_.clear();
+  modifiers_to_be_sent_.clear();
+}
+
+bool KeyEventHandler::ProcessModifiers(bool is_key_up, uint32_t keyval,
+                                       mozc::commands::KeyEvent *key_event) {
+  // Manage modifier key event.
+  // Modifier key event is sent on key up if non-modifier key has not been
+  // pressed since key down of modifier keys and no modifier keys are pressed
+  // anymore.
+  // Following examples are expected behaviors.
+  //
+  // E.g.) Shift key is special. If Shift + printable key is pressed, key event
+  //       does NOT have shift modifiers. It is handled by KeyTranslator class.
+  //    <Event from ibus> <Event to server>
+  //     Shift down      | None
+  //     "a" down        | A
+  //     "a" up          | None
+  //     Shift up        | None
+  //
+  // E.g.) Usual key is sent on key down.  Modifier keys are not sent if usual
+  //       key is sent.
+  //    <Event from ibus> <Event to server>
+  //     Ctrl down       | None
+  //     "a" down        | Ctrl+a
+  //     "a" up          | None
+  //     Ctrl up         | None
+  //
+  // E.g.) Modifier key is sent on key up.
+  //    <Event from ibus> <Event to server>
+  //     Shift down      | None
+  //     Shift up        | Shift
+  //
+  // E.g.) Multiple modifier keys are sent on the last key up.
+  //    <Event from ibus> <Event to server>
+  //     Shift down      | None
+  //     Control down    | None
+  //     Shift up        | None
+  //     Control up      | Control+Shift
+  //
+  // Essentialy we cannot handle modifier key evnet perfectly because
+  // - We cannot get current keyboard status with ibus. If some modifiers
+  //   are pressed or released without focusing the target window, we
+  //   cannot handle it.
+  // E.g.)
+  //    <Event from ibus> <Event to server>
+  //     Ctrl down       | None
+  //     (focuses out, Ctrl up, focuses in)
+  //     Shift down      | None
+  //     Shift up        | None (But we should send Shift key)
+  // To avoid a inconsistent state as much as possible, we clear states
+  // when key event without modifier keys is sent.
+
+  const bool is_modifier_only =
+      !(key_event->has_key_code() || key_event->has_special_key());
+
+  // We may get only up/down key event when a user moves a focus.
+  // This code handles such situation as much as possible.
+  // This code has a bug. If we send Shift + 'a', KeyTranslator removes a shift
+  // modifier and converts 'a' to 'A'. This codes does NOT consider these
+  // situation since we don't have enough data to handle it.
+  // TODO(hsumita): Moves the logic about a handling of Shift or Caps keys from
+  // KeyTranslator to MozcEngine.
+  if (key_event->modifier_keys_size() == 0) {
+    Clear();
+  }
+
+  if (!currently_pressed_modifiers_.empty() && !is_modifier_only) {
+    is_non_modifier_key_pressed_ = true;
+  }
+  if (is_non_modifier_key_pressed_) {
+    modifiers_to_be_sent_.clear();
+  }
+
+  if (is_key_up) {
+    currently_pressed_modifiers_.erase(keyval);
+    if (!is_modifier_only) {
+      return false;
+    }
+    if (!currently_pressed_modifiers_.empty() ||
+        modifiers_to_be_sent_.empty()) {
+      is_non_modifier_key_pressed_ = false;
+      return false;
+    }
+    if (is_non_modifier_key_pressed_) {
+      return false;
+    }
+    DCHECK(!is_non_modifier_key_pressed_);
+
+    // Modifier key event fires
+    key_event->mutable_modifier_keys()->Clear();
+    for (std::set<mozc::commands::KeyEvent::ModifierKey>::const_iterator it =
+             modifiers_to_be_sent_.begin();
+         it != modifiers_to_be_sent_.end(); ++it) {
+      key_event->add_modifier_keys(*it);
+    }
+    modifiers_to_be_sent_.clear();
+  } else if (is_modifier_only) {
+    // TODO(hsumita): Supports a key sequence below.
+    // - Ctrl down
+    // - a down
+    // - Alt down
+    // We should add Alt key to |currently_pressed_modifiers|, but current
+    // implementation does NOT do it.
+    if (currently_pressed_modifiers_.empty() ||
+        !modifiers_to_be_sent_.empty()) {
+      for (int i = 0; i < key_event->modifier_keys_size(); ++i) {
+        modifiers_to_be_sent_.insert(key_event->modifier_keys(i));
+      }
+      AddAdditionalModifiers(&modifiers_to_be_sent_);
+    }
+    currently_pressed_modifiers_.insert(keyval);
+    return false;
+  }
+
+  // Clear modifier data just in case if |key| has no modifier keys.
+  if (!IsModifierToBeSentOnKeyUp(*key_event)) {
+    Clear();
+  }
+
+  return true;
+}
+
+}  // namespace fcitx
diff --git a/src/unix/fcitx5/fcitx_key_event_handler.h b/src/unix/fcitx5/fcitx_key_event_handler.h
new file mode 100644
index 0000000..7421fc6
--- /dev/null
+++ b/src/unix/fcitx5/fcitx_key_event_handler.h
@@ -0,0 +1,83 @@
+// Copyright 2010-2012, Google Inc.
+// Copyright 2012-2017, Weng Xuetian <wengxt@gmail.com>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef UNIX_FCITX5_FCITX_KEY_EVENT_HANDLER_H_
+#define UNIX_FCITX5_FCITX_KEY_EVENT_HANDLER_H_
+
+#include <fcitx-utils/key.h>
+
+#include <cstdint>
+#include <memory>
+#include <set>
+#include <string>
+
+#include "protocol/commands.pb.h"
+#include "protocol/config.pb.h"
+#include "unix/fcitx5/fcitx_key_translator.h"
+
+namespace fcitx {
+
+class KeyEventHandler {
+ public:
+  KeyEventHandler();
+  KeyEventHandler(const KeyEventHandler &) = delete;
+
+  // Converts a key event came from fcitx to commands::KeyEvent. This is a
+  // stateful method. It stores modifier keys states since ibus doesn't send
+  // an enough information about the modifier keys.
+  bool GetKeyEvent(KeySym keyval, uint32_t keycode, KeyStates modifiers,
+                   mozc::config::Config::PreeditMethod preedit_method,
+                   bool layout_is_jp, bool is_key_up,
+                   mozc::commands::KeyEvent *key);
+
+  bool GetKeyEvent(const std::string &composeString,
+                   mozc::config::Config::PreeditMethod preedit_method,
+                   bool layout_is_jp, mozc::commands::KeyEvent *key);
+
+  // Clears states.
+  void Clear();
+
+ private:
+  // Manages modifier keys. Returns false if it should not be sent to server.
+  bool ProcessModifiers(bool is_key_up, uint32_t keyval,
+                        mozc::commands::KeyEvent *key_event);
+
+  std::unique_ptr<KeyTranslator> key_translator_;
+  // Non modifier key is pressed or not after all keys are released.
+  bool is_non_modifier_key_pressed_;
+  // Currently pressed modifier keys.  It is set of keyval.
+  std::set<uint32_t> currently_pressed_modifiers_;
+  // Pending modifier keys.
+  std::set<mozc::commands::KeyEvent::ModifierKey> modifiers_to_be_sent_;
+};
+
+}  // namespace fcitx
+
+#endif  // UNIX_FCITX5_FCITX_KEY_EVENT_HANDLER_H_
diff --git a/src/unix/fcitx5/fcitx_key_translator.cc b/src/unix/fcitx5/fcitx_key_translator.cc
new file mode 100644
index 0000000..6a95486
--- /dev/null
+++ b/src/unix/fcitx5/fcitx_key_translator.cc
@@ -0,0 +1,429 @@
+// Copyright 2010-2012, Google Inc.
+// Copyright 2012-2017, Weng Xuetian <wengxt@gmail.com>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "unix/fcitx5/fcitx_key_translator.h"
+
+#include <fcitx-utils/key.h>
+#include <fcitx-utils/keysym.h>
+
+#include <cstdint>
+#include <map>
+#include <string>
+#include <utility>
+
+#include "absl/log/check.h"
+#include "base/vlog.h"
+#include "protocol/commands.pb.h"
+#include "protocol/config.pb.h"
+
+namespace fcitx {
+using namespace mozc;
+namespace {
+const auto kSpecialKeyMap =
+    new std::map<uint32_t, commands::KeyEvent::SpecialKey>({
+        {FcitxKey_space, commands::KeyEvent::SPACE},
+        {FcitxKey_Return, commands::KeyEvent::ENTER},
+        {FcitxKey_Left, commands::KeyEvent::LEFT},
+        {FcitxKey_Right, commands::KeyEvent::RIGHT},
+        {FcitxKey_Up, commands::KeyEvent::UP},
+        {FcitxKey_Down, commands::KeyEvent::DOWN},
+        {FcitxKey_Escape, commands::KeyEvent::ESCAPE},
+        {FcitxKey_Delete, commands::KeyEvent::DEL},
+        {FcitxKey_BackSpace, commands::KeyEvent::BACKSPACE},
+        {FcitxKey_Insert, commands::KeyEvent::INSERT},
+        {FcitxKey_Henkan, commands::KeyEvent::HENKAN},
+        {FcitxKey_Muhenkan, commands::KeyEvent::MUHENKAN},
+        {FcitxKey_Hiragana, commands::KeyEvent::KANA},
+        {FcitxKey_Hiragana_Katakana, commands::KeyEvent::KANA},
+        {FcitxKey_Katakana, commands::KeyEvent::KATAKANA},
+        {FcitxKey_Zenkaku, commands::KeyEvent::HANKAKU},
+        {FcitxKey_Hankaku, commands::KeyEvent::HANKAKU},
+        {FcitxKey_Zenkaku_Hankaku, commands::KeyEvent::HANKAKU},
+        {FcitxKey_Eisu_toggle, commands::KeyEvent::EISU},
+        {FcitxKey_Home, commands::KeyEvent::HOME},
+        {FcitxKey_End, commands::KeyEvent::END},
+        {FcitxKey_Tab, commands::KeyEvent::TAB},
+        {FcitxKey_F1, commands::KeyEvent::F1},
+        {FcitxKey_F2, commands::KeyEvent::F2},
+        {FcitxKey_F3, commands::KeyEvent::F3},
+        {FcitxKey_F4, commands::KeyEvent::F4},
+        {FcitxKey_F5, commands::KeyEvent::F5},
+        {FcitxKey_F6, commands::KeyEvent::F6},
+        {FcitxKey_F7, commands::KeyEvent::F7},
+        {FcitxKey_F8, commands::KeyEvent::F8},
+        {FcitxKey_F9, commands::KeyEvent::F9},
+        {FcitxKey_F10, commands::KeyEvent::F10},
+        {FcitxKey_F11, commands::KeyEvent::F11},
+        {FcitxKey_F12, commands::KeyEvent::F12},
+        {FcitxKey_F13, commands::KeyEvent::F13},
+        {FcitxKey_F14, commands::KeyEvent::F14},
+        {FcitxKey_F15, commands::KeyEvent::F15},
+        {FcitxKey_F16, commands::KeyEvent::F16},
+        {FcitxKey_F17, commands::KeyEvent::F17},
+        {FcitxKey_F18, commands::KeyEvent::F18},
+        {FcitxKey_F19, commands::KeyEvent::F19},
+        {FcitxKey_F20, commands::KeyEvent::F20},
+        {FcitxKey_F21, commands::KeyEvent::F21},
+        {FcitxKey_F22, commands::KeyEvent::F22},
+        {FcitxKey_F23, commands::KeyEvent::F23},
+        {FcitxKey_F24, commands::KeyEvent::F24},
+        {FcitxKey_Page_Up, commands::KeyEvent::PAGE_UP},
+        {FcitxKey_Page_Down, commands::KeyEvent::PAGE_DOWN},
+
+        // Keypad (10-key).
+        {FcitxKey_KP_0, commands::KeyEvent::NUMPAD0},
+        {FcitxKey_KP_1, commands::KeyEvent::NUMPAD1},
+        {FcitxKey_KP_2, commands::KeyEvent::NUMPAD2},
+        {FcitxKey_KP_3, commands::KeyEvent::NUMPAD3},
+        {FcitxKey_KP_4, commands::KeyEvent::NUMPAD4},
+        {FcitxKey_KP_5, commands::KeyEvent::NUMPAD5},
+        {FcitxKey_KP_6, commands::KeyEvent::NUMPAD6},
+        {FcitxKey_KP_7, commands::KeyEvent::NUMPAD7},
+        {FcitxKey_KP_8, commands::KeyEvent::NUMPAD8},
+        {FcitxKey_KP_9, commands::KeyEvent::NUMPAD9},
+        {FcitxKey_KP_Equal, commands::KeyEvent::EQUALS},         // [=]
+        {FcitxKey_KP_Multiply, commands::KeyEvent::MULTIPLY},    // [*]
+        {FcitxKey_KP_Add, commands::KeyEvent::ADD},              // [+]
+        {FcitxKey_KP_Separator, commands::KeyEvent::SEPARATOR},  // enter
+        {FcitxKey_KP_Subtract, commands::KeyEvent::SUBTRACT},    // [-]
+        {FcitxKey_KP_Decimal, commands::KeyEvent::DECIMAL},      // [.]
+        {FcitxKey_KP_Divide, commands::KeyEvent::DIVIDE},        // [/]
+        {FcitxKey_KP_Space, commands::KeyEvent::SPACE},
+        {FcitxKey_KP_Tab, commands::KeyEvent::TAB},
+        {FcitxKey_KP_Enter, commands::KeyEvent::ENTER},
+        {FcitxKey_KP_Home, commands::KeyEvent::HOME},
+        {FcitxKey_KP_Left, commands::KeyEvent::LEFT},
+        {FcitxKey_KP_Up, commands::KeyEvent::UP},
+        {FcitxKey_KP_Right, commands::KeyEvent::RIGHT},
+        {FcitxKey_KP_Down, commands::KeyEvent::DOWN},
+        {FcitxKey_KP_Page_Up, commands::KeyEvent::PAGE_UP},
+        {FcitxKey_KP_Page_Down, commands::KeyEvent::PAGE_DOWN},
+        {FcitxKey_KP_End, commands::KeyEvent::END},
+        {FcitxKey_KP_Delete, commands::KeyEvent::DEL},
+        {FcitxKey_KP_Insert, commands::KeyEvent::INSERT},
+        {FcitxKey_Caps_Lock, commands::KeyEvent::CAPS_LOCK},
+
+        // Shift+TAB.
+        {FcitxKey_ISO_Left_Tab, commands::KeyEvent::TAB},
+
+        // On Linux (X / Wayland), Hangul and Hanja are identical with
+        // ImeOn and ImeOff.
+        // https://github.com/google/mozc/issues/552
+        //
+        // Hangul == Lang1 (USB HID) / ImeOn (Windows) / Kana (macOS)
+        {FcitxKey_Hangul, commands::KeyEvent::ON},
+        // Hanja == Lang2 (USB HID) / ImeOff (Windows) / Eisu (macOS)
+        {FcitxKey_Hangul_Hanja, commands::KeyEvent::OFF},
+
+        // TODO(mazda): Handle following keys?
+        //   - FcitxKey_Kana_Lock? FcitxKey_KEY_Kana_Shift?
+    });
+
+const auto kFcitxModifierMaskMap = new std::map<uint32_t, KeyState>({
+    {FcitxKey_Shift_L, KeyState::Shift},
+    {FcitxKey_Shift_R, KeyState::Shift},
+    {FcitxKey_Control_L, KeyState::Ctrl},
+    {FcitxKey_Control_R, KeyState::Ctrl},
+    {FcitxKey_Alt_L, KeyState::Alt},
+    {FcitxKey_Alt_R, KeyState::Alt},
+});
+
+// Stores a mapping from ASCII to Kana character. For example, ASCII character
+// '4' is mapped to Japanese 'Hiragana Letter U' (without Shift modifier) and
+// 'Hiragana Letter Small U' (with Shift modifier).
+// TODO(team): Add kana_map_dv to support Dvoraklayout.
+using KanaMap = std::map<uint32_t, std::pair<const char *, const char *>>;
+const KanaMap *kKanaJpMap = new KanaMap({
+    {'1', {"ぬ", "ぬ"}},
+    {'!', {"ぬ", "ぬ"}},
+    {'2', {"ふ", "ふ"}},
+    {'\"', {"ふ", "ふ"}},
+    {'3', {"あ", "ぁ"}},
+    {'#', {"あ", "ぁ"}},
+    {'4', {"う", "ぅ"}},
+    {'$', {"う", "ぅ"}},
+    {'5', {"え", "ぇ"}},
+    {'%', {"え", "ぇ"}},
+    {'6', {"お", "ぉ"}},
+    {'&', {"お", "ぉ"}},
+    {'7', {"や", "ゃ"}},
+    {'\'', {"や", "ゃ"}},
+    {'8', {"ゆ", "ゅ"}},
+    {'(', {"ゆ", "ゅ"}},
+    {'9', {"よ", "ょ"}},
+    {')', {"よ", "ょ"}},
+    {'0', {"わ", "を"}},
+    {'-', {"ほ", "ほ"}},
+    {'=', {"ほ", "ほ"}},
+    {'^', {"へ", "を"}},
+    {'~', {"へ", "を"}},
+    {'|', {"ー", "ー"}},
+    {'q', {"た", "た"}},
+    {'Q', {"た", "た"}},
+    {'w', {"て", "て"}},
+    {'W', {"て", "て"}},
+    {'e', {"い", "ぃ"}},
+    {'E', {"い", "ぃ"}},
+    {'r', {"す", "す"}},
+    {'R', {"す", "す"}},
+    {'t', {"か", "か"}},
+    {'T', {"か", "か"}},
+    {'y', {"ん", "ん"}},
+    {'Y', {"ん", "ん"}},
+    {'u', {"な", "な"}},
+    {'U', {"な", "な"}},
+    {'i', {"に", "に"}},
+    {'I', {"に", "に"}},
+    {'o', {"ら", "ら"}},
+    {'O', {"ら", "ら"}},
+    {'p', {"せ", "せ"}},
+    {'P', {"せ", "せ"}},
+    {'@', {"゛", "゛"}},
+    {'`', {"゛", "゛"}},
+    {'[', {"゜", "「"}},
+    {'{', {"゜", "「"}},
+    {'a', {"ち", "ち"}},
+    {'A', {"ち", "ち"}},
+    {'s', {"と", "と"}},
+    {'S', {"と", "と"}},
+    {'d', {"し", "し"}},
+    {'D', {"し", "し"}},
+    {'f', {"は", "は"}},
+    {'F', {"は", "は"}},
+    {'g', {"き", "き"}},
+    {'G', {"き", "き"}},
+    {'h', {"く", "く"}},
+    {'H', {"く", "く"}},
+    {'j', {"ま", "ま"}},
+    {'J', {"ま", "ま"}},
+    {'k', {"の", "の"}},
+    {'K', {"の", "の"}},
+    {'l', {"り", "り"}},
+    {'L', {"り", "り"}},
+    {';', {"れ", "れ"}},
+    {'+', {"れ", "れ"}},
+    {':', {"け", "け"}},
+    {'*', {"け", "け"}},
+    {']', {"む", "」"}},
+    {'}', {"む", "」"}},
+    {'z', {"つ", "っ"}},
+    {'Z', {"つ", "っ"}},
+    {'x', {"さ", "さ"}},
+    {'X', {"さ", "さ"}},
+    {'c', {"そ", "そ"}},
+    {'C', {"そ", "そ"}},
+    {'v', {"ひ", "ひ"}},
+    {'V', {"ひ", "ひ"}},
+    {'b', {"こ", "こ"}},
+    {'B', {"こ", "こ"}},
+    {'n', {"み", "み"}},
+    {'N', {"み", "み"}},
+    {'m', {"も", "も"}},
+    {'M', {"も", "も"}},
+    {',', {"ね", "、"}},
+    {'<', {"ね", "、"}},
+    {'.', {"る", "。"}},
+    {'>', {"る", "。"}},
+    {'/', {"め", "・"}},
+    {'?', {"め", "・"}},
+    {'_', {"ろ", "ろ"}},
+    // A backslash is handled in a special way because it is input by
+    // two different keys (the one next to Backslash and the one next
+    // to Right Shift).
+    {'\\', {"ろ", "ろ"}},
+    {U'¥', {"ー", "ー"}},  // U+00A5
+});
+
+const KanaMap *kKanaUsMap = new KanaMap({
+    {'`', {"ろ", "ろ"}},  {'~', {"ろ", "ろ"}},  {'1', {"ぬ", "ぬ"}},
+    {'!', {"ぬ", "ぬ"}},  {'2', {"ふ", "ふ"}},  {'@', {"ふ", "ふ"}},
+    {'3', {"あ", "ぁ"}},  {'#', {"あ", "ぁ"}},  {'4', {"う", "ぅ"}},
+    {'$', {"う", "ぅ"}},  {'5', {"え", "ぇ"}},  {'%', {"え", "ぇ"}},
+    {'6', {"お", "ぉ"}},  {'^', {"お", "ぉ"}},  {'7', {"や", "ゃ"}},
+    {'&', {"や", "ゃ"}},  {'8', {"ゆ", "ゅ"}},  {'*', {"ゆ", "ゅ"}},
+    {'9', {"よ", "ょ"}},  {'(', {"よ", "ょ"}},  {'0', {"わ", "を"}},
+    {')', {"わ", "を"}},  {'-', {"ほ", "ー"}},  {'_', {"ほ", "ー"}},
+    {'=', {"へ", "へ"}},  {'+', {"へ", "へ"}},  {'q', {"た", "た"}},
+    {'Q', {"た", "た"}},  {'w', {"て", "て"}},  {'W', {"て", "て"}},
+    {'e', {"い", "ぃ"}},  {'E', {"い", "ぃ"}},  {'r', {"す", "す"}},
+    {'R', {"す", "す"}},  {'t', {"か", "か"}},  {'T', {"か", "か"}},
+    {'y', {"ん", "ん"}},  {'Y', {"ん", "ん"}},  {'u', {"な", "な"}},
+    {'U', {"な", "な"}},  {'i', {"に", "に"}},  {'I', {"に", "に"}},
+    {'o', {"ら", "ら"}},  {'O', {"ら", "ら"}},  {'p', {"せ", "せ"}},
+    {'P', {"せ", "せ"}},  {'[', {"゛", "゛"}},  {'{', {"゛", "゛"}},
+    {']', {"゜", "「"}},  {'}', {"゜", "「"}},  {'\\', {"む", "」"}},
+    {'|', {"む", "」"}},  {'a', {"ち", "ち"}},  {'A', {"ち", "ち"}},
+    {'s', {"と", "と"}},  {'S', {"と", "と"}},  {'d', {"し", "し"}},
+    {'D', {"し", "し"}},  {'f', {"は", "は"}},  {'F', {"は", "は"}},
+    {'g', {"き", "き"}},  {'G', {"き", "き"}},  {'h', {"く", "く"}},
+    {'H', {"く", "く"}},  {'j', {"ま", "ま"}},  {'J', {"ま", "ま"}},
+    {'k', {"の", "の"}},  {'K', {"の", "の"}},  {'l', {"り", "り"}},
+    {'L', {"り", "り"}},  {';', {"れ", "れ"}},  {':', {"れ", "れ"}},
+    {'\'', {"け", "け"}}, {'\"', {"け", "け"}}, {'z', {"つ", "っ"}},
+    {'Z', {"つ", "っ"}},  {'x', {"さ", "さ"}},  {'X', {"さ", "さ"}},
+    {'c', {"そ", "そ"}},  {'C', {"そ", "そ"}},  {'v', {"ひ", "ひ"}},
+    {'V', {"ひ", "ひ"}},  {'b', {"こ", "こ"}},  {'B', {"こ", "こ"}},
+    {'n', {"み", "み"}},  {'N', {"み", "み"}},  {'m', {"も", "も"}},
+    {'M', {"も", "も"}},  {',', {"ね", "、"}},  {'<', {"ね", "、"}},
+    {'.', {"る", "。"}},  {'>', {"る", "。"}},  {'/', {"め", "・"}},
+    {'?', {"め", "・"}},
+});
+
+const char *GetKanaValue(const KanaMap &kana_map, uint32_t keyval,
+                         bool is_shift) {
+  KanaMap::const_iterator iter = kana_map.find(keyval);
+  if (iter == kana_map.end()) {
+    return nullptr;
+  }
+  return (is_shift) ? iter->second.second : iter->second.first;
+}
+
+}  // namespace
+
+// TODO(nona): Fix 'Shift-0' behavior b/4338394
+bool KeyTranslator::Translate(KeySym keyval, uint32_t keycode,
+                              KeyStates modifiers,
+                              mozc::config::Config::PreeditMethod method,
+                              bool layout_is_jp,
+                              mozc::commands::KeyEvent *out_event) const {
+  DCHECK(out_event) << "out_event is NULL";
+  out_event->Clear();
+
+  /* this is key we cannot handle, don't process it */
+  if (modifiers & KeyState::Super) {
+    return false;
+  }
+
+  // Due to historical reasons, many linux ditributions set Hiragana_Katakana
+  // key as Hiragana key (which is Katkana key with shift modifier). So, we
+  // translate Hiragana_Katanaka key as Hiragana key by mapping table, and
+  // Shift + Hiragana_Katakana key as Katakana key by functionally.
+  // TODO(nona): Fix process modifier to handle right shift
+  if (IsHiraganaKatakanaKeyWithShift(keyval, keycode, modifiers)) {
+    modifiers.unset(KeyState::Shift);
+    keyval = FcitxKey_Katakana;
+  }
+  std::string kana_key_string;
+  if ((method == mozc::config::Config::KANA) &&
+      IsKanaAvailable(keyval, keycode, modifiers, layout_is_jp,
+                      &kana_key_string)) {
+    out_event->set_key_code(keyval);
+    out_event->set_key_string(kana_key_string);
+  } else if (IsAscii(keyval, keycode, modifiers)) {
+    if (modifiers & KeyState::CapsLock) {
+      out_event->add_modifier_keys(mozc::commands::KeyEvent::CAPS);
+    }
+    out_event->set_key_code(keyval);
+  } else if (auto it = kFcitxModifierMaskMap->find(keyval);
+             it != kFcitxModifierMaskMap->end()) {
+    // Convert Fcitx modifier key to mask (e.g. FcitxKey_Shift_L to
+    // KeyState::Shift)
+    modifiers |= it->second;
+  } else if (auto it = kSpecialKeyMap->find(keyval);
+             it != kSpecialKeyMap->end()) {
+    out_event->set_special_key(it->second);
+  } else {
+    MOZC_VLOG(1) << "Unknown keyval: " << keyval;
+    return false;
+  }
+
+  // Modifier keys
+  if (modifiers & KeyState::Shift && !IsPrintable(keyval, keycode, modifiers)) {
+    // Only set a SHIFT modifier when `keyval` is a printable key by following
+    // the Mozc's rule.
+    out_event->add_modifier_keys(commands::KeyEvent::SHIFT);
+  }
+  if (modifiers & KeyState::Ctrl) {
+    out_event->add_modifier_keys(commands::KeyEvent::CTRL);
+  }
+  if (modifiers & KeyState::Alt) {
+    out_event->add_modifier_keys(commands::KeyEvent::ALT);
+  }
+
+  return true;
+}
+
+bool KeyTranslator::IsHiraganaKatakanaKeyWithShift(KeySym keyval,
+                                                   uint32_t /*keycode*/,
+                                                   KeyStates modifiers) {
+  return ((modifiers & KeyState::Shift) &&
+          (keyval == FcitxKey_Hiragana_Katakana));
+}
+
+bool KeyTranslator::IsKanaAvailable(KeySym keyval, uint32_t keycode,
+                                    KeyStates modifiers, bool layout_is_jp,
+                                    std::string *out) const {
+  if ((modifiers & KeyState::Ctrl) || (modifiers & KeyState::Alt)) {
+    return false;
+  }
+  const KanaMap &kana_map = layout_is_jp ? *kKanaJpMap : *kKanaUsMap;
+
+  // When a Japanese keyboard is in use, the yen-sign key and the backslash
+  // key generate the same |keyval|. In this case, we have to check |keycode|
+  // to return an appropriate string. See the following IBus issue for
+  // details: https://github.com/ibus/ibus/issues/73
+  // Note the difference(8, evdev offset) of keycode value between ibus/fcitx.
+  // IBUS_bar was wrongly used in mozc (it's a keysym value, not key code, so
+  // the intention is to compare against 124 (a.k.a 124 + 8 here).
+  if (layout_is_jp && keyval == '\\' && keycode == 132) {
+    keyval = static_cast<KeySym>(U'¥');  // U+00A5
+  }
+
+  const bool is_shift = (modifiers & KeyState::Shift);
+  const char *kana = GetKanaValue(kana_map, keyval, is_shift);
+
+  if (kana == nullptr) {
+    return false;
+  }
+  if (out) {
+    out->assign(kana);
+  }
+  return true;
+}
+
+// TODO(nona): resolve S-'0' problem (b/4338394).
+// TODO(nona): Current printable detection is weak. To enhance accuracy, use xkb
+// key map
+bool KeyTranslator::IsPrintable(KeySym keyval, uint32_t keycode,
+                                KeyStates modifiers) {
+  if ((modifiers & KeyState::Ctrl) || (modifiers & KeyState::Alt)) {
+    return false;
+  }
+  return IsAscii(keyval, keycode, modifiers);
+}
+
+bool KeyTranslator::IsAscii(KeySym keyval, uint32_t /*keycode*/,
+                            KeyStates /*modifiers*/) {
+  return (keyval > FcitxKey_space &&
+          // Note: Space key (0x20) is a special key in Mozc.
+          keyval <= FcitxKey_asciitilde);  // 0x7e.
+}
+
+}  // namespace fcitx
diff --git a/src/unix/fcitx5/fcitx_key_translator.h b/src/unix/fcitx5/fcitx_key_translator.h
new file mode 100644
index 0000000..0991b38
--- /dev/null
+++ b/src/unix/fcitx5/fcitx_key_translator.h
@@ -0,0 +1,76 @@
+// Copyright 2010-2012, Google Inc.
+// Copyright 2012~2023, Weng Xuetian <wengxt@gmail.com>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef UNIX_FCITX5_FCITX_KEY_TRANSLATOR_H_
+#define UNIX_FCITX5_FCITX_KEY_TRANSLATOR_H_
+
+#include <fcitx-utils/key.h>
+
+#include <cstdint>
+#include <string>
+
+#include "protocol/commands.pb.h"
+#include "protocol/config.pb.h"
+
+namespace fcitx {
+
+// This class is responsible for converting fcitx's key to IPC input for
+// mozc_server.
+class KeyTranslator {
+ public:
+  KeyTranslator() = default;
+  KeyTranslator(const KeyTranslator &) = delete;
+  KeyTranslator &operator=(const KeyTranslator &) = delete;
+  virtual ~KeyTranslator() = default;
+
+  // Converts fcitx key into Mozc key code and stores them on out_translated.
+  bool Translate(KeySym keyval, uint32_t keycode, KeyStates modifiers,
+                 mozc::config::Config::PreeditMethod method, bool layout_is_jp,
+                 mozc::commands::KeyEvent *out_event) const;
+
+ private:
+  // Returns true iff |keyval| is a key with a kana assigned.
+  bool IsKanaAvailable(KeySym keyval, uint32_t keycode, KeyStates modifiers,
+                       bool layout_is_jp, std::string *out) const;
+
+  // Returns true iff key is ASCII such as '0', 'A', or '!'.
+  static bool IsAscii(KeySym keyval, uint32_t keycode, KeyStates modifiers);
+
+  // Returns true iff key is printable.
+  static bool IsPrintable(KeySym keyval, uint32_t keycode, KeyStates modifiers);
+
+  // Returns true iff key is HiraganaKatakana with shift modifier.
+  static bool IsHiraganaKatakanaKeyWithShift(KeySym keyval, uint32_t keycode,
+                                             KeyStates modifiers);
+};
+
+}  // namespace fcitx
+
+#endif  // MOZC_UNIX_FCITX_FCITX_KEY_TRANSLATOR_H_
diff --git a/src/unix/fcitx5/i18nwrapper.h b/src/unix/fcitx5/i18nwrapper.h
new file mode 100644
index 0000000..9680f18
--- /dev/null
+++ b/src/unix/fcitx5/i18nwrapper.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2017~2017 by CSSlayer
+ * wengxt@gmail.com
+ *
+ * This library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; see the file COPYING. If not,
+ * see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef UNIX_FCITX5_I18NWRAPPER_H_
+#define UNIX_FCITX5_I18NWRAPPER_H_
+
+#define FCITX_GETTEXT_DOMAIN "fcitx5-mozc"
+
+#include <fcitx-utils/i18n.h>  // IWYU pragma: export
+
+#endif
diff --git a/src/unix/fcitx5/mozc-addon.conf b/src/unix/fcitx5/mozc-addon.conf
new file mode 100644
index 0000000..88fbc11
--- /dev/null
+++ b/src/unix/fcitx5/mozc-addon.conf
@@ -0,0 +1,10 @@
+[Addon]
+Name=Mozc
+Category=InputMethod
+Library=fcitx5-mozc
+Type=SharedLibrary
+OnDemand=True
+Configurable=True
+
+[Addon/OptionalDependencies]
+0=clipboard
diff --git a/src/unix/fcitx5/mozc.conf b/src/unix/fcitx5/mozc.conf
new file mode 100644
index 0000000..40725d7
--- /dev/null
+++ b/src/unix/fcitx5/mozc.conf
@@ -0,0 +1,7 @@
+[InputMethod]
+Name=Mozc
+Icon=fcitx_mozc
+Label=あ
+LangCode=ja
+Addon=mozc
+Configurable=True
diff --git a/src/unix/fcitx5/mozc_client_interface.h b/src/unix/fcitx5/mozc_client_interface.h
new file mode 100644
index 0000000..27e075e
--- /dev/null
+++ b/src/unix/fcitx5/mozc_client_interface.h
@@ -0,0 +1,44 @@
+#ifndef UNIX_FCITX5_MOZC_CLIENT_INTERFACE_H_
+#define UNIX_FCITX5_MOZC_CLIENT_INTERFACE_H_
+
+#include <memory>
+#include <string>
+#include <string_view>
+
+#include "protocol/commands.pb.h"
+#include "protocol/config.pb.h"
+
+namespace fcitx {
+
+// This is a simplified version of mozc::ClientInterface, with only functions
+// Needed by Fcitx.
+class MozcClientInterface {
+ public:
+  virtual ~MozcClientInterface() = default;
+  virtual bool EnsureConnection() = 0;
+  bool SendCommand(const mozc::commands::SessionCommand &command,
+                   mozc::commands::Output *output) {
+    return SendCommandWithContext(
+        command, mozc::commands::Context::default_instance(), output);
+  }
+  virtual bool SendKeyWithContext(const mozc::commands::KeyEvent &key,
+                                  const mozc::commands::Context &context,
+                                  mozc::commands::Output *output) = 0;
+  virtual bool SendCommandWithContext(
+      const mozc::commands::SessionCommand &command,
+      const mozc::commands::Context &context,
+      mozc::commands::Output *output) = 0;
+  virtual bool IsDirectModeCommand(
+      const mozc::commands::KeyEvent &key) const = 0;
+  virtual bool GetConfig(mozc::config::Config *config) = 0;
+  virtual void set_client_capability(
+      const mozc::commands::Capability &capability) = 0;
+  virtual bool SyncData() = 0;
+  virtual bool LaunchTool(const std::string &mode, std::string_view arg) = 0;
+  virtual bool LaunchToolWithProtoBuf(const mozc::commands::Output &output) = 0;
+};
+
+std::unique_ptr<MozcClientInterface> createClient();
+
+}  // namespace fcitx
+#endif
diff --git a/src/unix/fcitx5/mozc_client_pool.cc b/src/unix/fcitx5/mozc_client_pool.cc
new file mode 100644
index 0000000..b7fedd4
--- /dev/null
+++ b/src/unix/fcitx5/mozc_client_pool.cc
@@ -0,0 +1,123 @@
+// Copyright 2023-2023, Weng Xuetian <wengxt@gmail.com>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "unix/fcitx5/mozc_client_pool.h"
+
+#include <fcitx-utils/charutils.h>
+#include <fcitx-utils/macros.h>
+#include <fcitx-utils/stringutils.h>
+#include <fcitx/inputcontext.h>
+#include <fcitx/inputcontextmanager.h>
+
+#include <cassert>
+#include <memory>
+#include <string>
+#include <utility>
+
+#include "protocol/commands.pb.h"
+#include "unix/fcitx5/mozc_client_interface.h"
+
+namespace fcitx {
+
+MozcClientPool::MozcClientPool(PropertyPropagatePolicy initialPolicy)
+    : policy_(initialPolicy) {}
+
+void MozcClientPool::setPolicy(PropertyPropagatePolicy policy) {
+  if (policy_ == policy) {
+    return;
+  }
+
+  assert(clients_.empty());
+  policy_ = policy;
+}
+
+std::string uuidKey(InputContext *ic) {
+  std::string key = "u:";
+  for (auto v : ic->uuid()) {
+    auto lower = v % 16;
+    auto upper = v / 16;
+    key.push_back(charutils::toHex(upper));
+    key.push_back(charutils::toHex(lower));
+  }
+  return key;
+}
+
+std::shared_ptr<MozcClientInterface> MozcClientPool::requestClient(
+    InputContext *ic) {
+  std::string key;
+  switch (policy_) {
+    case PropertyPropagatePolicy::No:
+      key = uuidKey(ic);
+      break;
+    case PropertyPropagatePolicy::Program:
+      if (!ic->program().empty()) {
+        key = stringutils::concat("p:", ic->program());
+      } else {
+        key = uuidKey(ic);
+      }
+      break;
+    case PropertyPropagatePolicy::All:
+      key = "g:";
+      break;
+  }
+  auto iter = clients_.find(key);
+  if (iter != clients_.end()) {
+    return iter->second.lock();
+  }
+  std::unique_ptr<MozcClientInterface> newclient = createClient();
+  // Currently client capability is fixed.
+  mozc::commands::Capability capability;
+  capability.set_text_deletion(
+      mozc::commands::Capability::DELETE_PRECEDING_TEXT);
+  newclient->set_client_capability(capability);
+  return registerClient(key, std::move(newclient));
+}
+
+std::shared_ptr<MozcClientInterface> MozcClientPool::registerClient(
+    const std::string &key, std::unique_ptr<MozcClientInterface> client) {
+  assert(!key.empty());
+  std::shared_ptr<MozcClientInterface> managedClient(
+      client.release(),
+      [key, ref = this->watch()](MozcClientInterface *client) {
+        if (auto *that = ref.get()) {
+          that->unregisterClient(key);
+        }
+        delete client;
+      });
+  const auto [iter, success] = clients_.emplace(key, managedClient);
+  FCITX_UNUSED(success);
+  assert(success);
+  return managedClient;
+}
+
+void MozcClientPool::unregisterClient(const std::string &key) {
+  clients_.erase(key);
+}
+
+}  // namespace fcitx
diff --git a/src/unix/fcitx5/mozc_client_pool.h b/src/unix/fcitx5/mozc_client_pool.h
new file mode 100644
index 0000000..9a00f25
--- /dev/null
+++ b/src/unix/fcitx5/mozc_client_pool.h
@@ -0,0 +1,66 @@
+// Copyright 2023-2023, Weng Xuetian <wengxt@gmail.com>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef UNIX_FCITX5_MOZC_CLIENT_POOL_H_
+#define UNIX_FCITX5_MOZC_CLIENT_POOL_H_
+
+#include <fcitx-utils/trackableobject.h>
+#include <fcitx/inputcontext.h>
+#include <fcitx/inputcontextmanager.h>
+
+#include <memory>
+#include <string>
+#include <unordered_map>
+
+#include "unix/fcitx5/mozc_client_interface.h"
+
+namespace fcitx {
+
+class MozcClientPool : public TrackableObject<MozcClientPool> {
+  friend class MozcClientInterface;
+
+ public:
+  MozcClientPool(PropertyPropagatePolicy initialPolicy);
+
+  void setPolicy(PropertyPropagatePolicy policy);
+  PropertyPropagatePolicy policy() const { return policy_; }
+
+  std::shared_ptr<MozcClientInterface> requestClient(InputContext *ic);
+
+ private:
+  std::shared_ptr<MozcClientInterface> registerClient(
+      const std::string &key, std::unique_ptr<MozcClientInterface> client);
+  void unregisterClient(const std::string &key);
+  PropertyPropagatePolicy policy_;
+  std::unordered_map<std::string, std::weak_ptr<MozcClientInterface>> clients_;
+};
+
+}  // namespace fcitx
+
+#endif
diff --git a/src/unix/fcitx5/mozc_direct_client.cc b/src/unix/fcitx5/mozc_direct_client.cc
new file mode 100644
index 0000000..d25851b
--- /dev/null
+++ b/src/unix/fcitx5/mozc_direct_client.cc
@@ -0,0 +1,280 @@
+#include "unix/fcitx5/mozc_direct_client.h"
+
+#include <Fcitx5/Utils/fcitx-utils/macros.h>
+
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+#include <string>
+#include <string_view>
+#include <utility>
+
+#include "absl/log/check.h"
+#include "absl/log/log.h"
+#include "base/singleton.h"
+#include "config/config_handler.h"
+#include "data_manager/oss/oss_data_manager.h"
+#include "engine/engine.h"
+#include "protocol/commands.pb.h"
+#include "protocol/config.pb.h"
+#include "session/key_info_util.h"
+#include "session/session_handler.h"
+#include "unix/fcitx5/mozc_client_interface.h"
+
+namespace fcitx {
+
+namespace {
+
+std::unique_ptr<mozc::SessionHandler> CreateSessionHandler() {
+  auto engine = mozc::Engine::CreateDesktopEngine(
+      std::make_unique<mozc::oss::OssDataManager>());
+  DCHECK_OK(engine);
+  auto result =
+      std::make_unique<mozc::SessionHandler>(std::move(engine.value()));
+  return result;
+}
+
+mozc::SessionHandler *GetSessionHandler() {
+  static std::unique_ptr<mozc::SessionHandler> g_session_handler =
+      CreateSessionHandler();
+  return g_session_handler.get();
+}
+
+}  // namespace
+
+MozcDirectClient::MozcDirectClient() : id_(0) {
+  // Initialize direct_mode_keys_
+  direct_mode_keys_ = mozc::KeyInfoUtil::ExtractSortedDirectModeKeys(
+      *mozc::config::ConfigHandler::GetSharedConfig());
+  InitRequestForSvsJapanese(true);
+}
+
+MozcDirectClient::~MozcDirectClient() { DeleteSession(); }
+
+void MozcDirectClient::InitRequestForSvsJapanese(bool use_svs) {
+  request_ = std::make_unique<mozc::commands::Request>();
+
+  mozc::commands::DecoderExperimentParams params;
+  uint32_t variation_types = params.variation_character_types();
+  if (use_svs) {
+    variation_types |= mozc::commands::DecoderExperimentParams::SVS_JAPANESE;
+  } else {
+    variation_types &= ~mozc::commands::DecoderExperimentParams::SVS_JAPANESE;
+  }
+  request_->mutable_decoder_experiment_params()->set_variation_character_types(
+      variation_types);
+}
+
+bool MozcDirectClient::EnsureSession() {
+  if (server_status_ == SERVER_OK) {
+    return true;
+  }
+  if (!CreateSession()) {
+    LOG(ERROR) << "CreateSession failed";
+    return false;
+  }
+
+  // Call SET_REQUEST if request_ is not nullptr.
+  if (request_) {
+    mozc::commands::Input input;
+    input.set_id(id_);
+    input.set_type(mozc::commands::Input::SET_REQUEST);
+    *input.mutable_request() = *request_;
+    mozc::commands::Output output;
+    Call(input, &output);
+  }
+
+  server_status_ = SERVER_OK;
+  return true;
+}
+
+bool MozcDirectClient::SendKeyWithContext(
+    const mozc::commands::KeyEvent &key, const mozc::commands::Context &context,
+    mozc::commands::Output *output) {
+  mozc::commands::Input input;
+  input.set_type(mozc::commands::Input::SEND_KEY);
+  *input.mutable_key() = key;
+  // If the pointer of |context| is not the default_instance, update the data.
+  if (&context != &mozc::commands::Context::default_instance()) {
+    *input.mutable_context() = context;
+  }
+  return EnsureCallCommand(&input, output);
+}
+
+bool MozcDirectClient::SendCommandWithContext(
+    const mozc::commands::SessionCommand &command,
+    const mozc::commands::Context &context, mozc::commands::Output *output) {
+  mozc::commands::Input input;
+  input.set_type(mozc::commands::Input::SEND_COMMAND);
+  *input.mutable_command() = command;
+  // If the pointer of |context| is not the default_instance, update the data.
+  if (&context != &mozc::commands::Context::default_instance()) {
+    *input.mutable_context() = context;
+  }
+  return EnsureCallCommand(&input, output);
+}
+
+bool MozcDirectClient::EnsureCallCommand(mozc::commands::Input *input,
+                                         mozc::commands::Output *output) {
+  if (!EnsureSession()) {
+    LOG(ERROR) << "EnsureSession failed";
+    return false;
+  }
+  InitInput(input);
+  output->set_id(0);
+
+  if (!Call(*input, output)) {
+    LOG(ERROR) << "Call command failed";
+    return false;
+  }
+  return true;
+}
+
+void MozcDirectClient::set_client_capability(
+    const mozc::commands::Capability &capability) {
+  client_capability_ = capability;
+}
+
+bool MozcDirectClient::CreateSession() {
+  id_ = 0;
+  mozc::commands::Input input;
+  input.set_type(mozc::commands::Input::CREATE_SESSION);
+
+  *input.mutable_capability() = client_capability_;
+
+  mozc::commands::Output output;
+  if (!Call(input, &output)) {
+    return false;
+  }
+
+  if (output.error_code() != mozc::commands::Output::SESSION_SUCCESS) {
+    LOG(ERROR) << "Server returns an error";
+    server_status_ = SERVER_INVALID_SESSION;
+    return false;
+  }
+
+  id_ = output.id();
+  return true;
+}
+
+bool MozcDirectClient::DeleteSession() {
+  // No need to delete session
+  if (id_ == 0) {
+    return true;
+  }
+
+  mozc::commands::Input input;
+  InitInput(&input);
+  input.set_type(mozc::commands::Input::DELETE_SESSION);
+
+  mozc::commands::Output output;
+  if (!Call(input, &output)) {
+    LOG(ERROR) << "DeleteSession failed";
+    return false;
+  }
+  id_ = 0;
+  return true;
+}
+
+bool MozcDirectClient::IsDirectModeCommand(
+    const mozc::commands::KeyEvent &key) const {
+  return mozc::KeyInfoUtil::ContainsKey(direct_mode_keys_, key);
+}
+
+bool MozcDirectClient::GetConfig(mozc::config::Config *config) {
+  mozc::commands::Input input;
+  InitInput(&input);
+  input.set_type(mozc::commands::Input::GET_CONFIG);
+
+  mozc::commands::Output output;
+  if (!Call(input, &output)) {
+    return false;
+  }
+
+  if (!output.has_config()) {
+    return false;
+  }
+
+  config->Clear();
+  *config = output.config();
+  return true;
+}
+
+bool MozcDirectClient::SyncData() {
+  return CallCommand(mozc::commands::Input::SYNC_DATA);
+}
+
+bool MozcDirectClient::CallCommand(mozc::commands::Input::CommandType type) {
+  mozc::commands::Input input;
+  InitInput(&input);
+  input.set_type(type);
+  mozc::commands::Output output;
+  return Call(input, &output);
+}
+
+bool MozcDirectClient::Call(const mozc::commands::Input &input,
+                            mozc::commands::Output *output) {
+  mozc::commands::Command command;
+  *command.mutable_input() = input;
+  if (!GetSessionHandler()->EvalCommand(&command)) {
+    return false;
+  }
+  *output = command.output();
+  return true;
+}
+
+void MozcDirectClient::InitInput(mozc::commands::Input *input) const {
+  input->set_id(id_);
+}
+
+bool MozcDirectClient::TranslateProtoBufToMozcToolArg(
+    const mozc::commands::Output &output, std::string *mode) {
+  if (!output.has_launch_tool_mode() || mode == nullptr) {
+    return false;
+  }
+
+  switch (output.launch_tool_mode()) {
+    case mozc::commands::Output::CONFIG_DIALOG:
+      mode->assign("config_dialog");
+      break;
+    case mozc::commands::Output::DICTIONARY_TOOL:
+      mode->assign("dictionary_tool");
+      break;
+    case mozc::commands::Output::WORD_REGISTER_DIALOG:
+      mode->assign("word_register_dialog");
+      break;
+    case mozc::commands::Output::NO_TOOL:
+    default:
+      // do nothing
+      return false;
+      break;
+  }
+
+  return true;
+}
+
+bool MozcDirectClient::LaunchToolWithProtoBuf(
+    const mozc::commands::Output &output) {
+  std::string mode;
+  if (!TranslateProtoBufToMozcToolArg(output, &mode)) {
+    return false;
+  }
+
+  // TODO(nona): extends output message to support extra argument.
+  return LaunchTool(mode, "");
+}
+
+bool MozcDirectClient::LaunchTool(const std::string &mode,
+                                  const std::string_view extra_arg) {
+  FCITX_UNUSED(mode);
+  FCITX_UNUSED(extra_arg);
+  // We don't spawn a server thread as for now, so the tool is not helpful
+  // anyway.
+  return false;
+}
+
+std::unique_ptr<MozcClientInterface> createClient() {
+  return std::make_unique<MozcDirectClient>();
+}
+
+}  // namespace fcitx
diff --git a/src/unix/fcitx5/mozc_direct_client.h b/src/unix/fcitx5/mozc_direct_client.h
new file mode 100644
index 0000000..fc4e188
--- /dev/null
+++ b/src/unix/fcitx5/mozc_direct_client.h
@@ -0,0 +1,77 @@
+#ifndef UNIX_FCITX5_MOZC_DIRECT_CLIENT_H_
+#define UNIX_FCITX5_MOZC_DIRECT_CLIENT_H_
+
+#include <cstdint>
+#include <memory>
+#include <string>
+#include <string_view>
+#include <vector>
+
+#include "composer/key_event_util.h"
+#include "protocol/commands.pb.h"
+#include "protocol/config.pb.h"
+#include "unix/fcitx5/mozc_client_interface.h"
+
+namespace fcitx {
+
+class MozcDirectClient : public MozcClientInterface {
+ public:
+  MozcDirectClient();
+  ~MozcDirectClient();
+
+  bool EnsureConnection() override { return true; }
+  bool SendKeyWithContext(const mozc::commands::KeyEvent &key,
+                          const mozc::commands::Context &context,
+                          mozc::commands::Output *output) override;
+  bool SendCommandWithContext(const mozc::commands::SessionCommand &command,
+                              const mozc::commands::Context &context,
+                              mozc::commands::Output *output) override;
+  bool IsDirectModeCommand(const mozc::commands::KeyEvent &key) const override;
+  bool GetConfig(mozc::config::Config *config) override;
+  void set_client_capability(
+      const mozc::commands::Capability &capability) override;
+  bool SyncData() override;
+  bool LaunchTool(const std::string &mode, std::string_view arg) override;
+  bool LaunchToolWithProtoBuf(const mozc::commands::Output &output) override;
+
+ private:
+  // Initializes `request_` with the flag.
+  // This function should be called before EnsureSession.
+  void InitRequestForSvsJapanese(bool use_svs);
+  // Converts Output message from server to corresponding mozc_tool arguments
+  // If launch_tool_mode is not set or NO_TOOL is set or an invalid value is
+  // set, this function will return false and do nothing.
+  static bool TranslateProtoBufToMozcToolArg(
+      const mozc::commands::Output &output, std::string *mode);
+
+  bool EnsureSession();
+
+  enum ServerStatus {
+    SERVER_INVALID_SESSION,  // current session is not available
+    SERVER_OK,               // both server and session are health
+  };
+
+  // Initialize input filling id and preferences.
+  void InitInput(mozc::commands::Input *input) const;
+
+  bool CreateSession();
+  bool DeleteSession();
+  bool CallCommand(mozc::commands::Input::CommandType type);
+
+  // This method re-issue session id if it is not available.
+  bool EnsureCallCommand(mozc::commands::Input *input,
+                         mozc::commands::Output *output);
+
+  // The most primitive Call method
+  bool Call(const mozc::commands::Input &input, mozc::commands::Output *output);
+
+  uint64_t id_;
+  std::unique_ptr<mozc::commands::Request> request_;
+  ServerStatus server_status_ = SERVER_INVALID_SESSION;
+  // List of key combinations used in the direct input mode.
+  std::vector<mozc::KeyInformation> direct_mode_keys_;
+  mozc::commands::Capability client_capability_;
+};
+}  // namespace fcitx
+
+#endif
diff --git a/src/unix/fcitx5/mozc_engine.cc b/src/unix/fcitx5/mozc_engine.cc
new file mode 100644
index 0000000..b2e3f8e
--- /dev/null
+++ b/src/unix/fcitx5/mozc_engine.cc
@@ -0,0 +1,341 @@
+/*
+ * Copyright (C) 2017~2017 by CSSlayer
+ * wengxt@gmail.com
+ *
+ * This library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; see the file COPYING. If not,
+ * see <http://www.gnu.org/licenses/>.
+ */
+
+#include "unix/fcitx5/mozc_engine.h"
+
+#include <fcitx-config/iniparser.h>
+#include <fcitx-config/rawconfig.h>
+#include <fcitx-utils/log.h>
+#include <fcitx-utils/macros.h>
+#include <fcitx-utils/semver.h>
+#include <fcitx-utils/stringutils.h>
+#include <fcitx/action.h>
+#include <fcitx/addoninstance.h>
+#include <fcitx/event.h>
+#include <fcitx/inputcontext.h>
+#include <fcitx/inputcontextmanager.h>
+#include <fcitx/inputmethodmanager.h>
+#include <fcitx/instance.h>
+#include <fcitx/statusarea.h>
+#include <fcitx/userinterface.h>
+#include <fcitx/userinterfacemanager.h>
+
+#include <cstddef>
+#include <memory>
+#include <string>
+
+#include "base/init_mozc.h"
+#include "base/process.h"
+#include "protocol/commands.pb.h"
+#include "unix/fcitx5/i18nwrapper.h"
+#include "unix/fcitx5/mozc_client_interface.h"
+#include "unix/fcitx5/mozc_client_pool.h"
+#include "unix/fcitx5/mozc_response_parser.h"
+#include "unix/fcitx5/mozc_state.h"
+
+namespace fcitx {
+
+const struct CompositionModeInfo {
+  const char *name;
+  const char *icon;
+  const char *label;
+  const char *description;
+  mozc::commands::CompositionMode mode;
+} kPropCompositionModes[] = {
+    {
+        "mozc-mode-direct",
+        "fcitx_mozc_direct",
+        "A",
+        N_("Direct"),
+        mozc::commands::DIRECT,
+    },
+    {
+        "mozc-mode-hiragana",
+        "fcitx_mozc_hiragana",
+        "\xe3\x81\x82",  // Hiragana letter A in UTF-8.
+        N_("Hiragana"),
+        mozc::commands::HIRAGANA,
+    },
+    {
+        "mozc-mode-katakana_full",
+        "fcitx_mozc_katakana_full",
+        "\xe3\x82\xa2",  // Katakana letter A.
+        N_("Full Katakana"),
+        mozc::commands::FULL_KATAKANA,
+    },
+    {
+
+        "mozc-mode-alpha_half",
+        "fcitx_mozc_alpha_half",
+        "A",
+        N_("Half ASCII"),
+        mozc::commands::HALF_ASCII,
+    },
+    {
+
+        "mozc-mode-alpha_full",
+        "fcitx_mozc_alpha_full",
+        "\xef\xbc\xa1",  // Full width ASCII letter A.
+        N_("Full ASCII"),
+        mozc::commands::FULL_ASCII,
+    },
+    {
+        "mozc-mode-katakana_half",
+        "fcitx_mozc_katakana_half",
+        "\xef\xbd\xb1",  // Half width Katakana letter A.
+        N_("Half Katakana"),
+        mozc::commands::HALF_KATAKANA,
+    },
+};
+const size_t kNumCompositionModes = FCITX_ARRAY_SIZE(kPropCompositionModes);
+
+MozcModeSubAction::MozcModeSubAction(MozcEngine *engine,
+                                     mozc::commands::CompositionMode mode)
+    : engine_(engine), mode_(mode) {
+  setShortText(_(kPropCompositionModes[mode].description));
+  setLongText(_(kPropCompositionModes[mode].description));
+  setIcon(kPropCompositionModes[mode].icon);
+  setCheckable(true);
+}
+
+bool MozcModeSubAction::isChecked(InputContext *ic) const {
+  auto *mozc_state = engine_->mozcState(ic);
+  return mozc_state->GetCompositionMode() == mode_;
+}
+
+void MozcModeSubAction::activate(InputContext *ic) {
+  auto *mozc_state = engine_->mozcState(ic);
+  mozc_state->SendCompositionMode(mode_);
+}
+
+// This array must correspond with the CompositionMode enum in the
+// mozc/session/command.proto file.
+static_assert(mozc::commands::NUM_OF_COMPOSITIONS == kNumCompositionModes,
+              "number of modes must match");
+
+Instance *Init(Instance *instance) {
+  int argc = 1;
+  char argv0[] = "fcitx_mozc";
+  char *_argv[] = {argv0};
+  char **argv = _argv;
+  mozc::InitMozc(argv[0], &argc, &argv);
+  return instance;
+}
+
+MozcEngine::MozcEngine(Instance *instance)
+    : instance_(Init(instance)),
+      parser_(std::make_unique<MozcResponseParser>(this)),
+      client_(createClient()),
+      factory_([this](InputContext &ic) { return new MozcState(&ic, this); }) {
+  pool_ = std::make_unique<MozcClientPool>(GetSharedStatePolicy());
+  for (auto command :
+       {mozc::commands::DIRECT, mozc::commands::HIRAGANA,
+        mozc::commands::FULL_KATAKANA, mozc::commands::FULL_ASCII,
+        mozc::commands::HALF_ASCII, mozc::commands::HALF_KATAKANA}) {
+    modeActions_.push_back(std::make_unique<MozcModeSubAction>(this, command));
+  }
+
+  instance_->inputContextManager().registerProperty("mozcState", &factory_);
+  instance_->userInterfaceManager().registerAction("mozc-tool", &toolAction_);
+  toolAction_.setShortText(_("Mozc Settings"));
+  toolAction_.setLongText(_("Mozc Settings"));
+  toolAction_.setIcon("fcitx_mozc_tool");
+
+  int i = 0;
+  for (auto &modeAction : modeActions_) {
+    instance_->userInterfaceManager().registerAction(
+        kPropCompositionModes[i].name, modeAction.get());
+    toolMenu_.addAction(modeAction.get());
+    i++;
+  }
+
+  separatorAction_.setSeparator(true);
+  instance_->userInterfaceManager().registerAction("mozc-separator",
+                                                   &separatorAction_);
+
+  SemanticVersion version;
+  version.setMajor(5);
+  version.setMinor(0);
+  version.setPatch(22);
+  // Where we fix the support for separator
+  if (auto fcitxVersion = SemanticVersion::parse(Instance::version());
+      fcitxVersion && *fcitxVersion >= version) {
+    toolMenu_.addAction(&separatorAction_);
+  }
+
+  instance_->userInterfaceManager().registerAction("mozc-tool-config",
+                                                   &configToolAction_);
+  configToolAction_.setShortText(_("Configuration Tool"));
+  configToolAction_.setIcon("fcitx_mozc_tool");
+  configToolAction_.connect<SimpleAction::Activated>([](InputContext *) {
+    mozc::Process::SpawnMozcProcess("mozc_tool", "--mode=config_dialog");
+  });
+
+  instance_->userInterfaceManager().registerAction("mozc-tool-dict",
+                                                   &dictionaryToolAction_);
+  dictionaryToolAction_.setShortText(_("Dictionary Tool"));
+  dictionaryToolAction_.setIcon("fcitx_mozc_dictionary");
+  dictionaryToolAction_.connect<SimpleAction::Activated>([](InputContext *) {
+    mozc::Process::SpawnMozcProcess("mozc_tool", "--mode=dictionary_tool");
+  });
+
+  instance_->userInterfaceManager().registerAction("mozc-tool-add",
+                                                   &addWordAction_);
+  addWordAction_.setShortText(_("Add Word"));
+  addWordAction_.connect<SimpleAction::Activated>([](InputContext *) {
+    mozc::Process::SpawnMozcProcess("mozc_tool", "--mode=word_register_dialog");
+  });
+
+  instance_->userInterfaceManager().registerAction("mozc-tool-about",
+                                                   &aboutAction_);
+  aboutAction_.setShortText(_("About Mozc"));
+  aboutAction_.connect<SimpleAction::Activated>([](InputContext *) {
+    mozc::Process::SpawnMozcProcess("mozc_tool", "--mode=about_dialog");
+  });
+
+  toolMenu_.addAction(&configToolAction_);
+  toolMenu_.addAction(&dictionaryToolAction_);
+  toolMenu_.addAction(&addWordAction_);
+  toolMenu_.addAction(&aboutAction_);
+
+  toolAction_.setMenu(&toolMenu_);
+
+  globalConfigReloadHandle_ =
+      instance_->watchEvent(EventType::GlobalConfigReloaded,
+                            EventWatcherPhase::Default, [this](Event &) {
+                              ResetClientPool();
+                              return true;
+                            });
+
+  reloadConfig();
+}
+
+MozcEngine::~MozcEngine() {}
+
+void MozcEngine::setConfig(const RawConfig &config) {
+  config_.load(config, true);
+  safeSaveAsIni(config_, "conf/mozc.conf");
+  ResetClientPool();
+}
+
+void MozcEngine::reloadConfig() {
+  readAsIni(config_, "conf/mozc.conf");
+  ResetClientPool();
+}
+void MozcEngine::activate(const fcitx::InputMethodEntry & /*entry*/,
+                          fcitx::InputContextEvent &event) {
+  if (client_) {
+    client_->EnsureConnection();
+  }
+  auto *ic = event.inputContext();
+  auto *mozc_state = mozcState(ic);
+  mozc_state->FocusIn();
+  ic->statusArea().addAction(StatusGroup::InputMethod, &toolAction_);
+}
+void MozcEngine::deactivate(const fcitx::InputMethodEntry & /*entry*/,
+                            fcitx::InputContextEvent &event) {
+  auto *ic = event.inputContext();
+  deactivating_ = true;
+  auto *mozc_state = mozcState(ic);
+  mozc_state->FocusOut(event);
+  deactivating_ = false;
+}
+void MozcEngine::keyEvent(const InputMethodEntry &entry, KeyEvent &event) {
+  auto *mozc_state = mozcState(event.inputContext());
+
+  const auto &group = instance_->inputMethodManager().currentGroup();
+  std::string layout = group.layoutFor(entry.uniqueName());
+  if (layout.empty()) {
+    layout = group.defaultLayout();
+  }
+
+  const bool isJP = (layout == "jp" || stringutils::startsWith(layout, "jp-"));
+
+  if (mozc_state->ProcessKeyEvent(event.rawKey().sym(), event.rawKey().code(),
+                                  event.rawKey().states(), isJP,
+                                  event.isRelease())) {
+    event.filterAndAccept();
+  }
+}
+
+void MozcEngine::reset(const InputMethodEntry & /*entry*/,
+                       InputContextEvent &event) {
+  auto *mozc_state = mozcState(event.inputContext());
+  mozc_state->Reset();
+}
+
+void MozcEngine::save() {
+  if (client_ == nullptr) {
+    return;
+  }
+  client_->SyncData();
+}
+
+std::string MozcEngine::subMode(const fcitx::InputMethodEntry & /*entry*/,
+                                fcitx::InputContext &ic) {
+  auto *mozc_state = mozcState(&ic);
+  return _(kPropCompositionModes[mozc_state->GetCompositionMode()].description);
+}
+
+std::string MozcEngine::subModeIconImpl(
+    const fcitx::InputMethodEntry & /*unused*/, fcitx::InputContext &ic) {
+  auto *mozc_state = mozcState(&ic);
+  return _(kPropCompositionModes[mozc_state->GetCompositionMode()].icon);
+}
+
+MozcState *MozcEngine::mozcState(InputContext *ic) {
+  return ic->propertyFor(&factory_);
+}
+
+void MozcEngine::compositionModeUpdated(InputContext *ic) {
+  for (const auto &modeAction : modeActions_) {
+    modeAction->update(ic);
+  }
+  ic->updateUserInterface(UserInterfaceComponent::StatusArea);
+}
+
+AddonInstance *MozcEngine::clipboardAddon() { return clipboard(); }
+
+void MozcEngine::ResetClientPool() {
+  if (pool_->policy() != GetSharedStatePolicy()) {
+    instance_->inputContextManager().foreach ([this](InputContext *ic) {
+      if (auto *state = this->mozcState(ic)) {
+        state->ReleaseClient();
+      }
+      return true;
+    });
+    pool_->setPolicy(GetSharedStatePolicy());
+  }
+}
+
+PropertyPropagatePolicy MozcEngine::GetSharedStatePolicy() {
+  switch (*config_.sharedStatePolicy) {
+    case SharedStatePolicy::All:
+      return PropertyPropagatePolicy::All;
+    case SharedStatePolicy::Program:
+      return PropertyPropagatePolicy::Program;
+    case SharedStatePolicy::No:
+      return PropertyPropagatePolicy::No;
+    case SharedStatePolicy::FollowGlobalConfig:
+    default:
+      return instance_->globalConfig().shareInputState();
+  }
+}
+
+}  // namespace fcitx
diff --git a/src/unix/fcitx5/mozc_engine.h b/src/unix/fcitx5/mozc_engine.h
new file mode 100644
index 0000000..1f06934
--- /dev/null
+++ b/src/unix/fcitx5/mozc_engine.h
@@ -0,0 +1,180 @@
+/*
+ * Copyright (C) 2017~2017 by CSSlayer
+ * wengxt@gmail.com
+ *
+ * This library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; see the file COPYING. If not,
+ * see <http://www.gnu.org/licenses/>.
+ */
+#ifndef _FCITX_UNIX_FCITX5_MOZC_ENGINE_H_
+#define _FCITX_UNIX_FCITX5_MOZC_ENGINE_H_
+
+#include <fcitx-config/configuration.h>
+#include <fcitx-config/enum.h>
+#include <fcitx-config/option.h>
+#include <fcitx-config/rawconfig.h>
+#include <fcitx-utils/handlertable.h>
+#include <fcitx-utils/key.h>
+#include <fcitx-utils/stringutils.h>
+#include <fcitx/action.h>
+#include <fcitx/addonfactory.h>
+#include <fcitx/addoninstance.h>
+#include <fcitx/addonmanager.h>
+#include <fcitx/event.h>
+#include <fcitx/inputcontextmanager.h>
+#include <fcitx/inputcontextproperty.h>
+#include <fcitx/inputmethodengine.h>
+#include <fcitx/instance.h>
+#include <fcitx/menu.h>
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/file_util.h"
+#include "base/system_util.h"
+#include "protocol/commands.pb.h"
+#include "unix/fcitx5/i18nwrapper.h"
+#include "unix/fcitx5/mozc_client_interface.h"
+#include "unix/fcitx5/mozc_client_pool.h"
+#include "unix/fcitx5/mozc_state.h"
+
+namespace fcitx {
+
+class MozcResponseParser;
+class MozcEngine;
+
+enum class ExpandMode { Always, OnFocus, Hotkey };
+
+enum class SharedStatePolicy { FollowGlobalConfig, All, Program, No };
+
+using CompositionMode = mozc::commands::CompositionMode;
+
+FCITX_CONFIG_ENUM_NAME_WITH_I18N(SharedStatePolicy,
+                                 N_("Follow Global Configuration"), N_("All"),
+                                 N_("Program"), N_("No"));
+
+FCITX_CONFIG_ENUM_NAME_WITH_I18N(ExpandMode, N_("Always"), N_("On Focus"),
+                                 N_("Hotkey"));
+
+FCITX_CONFIG_ENUM_NAME_WITH_I18N(CompositionMode, N_("Direct"), N_("Hiragana"),
+                                 N_("Full Katakana"), N_("Half ASCII"),
+                                 N_("Full ASCII"), N_("Half Katakana"));
+
+FCITX_CONFIGURATION(
+    MozcEngineConfig, const std::string toolPath_ = mozc::FileUtil::JoinPath(
+                          mozc::SystemUtil::GetServerDirectory(), "mozc_tool");
+    std::string toolCommand(const char *arg) {
+      return stringutils::concat(toolPath_, " ", arg);
+    }
+
+    OptionWithAnnotation<CompositionMode, CompositionModeI18NAnnotation>
+        initialMode{this, "InitialMode", _("Initial Mode"),
+                    mozc::commands::HIRAGANA};
+    Option<SharedStatePolicy> sharedStatePolicy{
+        this, "InputState", _("Shared Input State"),
+        SharedStatePolicy::FollowGlobalConfig};
+    Option<bool> verticalList{this, "Vertical", _("Vertical candidate list"),
+                              true};
+    OptionWithAnnotation<ExpandMode, ExpandModeI18NAnnotation> expandMode{
+        this, "ExpandMode",
+        _("Expand Usage (Requires vertical candidate list)"),
+        ExpandMode::OnFocus};
+    Option<bool> preeditCursorPositionAtBeginning{
+        this, "PreeditCursorPositionAtBeginning",
+        _("Fix embedded preedit cursor at the beginning of the preedit"),
+        false};
+    Option<Key> expand{this, "ExpandKey", _("Hotkey to expand usage"),
+                       Key("Control+Alt+H")};
+
+    ExternalOption configTool{this, "ConfigTool", _("Configuration Tool"),
+                              toolCommand("--mode=config_dialog")};
+    ExternalOption dictTool{this, "Dictionary Tool", _("Dictionary Tool"),
+                            toolCommand("--mode=dictionary_tool")};
+    ExternalOption addTool{this, "Add Word", _("Add Word"),
+                           toolCommand("--mode=word_register_dialog")};
+    ExternalOption aboutTool{this, "About Mozc", _("About Mozc"),
+                             toolCommand("--mode=about_dialog")};);
+
+class MozcModeSubAction : public SimpleAction {
+ public:
+  MozcModeSubAction(MozcEngine *engine, mozc::commands::CompositionMode mode);
+  bool isChecked(fcitx::InputContext *ic) const override;
+  void activate(fcitx::InputContext *ic) override;
+
+ private:
+  MozcEngine *engine_;
+  mozc::commands::CompositionMode mode_;
+};
+
+class MozcEngine final : public InputMethodEngineV2 {
+ public:
+  MozcEngine(Instance *instance);
+  ~MozcEngine();
+  Instance *instance() { return instance_; }
+  void activate(const InputMethodEntry &entry,
+                InputContextEvent &event) override;
+  void deactivate(const fcitx::InputMethodEntry &entry,
+                  fcitx::InputContextEvent &event) override;
+  void keyEvent(const InputMethodEntry &entry, KeyEvent &keyEvent) override;
+  void reloadConfig() override;
+  void reset(const InputMethodEntry &entry, InputContextEvent &event) override;
+  void save() override;
+  std::string subMode(const fcitx::InputMethodEntry & /*entry*/,
+                      fcitx::InputContext &ic) override;
+  std::string subModeIconImpl(const InputMethodEntry &entry,
+                              InputContext &ic) override;
+
+  const Configuration *getConfig() const override { return &config_; }
+  void setConfig(const RawConfig &config) override;
+
+  auto &config() const { return config_; }
+  auto factory() const { return &factory_; }
+
+  MozcState *mozcState(InputContext *ic);
+  AddonInstance *clipboardAddon();
+
+  void compositionModeUpdated(InputContext *ic);
+
+  void SyncData(bool force);
+
+  bool deactivating() const { return deactivating_; }
+  auto *parser() const { return parser_.get(); }
+  auto *pool() const { return pool_.get(); }
+
+ private:
+  void ResetClientPool();
+  PropertyPropagatePolicy GetSharedStatePolicy();
+
+  Instance *instance_;
+  const std::unique_ptr<MozcResponseParser> parser_;
+  std::unique_ptr<MozcClientInterface> client_;
+  std::unique_ptr<MozcClientPool> pool_;
+  FactoryFor<MozcState> factory_;
+  SimpleAction toolAction_;
+  std::vector<std::unique_ptr<MozcModeSubAction>> modeActions_;
+  std::unique_ptr<HandlerTableEntry<EventHandler>> globalConfigReloadHandle_;
+
+  SimpleAction configToolAction_, dictionaryToolAction_, addWordAction_,
+      aboutAction_;
+  SimpleAction separatorAction_;
+  Menu toolMenu_;
+  MozcEngineConfig config_;
+  bool deactivating_ = false;
+
+  FCITX_ADDON_DEPENDENCY_LOADER(clipboard, instance_->addonManager());
+};
+
+}  // namespace fcitx
+
+#endif  // _FCITX_UNIX_FCITX5_MOZC_ENGINE_H_
diff --git a/src/unix/fcitx5/mozc_engine_factory.cc b/src/unix/fcitx5/mozc_engine_factory.cc
new file mode 100644
index 0000000..69bf94b
--- /dev/null
+++ b/src/unix/fcitx5/mozc_engine_factory.cc
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2020~2020 by CSSlayer
+ * wengxt@gmail.com
+ *
+ * This library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; see the file COPYING. If not,
+ * see <http://www.gnu.org/licenses/>.
+ */
+#include <fcitx-utils/fs.h>
+#include <fcitx-utils/misc.h>
+#include <fcitx-utils/stringutils.h>
+#include <fcitx/addonfactory.h>
+#include <fcitx/addoninstance.h>
+
+#include <cstdlib>
+#include <string_view>
+
+#include "base/system_util.h"
+#include "mozc_engine.h"
+#include "unix/fcitx5/i18nwrapper.h"
+
+namespace fcitx {
+class MozcEngineFactory : public AddonFactory {
+ public:
+  AddonInstance *create(AddonManager *manager) override {
+    // We don't have a direct way to detect, so we simply try.
+    auto baseDirectory = makeUniqueCPtr(
+        realpath(mozc::SystemUtil::GetServerDirectory().data(), nullptr));
+    int numberOfSlash = 0;
+    if (baseDirectory) {
+      std::string_view view(baseDirectory.get());
+      for (auto c : view) {
+        if (c == '/') {
+          numberOfSlash += 1;
+        }
+      }
+      if (view.empty()) {
+        baseDirectory.reset();
+      }
+    }
+
+    // Make sure we don't deadloop.
+    while (baseDirectory && numberOfSlash >= 0) {
+      auto path = stringutils::joinPath(baseDirectory.get(), "share/locale");
+      if (fs::isdir(path)) {
+        registerDomain("fcitx5-mozc", path.data());
+      }
+      baseDirectory = cdUp(baseDirectory.get());
+      if (baseDirectory && std::string_view(baseDirectory.get()).empty()) {
+        baseDirectory.reset();
+      }
+      numberOfSlash -= 1;
+    }
+    return new MozcEngine(manager->instance());
+  }
+
+ private:
+  UniqueCPtr<char> cdUp(const char *path) {
+    return makeUniqueCPtr(
+        realpath(stringutils::joinPath(path, "..").data(), nullptr));
+  }
+};
+}  // namespace fcitx
+
+#ifdef FCITX_ADDON_FACTORY_V2
+FCITX_ADDON_FACTORY_V2(mozc, fcitx::MozcEngineFactory)
+#else
+FCITX_ADDON_FACTORY(fcitx::MozcEngineFactory)
+#endif
diff --git a/src/unix/fcitx5/mozc_ipc_client.cc b/src/unix/fcitx5/mozc_ipc_client.cc
new file mode 100644
index 0000000..283187a
--- /dev/null
+++ b/src/unix/fcitx5/mozc_ipc_client.cc
@@ -0,0 +1,56 @@
+#include "unix/fcitx5/mozc_ipc_client.h"
+
+#include <memory>
+#include <string>
+#include <string_view>
+
+#include "client/client.h"
+#include "protocol/commands.pb.h"
+#include "protocol/config.pb.h"
+#include "unix/fcitx5/mozc_client_interface.h"
+
+namespace fcitx {
+
+MozcIPCClient::MozcIPCClient()
+    : client_(mozc::client::ClientFactory::NewClient()) {}
+
+MozcIPCClient::~MozcIPCClient() {}
+
+bool MozcIPCClient::EnsureConnection() { return client_->EnsureConnection(); }
+
+bool MozcIPCClient::SendKeyWithContext(const mozc::commands::KeyEvent &key,
+                                       const mozc::commands::Context &context,
+                                       mozc::commands::Output *output) {
+  return client_->SendKeyWithContext(key, context, output);
+}
+
+bool MozcIPCClient::SendCommandWithContext(
+    const mozc::commands::SessionCommand &command,
+    const mozc::commands::Context &context, mozc::commands::Output *output) {
+  return client_->SendCommandWithContext(command, context, output);
+}
+bool MozcIPCClient::IsDirectModeCommand(
+    const mozc::commands::KeyEvent &key) const {
+  return client_->IsDirectModeCommand(key);
+}
+bool MozcIPCClient::GetConfig(mozc::config::Config *config) {
+  return client_->GetConfig(config);
+}
+void MozcIPCClient::set_client_capability(
+    const mozc::commands::Capability &capability) {
+  return client_->set_client_capability(capability);
+}
+bool MozcIPCClient::SyncData() { return client_->SyncData(); }
+bool MozcIPCClient::LaunchTool(const std::string &mode, std::string_view arg) {
+  return client_->LaunchTool(mode, arg);
+}
+bool MozcIPCClient::LaunchToolWithProtoBuf(
+    const mozc::commands::Output &output) {
+  return client_->LaunchToolWithProtoBuf(output);
+}
+
+std::unique_ptr<MozcClientInterface> createClient() {
+  return std::make_unique<MozcIPCClient>();
+}
+
+}  // namespace fcitx
diff --git a/src/unix/fcitx5/mozc_ipc_client.h b/src/unix/fcitx5/mozc_ipc_client.h
new file mode 100644
index 0000000..b91b355
--- /dev/null
+++ b/src/unix/fcitx5/mozc_ipc_client.h
@@ -0,0 +1,43 @@
+#ifndef UNIX_FCITX5_MOZC_IPC_CLIENT_H_
+#define UNIX_FCITX5_MOZC_IPC_CLIENT_H_
+
+#include <memory>
+#include <string>
+#include <string_view>
+
+#include "client/client_interface.h"
+#include "protocol/commands.pb.h"
+#include "protocol/config.pb.h"
+#include "unix/fcitx5/mozc_client_interface.h"
+
+namespace fcitx {
+
+class MozcIPCClient : public MozcClientInterface {
+ public:
+  MozcIPCClient();
+
+  MozcIPCClient(MozcIPCClient &&) = delete;
+
+  ~MozcIPCClient();
+
+  bool EnsureConnection() override;
+  bool SendKeyWithContext(const mozc::commands::KeyEvent &key,
+                          const mozc::commands::Context &context,
+                          mozc::commands::Output *output) override;
+  bool SendCommandWithContext(const mozc::commands::SessionCommand &command,
+                              const mozc::commands::Context &context,
+                              mozc::commands::Output *output) override;
+  bool IsDirectModeCommand(const mozc::commands::KeyEvent &key) const override;
+  bool GetConfig(mozc::config::Config *config) override;
+  void set_client_capability(
+      const mozc::commands::Capability &capability) override;
+  bool SyncData() override;
+  bool LaunchTool(const std::string &mode, std::string_view arg) override;
+  bool LaunchToolWithProtoBuf(const mozc::commands::Output &output) override;
+
+ private:
+  std::unique_ptr<mozc::client::ClientInterface> client_;
+};
+
+}  // namespace fcitx
+#endif
diff --git a/src/unix/fcitx5/mozc_response_parser.cc b/src/unix/fcitx5/mozc_response_parser.cc
new file mode 100644
index 0000000..e989948
--- /dev/null
+++ b/src/unix/fcitx5/mozc_response_parser.cc
@@ -0,0 +1,498 @@
+// Copyright 2010-2012, Google Inc.
+// Copyright 2012~2013, Weng Xuetian <wengxt@gmail.com>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "unix/fcitx5/mozc_response_parser.h"
+
+#include <fcitx-utils/stringutils.h>
+#include <fcitx-utils/textformatflags.h>
+#include <fcitx-utils/utf8.h>
+#include <fcitx/candidatelist.h>
+#include <fcitx/inputcontext.h>
+#include <fcitx/inputpanel.h>
+#include <fcitx/text.h>
+
+#include <cstddef>
+#include <cstdint>
+#include <cstdlib>
+#include <map>
+#include <memory>
+#include <stdexcept>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "absl/log/check.h"
+#include "absl/log/log.h"
+#include "base/vlog.h"
+#include "protocol/candidate_window.pb.h"
+#include "protocol/commands.pb.h"
+#include "unix/fcitx5/i18nwrapper.h"
+#include "unix/fcitx5/mozc_engine.h"
+#include "unix/fcitx5/mozc_state.h"
+#include "unix/fcitx5/surrounding_text_util.h"
+
+namespace fcitx {
+
+namespace {
+
+// Returns a position that determines a preedit cursor position _AND_ top-left
+// position of a candidate window. Note that we can't set these two positions
+// independently. That's a SCIM's limitation.
+uint32_t GetCursorPosition(const mozc::commands::Output &response) {
+  if (!response.has_preedit()) {
+    return 0;
+  }
+  if (response.preedit().has_highlighted_position()) {
+    return response.preedit().highlighted_position();
+  }
+  return response.preedit().cursor();
+}
+
+std::string CreateDescriptionString(const std::string &description) {
+  return " [" + description + "]";
+}
+
+class MozcCandidateWord final : public CandidateWord {
+ public:
+  MozcCandidateWord(int id, std::string text, MozcEngine *engine)
+      : CandidateWord(Text(std::move(text))), id_(id), engine_(engine) {}
+
+  void select(InputContext *inputContext) const override {
+    MozcState *mozc_state = engine_->mozcState(inputContext);
+    mozc_state->SelectCandidate(id_);
+  }
+
+ private:
+  int id_;
+  MozcEngine *engine_;
+};
+
+class MozcCandidateList final : public CandidateList,
+                                public PageableCandidateList {
+ public:
+  MozcCandidateList(const mozc::commands::CandidateWindow &candidates,
+                    InputContext *ic, MozcEngine *engine, bool use_annotation)
+      : ic_(ic), engine_(engine) {
+    auto *state = engine_->mozcState(ic);
+    setPageable(this);
+    bool index_visible = false;
+    if (candidates.has_footer()) {
+      const auto &footer = candidates.footer();
+      index_visible = footer.has_index_visible() && footer.index_visible();
+    }
+
+    if (candidates.candidate_size() > 0) {
+      if (candidates.candidate(0).index() > 0) {
+        hasPrev_ = true;
+      }
+      if (candidates.candidate(candidates.candidate_size() - 1).index() + 1 <
+          candidates.size()) {
+        hasNext_ = true;
+      }
+    }
+    const bool isVertical = *engine_->config().verticalList;
+    // candidates.direction is never used, we just override it with our
+    // configuration.
+    layout_ = isVertical ? CandidateLayoutHint::Vertical
+                         : CandidateLayoutHint::Horizontal;
+
+    int focused_index = -1;
+    cursor_ = -1;
+    if (candidates.has_focused_index()) {
+      focused_index = candidates.focused_index();
+    }
+
+    std::map<int32_t, std::pair<std::string, std::string>> usage_map;
+    if (candidates.has_usages()) {
+      const mozc::commands::InformationList &usages = candidates.usages();
+      for (size_t i = 0; i < usages.information().size(); ++i) {
+        const mozc::commands::Information &information = usages.information(i);
+        if (!information.has_id() || !information.has_description()) {
+          continue;
+        }
+        usage_map[information.id()].first = information.title();
+        usage_map[information.id()].second = information.description();
+      }
+    }
+
+    labels_.reserve(candidates.candidate_size());
+
+    for (int i = 0; i < candidates.candidate_size(); ++i) {
+      const mozc::commands::CandidateWindow::Candidate &candidate =
+          candidates.candidate(i);
+      const uint32_t index = candidate.index();
+
+      std::string value;
+      if (use_annotation && candidate.has_annotation() &&
+          candidate.annotation().has_prefix()) {
+        value = candidate.annotation().prefix();
+      }
+      value += candidate.value();
+      if (use_annotation && candidate.has_annotation() &&
+          candidate.annotation().has_suffix()) {
+        value += candidate.annotation().suffix();
+      }
+      if (use_annotation && candidate.has_annotation() &&
+          candidate.annotation().has_description()) {
+        // Display descriptions ([HALF][KATAKANA], [GREEK], [Black square],
+        // etc).
+        value += CreateDescriptionString(candidate.annotation().description());
+      }
+
+      const bool is_current =
+          candidates.has_focused_index() && index == focused_index;
+      if (is_current) {
+        cursor_ = i;
+      }
+      if (use_annotation && candidate.has_information_id()) {
+        auto it = usage_map.find(candidate.information_id());
+        if (it != usage_map.end()) {
+          if (*engine_->config().expandMode == ExpandMode::Always ||
+              (*engine_->config().expandMode == ExpandMode::OnFocus &&
+               is_current)) {
+            if (it->second.first != candidate.value()) {
+              value.append("\n").append(it->second.first);
+            }
+            value.append("\n").append(it->second.second);
+          } else if (*engine_->config().expandMode == ExpandMode::Hotkey &&
+                     is_current && engine_->config().expand->isValid()) {
+            state->SetUsage(it->second.first, it->second.second);
+            // We don't have a good library option for this, just do the simple
+            // replace. absl's runtime parsed format string is too copmlex.
+            std::string msg = _("Press %s to show usages.");
+            msg = stringutils::replaceAll(msg, "%s",
+                                          engine_->config().expand->toString());
+            value += CreateDescriptionString(msg);
+          }
+        }
+      }
+
+      if (candidate.has_annotation() && candidate.annotation().has_shortcut()) {
+        labels_.emplace_back(candidate.annotation().shortcut() + ". ");
+      } else if (index_visible) {
+        labels_.emplace_back(std::to_string(i + 1) + ". ");
+      } else {
+        labels_.emplace_back();
+      }
+
+      int32_t id = kBadCandidateId;
+      if (candidate.has_id()) {
+        id = candidate.id();
+        DCHECK_NE(kBadCandidateId, id) << "Unexpected id is passed.";
+      }
+      candidateWords_.emplace_back(
+          std::make_unique<MozcCandidateWord>(id, value, engine));
+    }
+  }
+
+  const Text &label(int idx) const override {
+    checkIndex(idx);
+    return labels_[idx];
+  }
+
+  const CandidateWord &candidate(int idx) const override {
+    checkIndex(idx);
+    return *candidateWords_[idx];
+  }
+  int size() const override { return candidateWords_.size(); }
+
+  int cursorIndex() const override { return cursor_; }
+
+  CandidateLayoutHint layoutHint() const override { return layout_; }
+
+  bool hasPrev() const override { return hasPrev_; }
+  bool hasNext() const override { return hasNext_; }
+  void prev() override {
+    auto *mozc_state = engine_->mozcState(ic_);
+    mozc_state->Paging(true);
+  }
+  void next() override {
+    auto *mozc_state = engine_->mozcState(ic_);
+    mozc_state->Paging(false);
+  }
+
+  bool usedNextBefore() const override { return true; }
+
+ private:
+  void checkIndex(int idx) const {
+    if (idx < 0 && idx >= size()) {
+      throw std::invalid_argument("invalid index");
+    }
+  }
+
+  InputContext *ic_;
+  MozcEngine *engine_;
+  std::vector<Text> labels_;
+  bool hasPrev_ = false;
+  bool hasNext_ = false;
+  CandidateLayoutHint layout_ = CandidateLayoutHint::Vertical;
+  int cursor_ = -1;
+  std::vector<std::unique_ptr<CandidateWord>> candidateWords_;
+};
+
+}  // namespace
+
+MozcResponseParser::MozcResponseParser(MozcEngine *engine) : engine_(engine) {}
+
+MozcResponseParser::~MozcResponseParser() {}
+
+void MozcResponseParser::UpdateDeletionRange(
+    const mozc::commands::Output &response, InputContext *ic) const {
+  if (response.has_deletion_range() &&
+      response.deletion_range().offset() <= 0 &&
+      response.deletion_range().offset() + response.deletion_range().length() >=
+          0) {
+    ic->deleteSurroundingText(response.deletion_range().offset(),
+                              response.deletion_range().length());
+  }
+}
+
+void MozcResponseParser::LaunchTool(const mozc::commands::Output &response,
+                                    InputContext *ic) const {
+  if (response.has_launch_tool_mode()) {
+    auto *mozc_state = engine_->mozcState(ic);
+    mozc_state->GetClient()->LaunchToolWithProtoBuf(response);
+  }
+}
+
+void MozcResponseParser::ExecuteCallback(const mozc::commands::Output &response,
+                                         InputContext *ic) const {
+  if (!response.has_callback()) {
+    return;
+  }
+
+  if (!response.callback().has_session_command()) {
+    LOG(ERROR) << "callback does not have session_command";
+    return;
+  }
+
+  const mozc::commands::SessionCommand &callback_command =
+      response.callback().session_command();
+
+  if (!callback_command.has_type()) {
+    LOG(ERROR) << "callback_command has no type";
+    return;
+  }
+
+  mozc::commands::SessionCommand session_command;
+  session_command.set_type(callback_command.type());
+
+  // TODO(nona): Make a function to handle CONVERT_REVERSE.
+  // Used by CONVERT_REVERSE and/or UNDO
+  // This value represents how many characters are selected as a relative
+  // distance of characters. Positive value represents forward text selection
+  // and negative value represents backword text selection.
+  // Note that you should not allow 0x80000000 for |relative_selected_length|
+  // because you cannot safely use |-relative_selected_length| nor
+  // |abs(relative_selected_length)| in this case due to integer overflow.
+  SurroundingTextInfo surrounding_text_info;
+
+  switch (callback_command.type()) {
+    case mozc::commands::SessionCommand::UNDO:
+      break;
+    case mozc::commands::SessionCommand::CONVERT_REVERSE: {
+      if (!GetSurroundingText(ic, &surrounding_text_info,
+                              engine_->clipboardAddon())) {
+        return;
+      }
+
+      session_command.set_text(surrounding_text_info.selection_text);
+      break;
+    }
+    default:
+      return;
+  }
+
+  auto *mozc_state = engine_->mozcState(ic);
+  mozc::commands::Output new_output;
+  if (!mozc_state->SendCommand(session_command, &new_output)) {
+    LOG(ERROR) << "Callback Command Failed";
+    return;
+  }
+
+  if (callback_command.type() ==
+      mozc::commands::SessionCommand::CONVERT_REVERSE) {
+    // We need to remove selected text as a first step of reconversion.
+    mozc::commands::DeletionRange *range = new_output.mutable_deletion_range();
+    // Use DeletionRange field to remove the selected text.
+    // For forward selection (that is, |relative_selected_length > 0|), the
+    // offset should be a negative value to delete preceding text.
+    // For backward selection (that is, |relative_selected_length < 0|),
+    // IBus and/or some applications seem to expect |offset == 0| somehow.
+    const int32_t offset =
+        surrounding_text_info.relative_selected_length > 0
+            ? -surrounding_text_info
+                   .relative_selected_length  // forward selection
+            : 0;                              // backward selection
+    range->set_offset(offset);
+    range->set_length(abs(surrounding_text_info.relative_selected_length));
+  }
+
+  MOZC_VLOG(1) << "New output" << new_output.DebugString();
+
+  ParseResponse(new_output, ic);
+}
+
+bool MozcResponseParser::ParseResponse(const mozc::commands::Output &response,
+                                       InputContext *ic) const {
+  auto *mozc_state = engine_->mozcState(ic);
+  mozc_state->SetUsage("", "");
+
+  UpdateDeletionRange(response, ic);
+
+  // We should check the mode field first since the response for a
+  // SWITCH_INPUT_MODE request only contains mode and id fields.
+  if (response.has_mode()) {
+    mozc_state->SetCompositionMode(
+        response.mode(), !engine_->deactivating() &&
+                             engine_->instance()->inputMethod(ic) == "mozc");
+  }
+
+  if (!response.consumed()) {
+    // The key was not consumed by Mozc.
+    return false;
+  }
+
+  if (response.has_result()) {
+    const mozc::commands::Result &result = response.result();
+    ParseResult(result, ic);
+  }
+
+  // First, determine the cursor position.
+  if (response.has_preedit()) {
+    const mozc::commands::Preedit &preedit = response.preedit();
+    ParsePreedit(preedit, GetCursorPosition(response), ic);
+  }
+
+  // Then show the candidate window.
+  if (response.has_candidate_window()) {
+    const mozc::commands::CandidateWindow &candidates =
+        response.candidate_window();
+    ParseCandidates(candidates, ic);
+  }
+
+  if (response.has_url()) {
+    const std::string &url = response.url();
+    mozc_state->SetUrl(url);
+  }
+  LaunchTool(response, ic);
+  ExecuteCallback(response, ic);
+
+  return true;  // mozc consumed the key.
+}
+
+void MozcResponseParser::ParseResult(const mozc::commands::Result &result,
+                                     InputContext *ic) const {
+  auto *mozc_state = engine_->mozcState(ic);
+  switch (result.type()) {
+    case mozc::commands::Result::NONE: {
+      mozc_state->SetAuxString("No result");  // not a fatal error.
+      break;
+    }
+    case mozc::commands::Result::STRING: {
+      mozc_state->SetResultString(result.value());
+      break;
+    }
+  }
+}
+
+void MozcResponseParser::ParseCandidates(
+    const mozc::commands::CandidateWindow &candidates, InputContext *ic) const {
+  auto *mozc_state = engine_->mozcState(ic);
+  const mozc::commands::Footer &footer = candidates.footer();
+  if (candidates.has_footer()) {
+    std::string auxString;
+    if (footer.has_label()) {
+      // TODO(yusukes,mozc-team): label() is not localized. Currently, it's
+      // always
+      // written in Japanese (in UTF-8).
+      auxString += footer.label();
+    } else if (footer.has_sub_label()) {
+      // Windows client shows sub_label() only when label() is not specified. We
+      // follow the policy.
+      auxString += footer.sub_label();
+    }
+
+    if (footer.has_index_visible() && footer.index_visible()) {
+      if (!auxString.empty()) {
+        auxString += " ";
+      }
+      auxString += std::to_string(candidates.focused_index() + 1);
+      auxString += "/";
+      auxString += std::to_string(candidates.size());
+    }
+    mozc_state->SetAuxString(auxString);
+  }
+
+  ic->inputPanel().setCandidateList(std::make_unique<MozcCandidateList>(
+      candidates, ic, engine_, *engine_->config().verticalList));
+}
+
+void MozcResponseParser::ParsePreedit(const mozc::commands::Preedit &preedit,
+                                      uint32_t position,
+                                      InputContext *ic) const {
+  auto *mozc_state = engine_->mozcState(ic);
+  Text preedit_text;
+  std::string s;
+
+  for (int i = 0; i < preedit.segment_size(); ++i) {
+    const mozc::commands::Preedit_Segment &segment = preedit.segment(i);
+    const std::string &str = segment.value();
+    if (!utf8::validate(str)) {
+      continue;
+    }
+    TextFormatFlags format_flag;
+
+    switch (segment.annotation()) {
+      case mozc::commands::Preedit_Segment::NONE:
+        break;
+      case mozc::commands::Preedit_Segment::UNDERLINE:
+        format_flag = TextFormatFlag::Underline;
+        break;
+      case mozc::commands::Preedit_Segment::HIGHLIGHT:
+        format_flag = TextFormatFlag::HighLight;
+        break;
+    }
+    s += str;
+
+    preedit_text.append(str, format_flag);
+  }
+
+  int cursor = -1;
+  auto charLength = utf8::length(s);
+  if (charLength >= position) {
+    cursor = utf8::ncharByteLength(s.begin(), position);
+  }
+  preedit_text.setCursor(cursor);
+
+  mozc_state->SetPreeditInfo(std::move(preedit_text));
+}
+
+}  // namespace fcitx
diff --git a/src/unix/fcitx5/mozc_response_parser.h b/src/unix/fcitx5/mozc_response_parser.h
new file mode 100644
index 0000000..2fabef0
--- /dev/null
+++ b/src/unix/fcitx5/mozc_response_parser.h
@@ -0,0 +1,78 @@
+// Copyright 2010-2012, Google Inc.
+// Copyright 2012~2013, Weng Xuetian <wengxt@gmail.com>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MOZC_UNIX_FCITX_MOZC_RESPONSE_PARSER_H_
+#define MOZC_UNIX_FCITX_MOZC_RESPONSE_PARSER_H_
+
+#include <cstdint>
+
+#include "protocol/candidate_window.pb.h"
+#include "protocol/commands.pb.h"
+
+namespace fcitx {
+
+class InputContext;
+class MozcEngine;
+
+// This class parses IPC response from mozc_server (mozc::commands::Output) and
+// updates the FCITX UI.
+class MozcResponseParser {
+ public:
+  MozcResponseParser(MozcEngine *engine);
+  MozcResponseParser(const MozcResponseParser &) = delete;
+  ~MozcResponseParser();
+
+  // Parses a response from Mozc server and sets persed information on
+  // fcitx_mozc
+  // object. Returns true if response.consumed() is true. fcitx_mozc must be non
+  // NULL. This function does not take ownership of fcitx_mozc.
+  bool ParseResponse(const mozc::commands::Output &response,
+                     InputContext *ic) const;
+
+ private:
+  void UpdateDeletionRange(const mozc::commands::Output &response,
+                           InputContext *ic) const;
+  void LaunchTool(const mozc::commands::Output &response,
+                  InputContext *ic) const;
+  void ExecuteCallback(const mozc::commands::Output &response,
+                       InputContext *ic) const;
+  void ParseResult(const mozc::commands::Result &result,
+                   InputContext *ic) const;
+  void ParseCandidates(const mozc::commands::CandidateWindow &candidates,
+                       InputContext *ic) const;
+  void ParsePreedit(const mozc::commands::Preedit &preedit, uint32_t position,
+                    InputContext *ic) const;
+
+  MozcEngine *engine_;
+};
+
+}  // namespace fcitx
+
+#endif  // MOZC_UNIX_FCITX_MOZC_RESPONSE_PARSER_H_
diff --git a/src/unix/fcitx5/mozc_state.cc b/src/unix/fcitx5/mozc_state.cc
new file mode 100644
index 0000000..a926c8b
--- /dev/null
+++ b/src/unix/fcitx5/mozc_state.cc
@@ -0,0 +1,475 @@
+// Copyright 2012~2013, Weng Xuetian <wengxt@gmail.com>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "unix/fcitx5/mozc_state.h"
+
+#include <fcitx-utils/capabilityflags.h>
+#include <fcitx-utils/key.h>
+#include <fcitx-utils/keysym.h>
+#include <fcitx-utils/log.h>
+#include <fcitx-utils/stringutils.h>
+#include <fcitx-utils/utf8.h>
+#include <fcitx/candidatelist.h>
+#include <fcitx/event.h>
+#include <fcitx/inputpanel.h>
+#include <fcitx/text.h>
+#include <fcitx/userinterface.h>
+
+#include <cstdint>
+#include <memory>
+#include <optional>
+#include <string>
+#include <utility>
+
+#include "absl/log/check.h"
+#include "absl/log/log.h"
+#include "base/process.h"
+#include "base/vlog.h"
+#include "protocol/commands.pb.h"
+#include "protocol/config.pb.h"
+#include "unix/fcitx5/fcitx_key_event_handler.h"
+#include "unix/fcitx5/i18nwrapper.h"
+#include "unix/fcitx5/mozc_engine.h"
+#include "unix/fcitx5/mozc_response_parser.h"
+#include "unix/fcitx5/surrounding_text_util.h"
+
+namespace fcitx {
+
+MozcState::MozcState(InputContext* ic, MozcEngine* engine)
+    : ic_(ic), engine_(engine), handler_(std::make_unique<KeyEventHandler>()) {
+  // mozc::Logging::SetVerboseLevel(1);
+  MOZC_VLOG(1) << "MozcState created.";
+
+  if (GetClient()->EnsureConnection()) {
+    UpdatePreeditMethod();
+  }
+
+  std::string error;
+  mozc::commands::Output raw_response;
+  if (TrySendCompositionMode(*engine_->config().initialMode, &raw_response,
+                             &error)) {
+    if (raw_response.has_mode()) {
+      SetCompositionMode(raw_response.mode(), /*updateUI=*/false);
+    }
+  }
+}
+
+MozcState::~MozcState() { MOZC_VLOG(1) << "MozcState destroyed."; }
+
+void MozcState::UpdatePreeditMethod() {
+  mozc::config::Config config;
+  if (!GetClient()->GetConfig(&config)) {
+    LOG(ERROR) << "GetConfig failed";
+    return;
+  }
+  preedit_method_ = config.has_preedit_method() ? config.preedit_method()
+                                                : mozc::config::Config::ROMAN;
+  std::string error;
+  mozc::commands::Output raw_response;
+  mozc::commands::CompositionMode mode = composition_mode_;
+  if (TrySendCommand(mozc::commands::SessionCommand::GET_STATUS, &raw_response,
+                     &error)) {
+    if (raw_response.has_status()) {
+      if (raw_response.status().activated()) {
+        mode = raw_response.status().mode();
+      } else {
+        mode = mozc::commands::DIRECT;
+      }
+    }
+  }
+  if (mode != composition_mode_) {
+    composition_mode_ = mode;
+    engine_->compositionModeUpdated(ic_);
+  }
+}
+
+bool MozcState::TrySendKeyEvent(InputContext* ic,
+                                const mozc::commands::KeyEvent& event,
+                                mozc::commands::Output* out,
+                                std::string* out_error) const {
+  DCHECK(out);
+  DCHECK(out_error);
+
+  // Call EnsureConnection just in case MozcState::MozcConnection() fails
+  // to establish the server connection.
+  auto* client = GetClient();
+  if (!client->EnsureConnection()) {
+    *out_error = "EnsureConnection failed";
+    MOZC_VLOG(1) << "EnsureConnection failed";
+    return false;
+  }
+
+  if ((composition_mode_ == mozc::commands::DIRECT) &&
+      !client->IsDirectModeCommand(event)) {
+    MOZC_VLOG(1) << "In DIRECT mode. Not consumed.";
+    return false;  // not consumed.
+  }
+
+  mozc::commands::Context context;
+  SurroundingTextInfo surrounding_text_info;
+  if (GetSurroundingText(ic, &surrounding_text_info,
+                         engine_->clipboardAddon())) {
+    context.set_preceding_text(surrounding_text_info.preceding_text);
+    context.set_following_text(surrounding_text_info.following_text);
+  }
+
+  MOZC_VLOG(1) << "TrySendKeyEvent: " << event.DebugString();
+  if (!client->SendKeyWithContext(event, context, out)) {
+    *out_error = "SendKey failed";
+    MOZC_VLOG(1) << "ERROR";
+    return false;
+  }
+  MOZC_VLOG(1) << "OK: " << out->DebugString();
+  return true;
+}
+
+bool MozcState::TrySendClick(int32_t unique_id, mozc::commands::Output* out,
+                             std::string* out_error) const {
+  DCHECK(out);
+  DCHECK(out_error);
+
+  mozc::commands::SessionCommand command;
+  command.set_type(mozc::commands::SessionCommand::SELECT_CANDIDATE);
+  command.set_id(unique_id);
+  return TrySendRawCommand(command, out, out_error);
+}
+
+bool MozcState::TrySendCompositionMode(mozc::commands::CompositionMode mode,
+                                       mozc::commands::Output* out,
+                                       std::string* out_error) const {
+  DCHECK(out);
+  DCHECK(out_error);
+
+  mozc::commands::SessionCommand command;
+  if (mode == mozc::commands::DIRECT) {
+    command.set_type(mozc::commands::SessionCommand::TURN_OFF_IME);
+    command.set_composition_mode(composition_mode_);
+  } else {
+    command.set_type(mozc::commands::SessionCommand::SWITCH_INPUT_MODE);
+    command.set_composition_mode(mode);
+  }
+  return TrySendRawCommand(command, out, out_error);
+}
+
+bool MozcState::TrySendCommand(mozc::commands::SessionCommand::CommandType type,
+                               mozc::commands::Output* out,
+                               std::string* out_error) const {
+  DCHECK(out);
+  DCHECK(out_error);
+
+  mozc::commands::SessionCommand command;
+  command.set_type(type);
+  return TrySendRawCommand(command, out, out_error);
+}
+
+bool MozcState::TrySendRawCommand(const mozc::commands::SessionCommand& command,
+                                  mozc::commands::Output* out,
+                                  std::string* out_error) const {
+  MOZC_VLOG(1) << "TrySendRawCommand: " << command.DebugString();
+  if (!GetClient()->SendCommand(command, out)) {
+    *out_error = "SendCommand failed";
+    MOZC_VLOG(1) << "ERROR";
+    return false;
+  }
+  MOZC_VLOG(1) << "OK: " << out->DebugString();
+  return true;
+}
+
+// This function is called when users press or release a key.
+bool MozcState::ProcessKeyEvent(KeySym sym, uint32_t keycode, KeyStates state,
+                                bool layout_is_jp, bool is_key_up) {
+  auto normalized_key = Key(sym, state).normalize();
+  if (displayUsage_) {
+    if (is_key_up) {
+      return true;
+    }
+
+    if (normalized_key.check(Key(FcitxKey_Escape))) {
+      displayUsage_ = false;
+      ProcessKeyEvent(FcitxKey_VoidSymbol, 0, KeyState::NoState, layout_is_jp,
+                      false);
+    }
+    return true;
+  }
+
+  if (*engine_->config().expandMode == ExpandMode::Hotkey &&
+      normalized_key.check(*engine_->config().expand)) {
+    if (!title_.empty() || !description_.empty()) {
+      DisplayUsage();
+      return true;
+    }
+  }
+
+  mozc::commands::KeyEvent event;
+  std::optional<std::string> compose;
+  do {
+    if (!is_key_up &&
+        !state.testAny(KeyStates{KeyState::Ctrl, KeyState::Super})) {
+      compose = engine_->instance()->processComposeString(ic_, sym);
+      if (!compose) {
+        return true;
+      }
+      if (!compose->empty()) {
+        auto length = utf8::lengthValidated(*compose);
+        if (length == utf8::INVALID_LENGTH) {
+          return true;
+        }
+        if (!handler_->GetKeyEvent(*compose, preedit_method_, layout_is_jp,
+                                   &event)) {
+          return false;
+        }
+        break;
+      }
+    }
+    if (!handler_->GetKeyEvent(sym, keycode, state, preedit_method_,
+                               layout_is_jp, is_key_up, &event)) {
+      return false;
+    }
+  } while (false);
+
+  std::string error;
+  mozc::commands::Output raw_response;
+  if (!TrySendKeyEvent(ic_, event, &raw_response, &error)) {
+    // TODO(yusukes): Show |error|.
+    if (compose && !compose->empty()) {
+      ic_->commitString(*compose);
+      Reset();
+      return true;
+    }
+    return false;  // not consumed.
+  }
+
+  return ParseResponse(raw_response);
+}
+
+// This function is called from SCIM framework when users click the candidate
+// window.
+void MozcState::SelectCandidate(int32_t id) {
+  if (id == kBadCandidateId) {
+    LOG(ERROR) << "The clicked candidate doesn't have unique ID.";
+    return;
+  }
+  MOZC_VLOG(1) << "select_candidate, id=" << id;
+
+  std::string error;
+  mozc::commands::Output raw_response;
+  if (!TrySendClick(id, &raw_response, &error)) {
+    LOG(ERROR) << "IPC failed. error=" << error;
+    SetAuxString(error);
+    DrawAll();
+  } else {
+    ParseResponse(raw_response);
+  }
+}
+
+// This function is called from SCIM framework.
+void MozcState::Reset() {
+  MOZC_VLOG(1) << "resetim";
+  std::string error;
+  mozc::commands::Output raw_response;
+  if (TrySendCommand(mozc::commands::SessionCommand::REVERT, &raw_response,
+                     &error)) {
+    engine_->parser()->ParseResponse(raw_response, ic_);
+  }
+  ClearAll();  // just in case.
+  DrawAll();
+  engine_->instance()->resetCompose(ic_);
+}
+
+bool MozcState::Paging(bool prev) {
+  MOZC_VLOG(1) << "paging";
+  std::string error;
+  mozc::commands::SessionCommand::CommandType command =
+      prev ? mozc::commands::SessionCommand::CONVERT_PREV_PAGE
+           : mozc::commands::SessionCommand::CONVERT_NEXT_PAGE;
+  mozc::commands::Output raw_response;
+  if (TrySendCommand(command, &raw_response, &error)) {
+    engine_->parser()->ParseResponse(raw_response, ic_);
+    return true;
+  }
+  return false;
+}
+
+// This function is called when the ic gets focus.
+void MozcState::FocusIn() {
+  MOZC_VLOG(1) << "MozcState::FocusIn()";
+
+  UpdatePreeditMethod();
+  DrawAll();
+}
+
+// This function is called when the ic loses focus.
+void MozcState::FocusOut(const InputContextEvent& event) {
+  MOZC_VLOG(1) << "MozcState::FocusOut()";
+  std::string error;
+  mozc::commands::Output raw_response;
+
+  const auto command =
+      (event.type() == EventType::InputContextSwitchInputMethod)
+          ? mozc::commands::SessionCommand::SUBMIT
+          : mozc::commands::SessionCommand::REVERT;
+
+  if (TrySendCommand(command, &raw_response, &error)) {
+    engine_->parser()->ParseResponse(raw_response, ic_);
+  }
+  ClearAll();  // just in case.
+  DrawAll();
+  engine_->instance()->resetCompose(ic_);
+}
+
+bool MozcState::ParseResponse(const mozc::commands::Output& raw_response) {
+  auto oldMode = composition_mode_;
+  ClearAll();
+  const bool consumed = engine_->parser()->ParseResponse(raw_response, ic_);
+  if (!consumed) {
+    MOZC_VLOG(1) << "The input was not consumed by Mozc.";
+  }
+  OpenUrl();
+  DrawAll();
+  if (oldMode != composition_mode_ && aux_.empty() && preedit_.empty() &&
+      !ic_->inputPanel().candidateList()) {
+    engine_->instance()->showInputMethodInformation(ic_);
+  }
+  return consumed;
+}
+
+void MozcState::SetResultString(const std::string& result_string) {
+  ic_->commitString(result_string);
+}
+
+void MozcState::SetPreeditInfo(Text preedit_info) {
+  preedit_ = std::move(preedit_info);
+}
+
+void MozcState::SetAuxString(const std::string& str) { aux_ = str; }
+
+void MozcState::SetCompositionMode(mozc::commands::CompositionMode mode,
+                                   bool updateUI) {
+  composition_mode_ = mode;
+  DCHECK(composition_mode_ < mozc::commands::NUM_OF_COMPOSITIONS);
+  if (updateUI) {
+    engine_->compositionModeUpdated(ic_);
+  }
+}
+
+void MozcState::SendCompositionMode(mozc::commands::CompositionMode mode) {
+  // Send the SWITCH_INPUT_MODE command.
+  std::string error;
+  mozc::commands::Output raw_response;
+  if (TrySendCompositionMode(mode, &raw_response, &error)) {
+    engine_->parser()->ParseResponse(raw_response, ic_);
+  }
+}
+
+void MozcState::SetUrl(const std::string& url) { url_ = url; }
+
+void MozcState::ClearAll() {
+  SetPreeditInfo(Text());
+  SetAuxString("");
+  ic_->inputPanel().reset();
+  url_.clear();
+}
+
+void MozcState::DrawAll() {
+  std::string aux;
+  if (!aux_.empty()) {
+    aux += "[";
+    aux += aux_;
+    aux += "]";
+  }
+  if (ic_->capabilityFlags().test(CapabilityFlag::Preedit)) {
+    Text preedit = preedit_;
+    if (*engine_->config().preeditCursorPositionAtBeginning) {
+      preedit.setCursor(0);
+    }
+    ic_->inputPanel().setClientPreedit(preedit);
+    if (!aux_.empty()) {
+      ic_->inputPanel().setAuxUp(Text(aux));
+    }
+  } else {
+    Text preedit = preedit_;
+    if (!preedit.empty()) {
+      preedit.append(" ");
+      preedit.append(aux);
+      ic_->inputPanel().setPreedit(preedit);
+    } else if (!aux_.empty()) {
+      ic_->inputPanel().setAuxUp(Text(aux));
+    }
+  }
+  ic_->updatePreedit();
+  ic_->updateUserInterface(UserInterfaceComponent::InputPanel);
+}
+
+void MozcState::OpenUrl() {
+  if (url_.empty()) {
+    return;
+  }
+  mozc::Process::OpenBrowser(url_);
+  url_.clear();
+}
+
+bool MozcState::SendCommand(
+    const mozc::commands::SessionCommand& session_command,
+    mozc::commands::Output* new_output) {
+  std::string error;
+  return TrySendRawCommand(session_command, new_output, &error);
+}
+
+void MozcState::SetUsage(const std::string& title,
+                         const std::string& description) {
+  title_ = title;
+  description_ = description;
+}
+
+void MozcState::DisplayUsage() {
+  displayUsage_ = true;
+
+  ic_->inputPanel().reset();
+  auto candidateList = std::make_unique<DisplayOnlyCandidateList>();
+
+  auto lines = stringutils::split(description_, "\n");
+  candidateList->setLayoutHint(CandidateLayoutHint::Vertical);
+  candidateList->setContent(lines);
+  ic_->inputPanel().setCandidateList(std::move(candidateList));
+  auto str = title_ + " [" + _("Press Escape to go back") + "]";
+  ic_->inputPanel().setAuxUp(Text(str));
+  ic_->updatePreedit();
+  ic_->updateUserInterface(UserInterfaceComponent::InputPanel);
+}
+
+MozcClientInterface* MozcState::GetClient() const {
+  if (!client_) {
+    client_ = engine_->pool()->requestClient(ic_);
+  }
+  return client_.get();
+}
+
+void MozcState::ReleaseClient() { client_.reset(); }
+
+}  // namespace fcitx
diff --git a/src/unix/fcitx5/mozc_state.h b/src/unix/fcitx5/mozc_state.h
new file mode 100644
index 0000000..89b1a40
--- /dev/null
+++ b/src/unix/fcitx5/mozc_state.h
@@ -0,0 +1,166 @@
+// Copyright 2012~2013, Weng Xuetian <wengxt@gmail.com>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MOZC_UNIX_FCITX_FCITX_MOZC_H_
+#define MOZC_UNIX_FCITX_FCITX_MOZC_H_
+
+#include <fcitx-utils/key.h>
+#include <fcitx/event.h>
+#include <fcitx/inputcontextproperty.h>
+#include <fcitx/text.h>
+
+#include <cstdint>
+#include <memory>
+#include <string>
+
+#include "protocol/commands.pb.h"
+#include "protocol/config.pb.h"
+#include "unix/fcitx5/mozc_client_interface.h"
+
+namespace fcitx {
+inline const int32_t kBadCandidateId = -12345;
+class MozcConnectionInterface;
+class MozcResponseParser;
+class KeyTranslator;
+class KeyEventHandler;
+class MozcEngine;
+
+class MozcState : public InputContextProperty {
+ public:
+  // This constructor is used by unittests.
+  MozcState(InputContext *ic, MozcEngine *engine);
+  MozcState(const MozcState &) = delete;
+  virtual ~MozcState();
+
+  void UpdatePreeditMethod();
+
+  bool ProcessKeyEvent(KeySym sym, uint32_t keycode, KeyStates state,
+                       bool layout_is_jp, bool is_key_up);
+  void SelectCandidate(int idx);
+  void Reset();
+  void FocusIn();
+  void FocusOut(const InputContextEvent &event);
+  bool Paging(bool prev);
+
+  // Functions called by the MozcResponseParser class to update UI.
+
+  // Displays a 'result' (aka 'commit string') on FCITX UI.
+  void SetResultString(const std::string &result_string);
+  // Displays a 'preedit' string on FCITX UI. This function takes ownership
+  // of preedit_info. If the parameter is NULL, hides the string currently
+  // displayed.
+  void SetPreeditInfo(Text preedit_info);
+  // Displays an auxiliary message (e.g., an error message, a title of
+  // candidate window). If the string is empty (""), hides the message
+  // currently being displayed.
+  void SetAuxString(const std::string &str);
+  // Sets a current composition mode (e.g., Hankaku Katakana).
+  void SetCompositionMode(mozc::commands::CompositionMode mode,
+                          bool updateUI = true);
+
+  void SendCompositionMode(mozc::commands::CompositionMode mode);
+
+  // Sets the url to be opened by the default browser.
+  void SetUrl(const std::string &url);
+
+  const std::string &GetIconFile(std::string key);
+
+  mozc::commands::CompositionMode GetCompositionMode() {
+    return composition_mode_;
+  }
+
+  MozcClientInterface *GetClient() const;
+  void ReleaseClient();
+
+  bool SendCommand(const mozc::commands::SessionCommand &session_command,
+                   mozc::commands::Output *new_output);
+
+  void SetUsage(const std::string &title, const std::string &description);
+
+  void DrawAll();
+
+ private:
+  void DisplayUsage();
+  // Sends key event to the server. If the IPC succeeds, returns true and the
+  // response is stored on 'out' (and 'out_error' is not modified). If the IPC
+  // fails, returns false and the error message is stored on 'out_error'. In
+  // this case, 'out' is not modified.
+  bool TrySendKeyEvent(InputContext *ic, const mozc::commands::KeyEvent &event,
+                       mozc::commands::Output *out,
+                       std::string *out_error) const;
+
+  // Sends 'mouse click on the candidate window' event to the server.
+  bool TrySendClick(int32_t unique_id, mozc::commands::Output *out,
+                    std::string *out_error) const;
+
+  // Sends composition mode to the server.
+  bool TrySendCompositionMode(mozc::commands::CompositionMode mode,
+                              mozc::commands::Output *out,
+                              std::string *out_error) const;
+
+  // Sends a command to the server.
+  bool TrySendCommand(mozc::commands::SessionCommand::CommandType type,
+                      mozc::commands::Output *out,
+                      std::string *out_error) const;
+
+  bool TrySendRawCommand(const mozc::commands::SessionCommand &command,
+                         mozc::commands::Output *out,
+                         std::string *out_error) const;
+
+  // Parses the response from mozc_server. Returns whether the server consumes
+  // the input or not (true means 'consumed').
+  bool ParseResponse(const mozc::commands::Output &raw_response);
+
+  void ClearAll();
+  void DrawPreeditInfo();
+  void DrawAux();
+
+  // Open url_ with a default browser.
+  void OpenUrl();
+
+  InputContext *ic_;
+  MozcEngine *engine_;
+  mutable std::shared_ptr<MozcClientInterface> client_;
+
+  mozc::commands::CompositionMode composition_mode_ = mozc::commands::HIRAGANA;
+  mozc::config::Config::PreeditMethod preedit_method_ =
+      mozc::config::Config::ROMAN;
+  const std::unique_ptr<KeyEventHandler> handler_;
+
+  bool displayUsage_ = false;
+  Text preedit_;
+  std::string aux_;  // error tooltip, or candidate window title.
+  std::string url_;  // URL to be opened by a browser.
+  std::string description_;
+  std::string title_;
+};
+
+}  // namespace fcitx
+
+#endif  // MOZC_UNIX_FCITX_FCITX_MOZC_H_
diff --git a/src/unix/fcitx5/org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in b/src/unix/fcitx5/org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in
new file mode 100644
index 0000000..e8ac1ff
--- /dev/null
+++ b/src/unix/fcitx5/org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?>
+<component type="addon">
+  <id>org.fcitx.Fcitx5.Addon.Mozc</id>
+  <extends>org.fcitx.Fcitx5</extends>
+  <metadata_license>CC0-1.0</metadata_license>
+  <project_license>GPL-2.0+</project_license>
+  <name>Mozc for Fcitx 5</name>
+  <summary>Japanese input method based on Mozc</summary>
+  <developer id="org.fcitx-im">
+    <name>The Fcitx Team</name>
+  </developer>
+  <url type="homepage">https://fcitx-im.org</url>
+  <url type="bugtracker">https://github.com/fcitx/mozc/issues</url>
+  <url type="vcs-browser">https://github.com/fcitx/mozc</url>
+  <project_group>Fcitx</project_group>
+  <releases>
+    <release version="2.31.5851.102" date="2025-06-02"></release>
+    <release version="2.31.5810.102" date="2025-04-24"></release>
+    <release version="2.31.5712.102" date="2025-01-16"></release>
+    <release version="2.30.5618.102" date="2024-10-10"></release>
+    <release version="2.30.5595.102" date="2024-09-17"></release>
+    <release version="2.30.5544.102" date="2024-08-28"></release>
+    <release version="2.30.5490.102" date="2024-06-06"></release>
+    <release version="2.30.5448.102" date="2024-04-25"></release>
+    <release version="2.30.5432.102" date="2024-04-06"></release>
+    <release version="2.29.5400.102" date="2024-03-07"></release>
+    <release version="2.29.5374.102" date="2024-02-09"></release>
+    <release version="2.29.5372.102" date="2024-02-07"></release>
+    <release version="2.29.5346.102" date="2024-01-22"></release>
+    <release version="2.29.5291.102" date="2023-12-04"></release>
+    <release version="2.26.4220.106.1" date="2021-01-16"></release>
+    <release version="2.25.4150.102.1" date="2020-11-10"></release>
+  </releases>
+</component>
diff --git a/src/unix/fcitx5/po/LINGUAS b/src/unix/fcitx5/po/LINGUAS
new file mode 100644
index 0000000..29d9f11
--- /dev/null
+++ b/src/unix/fcitx5/po/LINGUAS
@@ -0,0 +1,12 @@
+
+ca
+da
+de
+he
+ja
+ko
+ru
+tr
+vi
+zh_CN
+zh_TW
diff --git a/src/unix/fcitx5/po/ca.po b/src/unix/fcitx5/po/ca.po
new file mode 100644
index 0000000..d26bd40
--- /dev/null
+++ b/src/unix/fcitx5/po/ca.po
@@ -0,0 +1,139 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the fcitx5-mozc package.
+#
+# Translators:
+# csslayer <wengxt@gmail.com>, 2017
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: fcitx5-mozc\n"
+"Report-Msgid-Bugs-To: fcitx-dev@googlegroups.com\n"
+"POT-Creation-Date: 2023-09-20 20:24+0000\n"
+"PO-Revision-Date: 2017-11-23 05:28+0000\n"
+"Last-Translator: csslayer <wengxt@gmail.com>, 2017\n"
+"Language-Team: Catalan (https://app.transifex.com/fcitx/teams/12005/ca/)\n"
+"Language: ca\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+
+#: mozc_engine.h:94 mozc_engine.cc:198
+msgid "About Mozc"
+msgstr ""
+
+#: mozc_engine.h:92 mozc_engine.cc:191
+msgid "Add Word"
+msgstr ""
+
+#: mozc_engine.h:52
+msgid "All"
+msgstr ""
+
+#: mozc_engine.h:55
+msgid "Always"
+msgstr ""
+
+#: mozc_engine.h:88 mozc_engine.cc:175
+msgid "Configuration Tool"
+msgstr "Eina de configuració"
+
+#: mozc_engine.h:90 mozc_engine.cc:183
+msgid "Dictionary Tool"
+msgstr "Eina de diccionari"
+
+#: mozc_engine.h:58 mozc_engine.cc:54
+msgid "Direct"
+msgstr ""
+
+#: mozc_engine.h:79
+msgid "Expand Usage (Requires vertical candidate list)"
+msgstr ""
+
+#: mozc_engine.h:83
+msgid "Fix embedded preedit cursor at the beginning of the preedit"
+msgstr ""
+
+#: mozc_engine.h:52
+msgid "Follow Global Configuration"
+msgstr ""
+
+#. Full width ASCII letter A.
+#: mozc_engine.h:60 mozc_engine.cc:84
+msgid "Full ASCII"
+msgstr ""
+
+#. Katakana letter A.
+#: mozc_engine.h:59 mozc_engine.cc:68
+msgid "Full Katakana"
+msgstr ""
+
+#: mozc_engine.h:59 mozc_engine.cc:76
+msgid "Half ASCII"
+msgstr ""
+
+#. Half width Katakana letter A.
+#: mozc_engine.h:60 mozc_engine.cc:91
+msgid "Half Katakana"
+msgstr ""
+
+#. Hiragana letter A in UTF-8.
+#: mozc_engine.h:58 mozc_engine.cc:61
+msgid "Hiragana"
+msgstr ""
+
+#: mozc_engine.h:56
+msgid "Hotkey"
+msgstr ""
+
+#: mozc_engine.h:85
+msgid "Hotkey to expand usage"
+msgstr ""
+
+#: mozc_engine.h:70
+msgid "Initial Mode"
+msgstr ""
+
+#: org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in:8
+msgid "Japanese input method based on Mozc"
+msgstr ""
+
+#: mozc_engine.cc:147 mozc_engine.cc:148
+msgid "Mozc Settings"
+msgstr ""
+
+#: org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in:7
+msgid "Mozc for Fcitx 5"
+msgstr ""
+
+#: mozc_engine.h:53
+msgid "No"
+msgstr ""
+
+#: mozc_engine.h:55
+msgid "On Focus"
+msgstr ""
+
+#. We don't have a good library option for this, just do the simple
+#. replace. absl's runtime parsed format string is too copmlex.
+#: mozc_response_parser.cc:175
+#, c-format
+msgid "Press %s to show usages."
+msgstr ""
+
+#: mozc_state.cc:426
+msgid "Press Escape to go back"
+msgstr ""
+
+#: mozc_engine.h:53
+msgid "Program"
+msgstr ""
+
+#: mozc_engine.h:73
+msgid "Shared Input State"
+msgstr ""
+
+#: mozc_engine.h:75
+msgid "Vertical candidate list"
+msgstr ""
diff --git a/src/unix/fcitx5/po/da.po b/src/unix/fcitx5/po/da.po
new file mode 100644
index 0000000..2ed5dc2
--- /dev/null
+++ b/src/unix/fcitx5/po/da.po
@@ -0,0 +1,139 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the fcitx5-mozc package.
+#
+# Translators:
+# scootergrisen, 2020
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: fcitx5-mozc\n"
+"Report-Msgid-Bugs-To: fcitx-dev@googlegroups.com\n"
+"POT-Creation-Date: 2023-09-20 20:24+0000\n"
+"PO-Revision-Date: 2017-11-23 05:28+0000\n"
+"Last-Translator: scootergrisen, 2020\n"
+"Language-Team: Danish (https://app.transifex.com/fcitx/teams/12005/da/)\n"
+"Language: da\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+
+#: mozc_engine.h:94 mozc_engine.cc:198
+msgid "About Mozc"
+msgstr "Om Mozc"
+
+#: mozc_engine.h:92 mozc_engine.cc:191
+msgid "Add Word"
+msgstr "Tilføj ord"
+
+#: mozc_engine.h:52
+msgid "All"
+msgstr ""
+
+#: mozc_engine.h:55
+msgid "Always"
+msgstr "Altid"
+
+#: mozc_engine.h:88 mozc_engine.cc:175
+msgid "Configuration Tool"
+msgstr "Konfigurationsværktøj"
+
+#: mozc_engine.h:90 mozc_engine.cc:183
+msgid "Dictionary Tool"
+msgstr "Ordbogsværktøj"
+
+#: mozc_engine.h:58 mozc_engine.cc:54
+msgid "Direct"
+msgstr "Direkte"
+
+#: mozc_engine.h:79
+msgid "Expand Usage (Requires vertical candidate list)"
+msgstr ""
+
+#: mozc_engine.h:83
+msgid "Fix embedded preedit cursor at the beginning of the preedit"
+msgstr ""
+
+#: mozc_engine.h:52
+msgid "Follow Global Configuration"
+msgstr ""
+
+#. Full width ASCII letter A.
+#: mozc_engine.h:60 mozc_engine.cc:84
+msgid "Full ASCII"
+msgstr "Fuld ASCII"
+
+#. Katakana letter A.
+#: mozc_engine.h:59 mozc_engine.cc:68
+msgid "Full Katakana"
+msgstr "Fuld Katakana"
+
+#: mozc_engine.h:59 mozc_engine.cc:76
+msgid "Half ASCII"
+msgstr "Halv ASCII"
+
+#. Half width Katakana letter A.
+#: mozc_engine.h:60 mozc_engine.cc:91
+msgid "Half Katakana"
+msgstr "Halv Katakana"
+
+#. Hiragana letter A in UTF-8.
+#: mozc_engine.h:58 mozc_engine.cc:61
+msgid "Hiragana"
+msgstr "Hiragana"
+
+#: mozc_engine.h:56
+msgid "Hotkey"
+msgstr "Hottast"
+
+#: mozc_engine.h:85
+msgid "Hotkey to expand usage"
+msgstr "Hottast til at udvide anvendelse"
+
+#: mozc_engine.h:70
+msgid "Initial Mode"
+msgstr ""
+
+#: org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in:8
+msgid "Japanese input method based on Mozc"
+msgstr "Japansk-inputmetode baseret på Mozc"
+
+#: mozc_engine.cc:147 mozc_engine.cc:148
+msgid "Mozc Settings"
+msgstr ""
+
+#: org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in:7
+msgid "Mozc for Fcitx 5"
+msgstr "Mozc til Fcitx 5"
+
+#: mozc_engine.h:53
+msgid "No"
+msgstr ""
+
+#: mozc_engine.h:55
+msgid "On Focus"
+msgstr "Ved fokus"
+
+#. We don't have a good library option for this, just do the simple
+#. replace. absl's runtime parsed format string is too copmlex.
+#: mozc_response_parser.cc:175
+#, c-format
+msgid "Press %s to show usages."
+msgstr "Tryk på %s for at vise anvendelser."
+
+#: mozc_state.cc:426
+msgid "Press Escape to go back"
+msgstr "Tryk på Escape for at gå tilbage"
+
+#: mozc_engine.h:53
+msgid "Program"
+msgstr ""
+
+#: mozc_engine.h:73
+msgid "Shared Input State"
+msgstr ""
+
+#: mozc_engine.h:75
+msgid "Vertical candidate list"
+msgstr ""
diff --git a/src/unix/fcitx5/po/de.po b/src/unix/fcitx5/po/de.po
new file mode 100644
index 0000000..059c7a6
--- /dev/null
+++ b/src/unix/fcitx5/po/de.po
@@ -0,0 +1,140 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the fcitx5-mozc package.
+#
+# Translators:
+# csslayer <wengxt@gmail.com>, 2017
+# Ettore Atalan <atalanttore@googlemail.com>, 2022
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: fcitx5-mozc\n"
+"Report-Msgid-Bugs-To: fcitx-dev@googlegroups.com\n"
+"POT-Creation-Date: 2023-09-20 20:24+0000\n"
+"PO-Revision-Date: 2017-11-23 05:28+0000\n"
+"Last-Translator: Ettore Atalan <atalanttore@googlemail.com>, 2022\n"
+"Language-Team: German (https://app.transifex.com/fcitx/teams/12005/de/)\n"
+"Language: de\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+
+#: mozc_engine.h:94 mozc_engine.cc:198
+msgid "About Mozc"
+msgstr ""
+
+#: mozc_engine.h:92 mozc_engine.cc:191
+msgid "Add Word"
+msgstr "Wort hinzufügen"
+
+#: mozc_engine.h:52
+msgid "All"
+msgstr ""
+
+#: mozc_engine.h:55
+msgid "Always"
+msgstr "Immer"
+
+#: mozc_engine.h:88 mozc_engine.cc:175
+msgid "Configuration Tool"
+msgstr "Konfigurationswerkzeug"
+
+#: mozc_engine.h:90 mozc_engine.cc:183
+msgid "Dictionary Tool"
+msgstr "Wörterbuchwerkzeug"
+
+#: mozc_engine.h:58 mozc_engine.cc:54
+msgid "Direct"
+msgstr "Direkt"
+
+#: mozc_engine.h:79
+msgid "Expand Usage (Requires vertical candidate list)"
+msgstr ""
+
+#: mozc_engine.h:83
+msgid "Fix embedded preedit cursor at the beginning of the preedit"
+msgstr ""
+
+#: mozc_engine.h:52
+msgid "Follow Global Configuration"
+msgstr ""
+
+#. Full width ASCII letter A.
+#: mozc_engine.h:60 mozc_engine.cc:84
+msgid "Full ASCII"
+msgstr ""
+
+#. Katakana letter A.
+#: mozc_engine.h:59 mozc_engine.cc:68
+msgid "Full Katakana"
+msgstr ""
+
+#: mozc_engine.h:59 mozc_engine.cc:76
+msgid "Half ASCII"
+msgstr ""
+
+#. Half width Katakana letter A.
+#: mozc_engine.h:60 mozc_engine.cc:91
+msgid "Half Katakana"
+msgstr ""
+
+#. Hiragana letter A in UTF-8.
+#: mozc_engine.h:58 mozc_engine.cc:61
+msgid "Hiragana"
+msgstr ""
+
+#: mozc_engine.h:56
+msgid "Hotkey"
+msgstr "Kurzbefehl"
+
+#: mozc_engine.h:85
+msgid "Hotkey to expand usage"
+msgstr ""
+
+#: mozc_engine.h:70
+msgid "Initial Mode"
+msgstr "Anfangsmodus"
+
+#: org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in:8
+msgid "Japanese input method based on Mozc"
+msgstr ""
+
+#: mozc_engine.cc:147 mozc_engine.cc:148
+msgid "Mozc Settings"
+msgstr ""
+
+#: org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in:7
+msgid "Mozc for Fcitx 5"
+msgstr ""
+
+#: mozc_engine.h:53
+msgid "No"
+msgstr ""
+
+#: mozc_engine.h:55
+msgid "On Focus"
+msgstr "Im Fokus"
+
+#. We don't have a good library option for this, just do the simple
+#. replace. absl's runtime parsed format string is too copmlex.
+#: mozc_response_parser.cc:175
+#, c-format
+msgid "Press %s to show usages."
+msgstr ""
+
+#: mozc_state.cc:426
+msgid "Press Escape to go back"
+msgstr ""
+
+#: mozc_engine.h:53
+msgid "Program"
+msgstr ""
+
+#: mozc_engine.h:73
+msgid "Shared Input State"
+msgstr ""
+
+#: mozc_engine.h:75
+msgid "Vertical candidate list"
+msgstr ""
diff --git a/src/unix/fcitx5/po/fcitx5-mozc.pot b/src/unix/fcitx5/po/fcitx5-mozc.pot
new file mode 100644
index 0000000..7133997
--- /dev/null
+++ b/src/unix/fcitx5/po/fcitx5-mozc.pot
@@ -0,0 +1,135 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the fcitx5-mozc package.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: fcitx5-mozc\n"
+"Report-Msgid-Bugs-To: fcitx-dev@googlegroups.com\n"
+"POT-Creation-Date: 2023-09-20 20:24+0000\n"
+"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
+"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
+"Language-Team: LANGUAGE <LL@li.org>\n"
+"Language: LANG\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#: mozc_engine.h:94 mozc_engine.cc:198
+msgid "About Mozc"
+msgstr ""
+
+#: mozc_engine.h:92 mozc_engine.cc:191
+msgid "Add Word"
+msgstr ""
+
+#: mozc_engine.h:52
+msgid "All"
+msgstr ""
+
+#: mozc_engine.h:55
+msgid "Always"
+msgstr ""
+
+#: mozc_engine.h:88 mozc_engine.cc:175
+msgid "Configuration Tool"
+msgstr ""
+
+#: mozc_engine.h:90 mozc_engine.cc:183
+msgid "Dictionary Tool"
+msgstr ""
+
+#: mozc_engine.h:58 mozc_engine.cc:54
+msgid "Direct"
+msgstr ""
+
+#: mozc_engine.h:79
+msgid "Expand Usage (Requires vertical candidate list)"
+msgstr ""
+
+#: mozc_engine.h:83
+msgid "Fix embedded preedit cursor at the beginning of the preedit"
+msgstr ""
+
+#: mozc_engine.h:52
+msgid "Follow Global Configuration"
+msgstr ""
+
+#. Full width ASCII letter A.
+#: mozc_engine.h:60 mozc_engine.cc:84
+msgid "Full ASCII"
+msgstr ""
+
+#. Katakana letter A.
+#: mozc_engine.h:59 mozc_engine.cc:68
+msgid "Full Katakana"
+msgstr ""
+
+#: mozc_engine.h:59 mozc_engine.cc:76
+msgid "Half ASCII"
+msgstr ""
+
+#. Half width Katakana letter A.
+#: mozc_engine.h:60 mozc_engine.cc:91
+msgid "Half Katakana"
+msgstr ""
+
+#. Hiragana letter A in UTF-8.
+#: mozc_engine.h:58 mozc_engine.cc:61
+msgid "Hiragana"
+msgstr ""
+
+#: mozc_engine.h:56
+msgid "Hotkey"
+msgstr ""
+
+#: mozc_engine.h:85
+msgid "Hotkey to expand usage"
+msgstr ""
+
+#: mozc_engine.h:70
+msgid "Initial Mode"
+msgstr ""
+
+#: org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in:8
+msgid "Japanese input method based on Mozc"
+msgstr ""
+
+#: mozc_engine.cc:147 mozc_engine.cc:148
+msgid "Mozc Settings"
+msgstr ""
+
+#: org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in:7
+msgid "Mozc for Fcitx 5"
+msgstr ""
+
+#: mozc_engine.h:53
+msgid "No"
+msgstr ""
+
+#: mozc_engine.h:55
+msgid "On Focus"
+msgstr ""
+
+#. We don't have a good library option for this, just do the simple
+#. replace. absl's runtime parsed format string is too copmlex.
+#: mozc_response_parser.cc:175
+#, c-format
+msgid "Press %s to show usages."
+msgstr ""
+
+#: mozc_state.cc:426
+msgid "Press Escape to go back"
+msgstr ""
+
+#: mozc_engine.h:53
+msgid "Program"
+msgstr ""
+
+#: mozc_engine.h:73
+msgid "Shared Input State"
+msgstr ""
+
+#: mozc_engine.h:75
+msgid "Vertical candidate list"
+msgstr ""
diff --git a/src/unix/fcitx5/po/he.po b/src/unix/fcitx5/po/he.po
new file mode 100644
index 0000000..a81ecb2
--- /dev/null
+++ b/src/unix/fcitx5/po/he.po
@@ -0,0 +1,141 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the fcitx5-mozc package.
+#
+# Translators:
+# 63f334ffc0709ba0fc2361b80bf3c0f0_00ffd1e <ab96c93ca0ac55ba7fa06385427e60dd_878890>, 2021
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: fcitx5-mozc\n"
+"Report-Msgid-Bugs-To: fcitx-dev@googlegroups.com\n"
+"POT-Creation-Date: 2024-02-28 20:24+0000\n"
+"PO-Revision-Date: 2017-11-23 05:28+0000\n"
+"Last-Translator: 63f334ffc0709ba0fc2361b80bf3c0f0_00ffd1e "
+"<ab96c93ca0ac55ba7fa06385427e60dd_878890>, 2021\n"
+"Language-Team: Hebrew (https://app.transifex.com/fcitx/teams/12005/he/)\n"
+"Language: he\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=3; plural=(n == 1 && n % 1 == 0) ? 0 : (n == 2 && n % "
+"1 == 0) ? 1: 2;\n"
+
+#: mozc_engine.h:94 mozc_engine.cc:198
+msgid "About Mozc"
+msgstr "על אודות Mozc"
+
+#: mozc_engine.h:92 mozc_engine.cc:191
+msgid "Add Word"
+msgstr "הוספת מילה"
+
+#: mozc_engine.h:52
+msgid "All"
+msgstr ""
+
+#: mozc_engine.h:55
+msgid "Always"
+msgstr ""
+
+#: mozc_engine.h:88 mozc_engine.cc:175
+msgid "Configuration Tool"
+msgstr ""
+
+#: mozc_engine.h:90 mozc_engine.cc:183
+msgid "Dictionary Tool"
+msgstr ""
+
+#: mozc_engine.h:58 mozc_engine.cc:54
+msgid "Direct"
+msgstr ""
+
+#: mozc_engine.h:79
+msgid "Expand Usage (Requires vertical candidate list)"
+msgstr ""
+
+#: mozc_engine.h:83
+msgid "Fix embedded preedit cursor at the beginning of the preedit"
+msgstr ""
+
+#: mozc_engine.h:52
+msgid "Follow Global Configuration"
+msgstr ""
+
+#. Full width ASCII letter A.
+#: mozc_engine.h:60 mozc_engine.cc:84
+msgid "Full ASCII"
+msgstr ""
+
+#. Katakana letter A.
+#: mozc_engine.h:59 mozc_engine.cc:68
+msgid "Full Katakana"
+msgstr ""
+
+#: mozc_engine.h:59 mozc_engine.cc:76
+msgid "Half ASCII"
+msgstr ""
+
+#. Half width Katakana letter A.
+#: mozc_engine.h:60 mozc_engine.cc:91
+msgid "Half Katakana"
+msgstr ""
+
+#. Hiragana letter A in UTF-8.
+#: mozc_engine.h:58 mozc_engine.cc:61
+msgid "Hiragana"
+msgstr ""
+
+#: mozc_engine.h:56
+msgid "Hotkey"
+msgstr ""
+
+#: mozc_engine.h:85
+msgid "Hotkey to expand usage"
+msgstr ""
+
+#: mozc_engine.h:70
+msgid "Initial Mode"
+msgstr ""
+
+#: org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in:8
+msgid "Japanese input method based on Mozc"
+msgstr ""
+
+#: mozc_engine.cc:147 mozc_engine.cc:148
+msgid "Mozc Settings"
+msgstr ""
+
+#: org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in:7
+msgid "Mozc for Fcitx 5"
+msgstr ""
+
+#: mozc_engine.h:53
+msgid "No"
+msgstr ""
+
+#: mozc_engine.h:55
+msgid "On Focus"
+msgstr ""
+
+#. We don't have a good library option for this, just do the simple
+#. replace. absl's runtime parsed format string is too copmlex.
+#: mozc_response_parser.cc:176
+#, c-format
+msgid "Press %s to show usages."
+msgstr ""
+
+#: mozc_state.cc:426
+msgid "Press Escape to go back"
+msgstr ""
+
+#: mozc_engine.h:53
+msgid "Program"
+msgstr ""
+
+#: mozc_engine.h:73
+msgid "Shared Input State"
+msgstr ""
+
+#: mozc_engine.h:75
+msgid "Vertical candidate list"
+msgstr ""
diff --git a/src/unix/fcitx5/po/ja.po b/src/unix/fcitx5/po/ja.po
new file mode 100644
index 0000000..f1ae1b8
--- /dev/null
+++ b/src/unix/fcitx5/po/ja.po
@@ -0,0 +1,140 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the fcitx5-mozc package.
+#
+# Translators:
+# csslayer <wengxt@gmail.com>, 2017
+# UTUMI Hirosi <utuhiro78@yahoo.co.jp>, 2023
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: fcitx5-mozc\n"
+"Report-Msgid-Bugs-To: fcitx-dev@googlegroups.com\n"
+"POT-Creation-Date: 2023-09-21 20:24+0000\n"
+"PO-Revision-Date: 2017-11-23 05:28+0000\n"
+"Last-Translator: UTUMI Hirosi <utuhiro78@yahoo.co.jp>, 2023\n"
+"Language-Team: Japanese (https://app.transifex.com/fcitx/teams/12005/ja/)\n"
+"Language: ja\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=1; plural=0;\n"
+
+#: mozc_engine.h:94 mozc_engine.cc:198
+msgid "About Mozc"
+msgstr "Mozc について"
+
+#: mozc_engine.h:92 mozc_engine.cc:191
+msgid "Add Word"
+msgstr "単語を追加"
+
+#: mozc_engine.h:52
+msgid "All"
+msgstr "すべて"
+
+#: mozc_engine.h:55
+msgid "Always"
+msgstr "常に"
+
+#: mozc_engine.h:88 mozc_engine.cc:175
+msgid "Configuration Tool"
+msgstr "設定ツール"
+
+#: mozc_engine.h:90 mozc_engine.cc:183
+msgid "Dictionary Tool"
+msgstr "辞書ツール"
+
+#: mozc_engine.h:58 mozc_engine.cc:54
+msgid "Direct"
+msgstr "直接入力"
+
+#: mozc_engine.h:79
+msgid "Expand Usage (Requires vertical candidate list)"
+msgstr "用例の表示 (候補が縦並びのとき)"
+
+#: mozc_engine.h:83
+msgid "Fix embedded preedit cursor at the beginning of the preedit"
+msgstr "プリエディットカーソルをプリエディットの先頭に固定する"
+
+#: mozc_engine.h:52
+msgid "Follow Global Configuration"
+msgstr "グローバル設定に従う"
+
+#. Full width ASCII letter A.
+#: mozc_engine.h:60 mozc_engine.cc:84
+msgid "Full ASCII"
+msgstr "全角英数"
+
+#. Katakana letter A.
+#: mozc_engine.h:59 mozc_engine.cc:68
+msgid "Full Katakana"
+msgstr "全角カナ"
+
+#: mozc_engine.h:59 mozc_engine.cc:76
+msgid "Half ASCII"
+msgstr "半角英数"
+
+#. Half width Katakana letter A.
+#: mozc_engine.h:60 mozc_engine.cc:91
+msgid "Half Katakana"
+msgstr "半角カナ"
+
+#. Hiragana letter A in UTF-8.
+#: mozc_engine.h:58 mozc_engine.cc:61
+msgid "Hiragana"
+msgstr "全角かな"
+
+#: mozc_engine.h:56
+msgid "Hotkey"
+msgstr "ホットキー"
+
+#: mozc_engine.h:85
+msgid "Hotkey to expand usage"
+msgstr "用例を表示するホットキー"
+
+#: mozc_engine.h:70
+msgid "Initial Mode"
+msgstr "初期モード"
+
+#: org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in:8
+msgid "Japanese input method based on Mozc"
+msgstr "Mozc をベースとした日本語入力メソッド"
+
+#: mozc_engine.cc:147 mozc_engine.cc:148
+msgid "Mozc Settings"
+msgstr "Mozc の設定"
+
+#: org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in:7
+msgid "Mozc for Fcitx 5"
+msgstr "Fcitx 5 用の Mozc"
+
+#: mozc_engine.h:53
+msgid "No"
+msgstr "しない"
+
+#: mozc_engine.h:55
+msgid "On Focus"
+msgstr "フォーカス時"
+
+#. We don't have a good library option for this, just do the simple
+#. replace. absl's runtime parsed format string is too copmlex.
+#: mozc_response_parser.cc:175
+#, c-format
+msgid "Press %s to show usages."
+msgstr "%s で用例表示"
+
+#: mozc_state.cc:426
+msgid "Press Escape to go back"
+msgstr "Esc キーを押して戻る"
+
+#: mozc_engine.h:53
+msgid "Program"
+msgstr "プログラム"
+
+#: mozc_engine.h:73
+msgid "Shared Input State"
+msgstr "入力状態の共有"
+
+#: mozc_engine.h:75
+msgid "Vertical candidate list"
+msgstr "候補を縦に並べる"
diff --git a/src/unix/fcitx5/po/ko.po b/src/unix/fcitx5/po/ko.po
new file mode 100644
index 0000000..246dbc5
--- /dev/null
+++ b/src/unix/fcitx5/po/ko.po
@@ -0,0 +1,141 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the fcitx5-mozc package.
+#
+# Translators:
+# csslayer <wengxt@gmail.com>, 2017
+# Bon Keun Seo <scobyseo@gmail.com>, 2021
+# JungHee Lee <daemul72@gmail.com>, 2022
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: fcitx5-mozc\n"
+"Report-Msgid-Bugs-To: fcitx-dev@googlegroups.com\n"
+"POT-Creation-Date: 2023-09-20 20:24+0000\n"
+"PO-Revision-Date: 2017-11-23 05:28+0000\n"
+"Last-Translator: JungHee Lee <daemul72@gmail.com>, 2022\n"
+"Language-Team: Korean (https://app.transifex.com/fcitx/teams/12005/ko/)\n"
+"Language: ko\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=1; plural=0;\n"
+
+#: mozc_engine.h:94 mozc_engine.cc:198
+msgid "About Mozc"
+msgstr "Mozc 정보"
+
+#: mozc_engine.h:92 mozc_engine.cc:191
+msgid "Add Word"
+msgstr "단어 추가"
+
+#: mozc_engine.h:52
+msgid "All"
+msgstr ""
+
+#: mozc_engine.h:55
+msgid "Always"
+msgstr "항상"
+
+#: mozc_engine.h:88 mozc_engine.cc:175
+msgid "Configuration Tool"
+msgstr "구성 도구"
+
+#: mozc_engine.h:90 mozc_engine.cc:183
+msgid "Dictionary Tool"
+msgstr "사전 도구"
+
+#: mozc_engine.h:58 mozc_engine.cc:54
+msgid "Direct"
+msgstr "직접"
+
+#: mozc_engine.h:79
+msgid "Expand Usage (Requires vertical candidate list)"
+msgstr "어법 확장 (세로 후보 목록 필요)"
+
+#: mozc_engine.h:83
+msgid "Fix embedded preedit cursor at the beginning of the preedit"
+msgstr "사전편집 시작 부분에 포함된 사전편집 커서 수정"
+
+#: mozc_engine.h:52
+msgid "Follow Global Configuration"
+msgstr ""
+
+#. Full width ASCII letter A.
+#: mozc_engine.h:60 mozc_engine.cc:84
+msgid "Full ASCII"
+msgstr "전각 아스키"
+
+#. Katakana letter A.
+#: mozc_engine.h:59 mozc_engine.cc:68
+msgid "Full Katakana"
+msgstr "전각 가타카나"
+
+#: mozc_engine.h:59 mozc_engine.cc:76
+msgid "Half ASCII"
+msgstr "반각 아스키"
+
+#. Half width Katakana letter A.
+#: mozc_engine.h:60 mozc_engine.cc:91
+msgid "Half Katakana"
+msgstr "반각 가타카나"
+
+#. Hiragana letter A in UTF-8.
+#: mozc_engine.h:58 mozc_engine.cc:61
+msgid "Hiragana"
+msgstr "히라가나"
+
+#: mozc_engine.h:56
+msgid "Hotkey"
+msgstr "단축키"
+
+#: mozc_engine.h:85
+msgid "Hotkey to expand usage"
+msgstr "사용을 확장할 단축키"
+
+#: mozc_engine.h:70
+msgid "Initial Mode"
+msgstr "초기 모드"
+
+#: org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in:8
+msgid "Japanese input method based on Mozc"
+msgstr "Mozc 기반 일본어 입력기"
+
+#: mozc_engine.cc:147 mozc_engine.cc:148
+msgid "Mozc Settings"
+msgstr "Mozc 설정"
+
+#: org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in:7
+msgid "Mozc for Fcitx 5"
+msgstr "Fcitx5용 Mozc"
+
+#: mozc_engine.h:53
+msgid "No"
+msgstr ""
+
+#: mozc_engine.h:55
+msgid "On Focus"
+msgstr "초점 맞추기"
+
+#. We don't have a good library option for this, just do the simple
+#. replace. absl's runtime parsed format string is too copmlex.
+#: mozc_response_parser.cc:175
+#, c-format
+msgid "Press %s to show usages."
+msgstr "%s 키를 눌러 사용법을 표시합니다."
+
+#: mozc_state.cc:426
+msgid "Press Escape to go back"
+msgstr "돌아가려면 Esc 키를 눌러 취소합니다"
+
+#: mozc_engine.h:53
+msgid "Program"
+msgstr ""
+
+#: mozc_engine.h:73
+msgid "Shared Input State"
+msgstr ""
+
+#: mozc_engine.h:75
+msgid "Vertical candidate list"
+msgstr "세로 후보 목록"
diff --git a/src/unix/fcitx5/po/ru.po b/src/unix/fcitx5/po/ru.po
new file mode 100644
index 0000000..c94566f
--- /dev/null
+++ b/src/unix/fcitx5/po/ru.po
@@ -0,0 +1,143 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the fcitx5-mozc package.
+#
+# Translators:
+# csslayer <wengxt@gmail.com>, 2017
+# Dmitry <dmitrydmitry761@gmail.com>, 2024
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: fcitx5-mozc\n"
+"Report-Msgid-Bugs-To: fcitx-dev@googlegroups.com\n"
+"POT-Creation-Date: 2024-05-31 20:24+0000\n"
+"PO-Revision-Date: 2017-11-23 05:28+0000\n"
+"Last-Translator: Dmitry <dmitrydmitry761@gmail.com>, 2024\n"
+"Language-Team: Russian (https://app.transifex.com/fcitx/teams/12005/ru/)\n"
+"Language: ru\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
+"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
+"(n%100>=11 && n%100<=14)? 2 : 3);\n"
+
+#: mozc_engine.h:107 mozc_engine.cc:209
+msgid "About Mozc"
+msgstr "О Mozc"
+
+#: mozc_engine.h:105 mozc_engine.cc:202
+msgid "Add Word"
+msgstr "Добавить слово"
+
+#: mozc_engine.h:65
+msgid "All"
+msgstr "Все"
+
+#: mozc_engine.h:68
+msgid "Always"
+msgstr "Всегда"
+
+#: mozc_engine.h:101 mozc_engine.cc:186
+msgid "Configuration Tool"
+msgstr "Инструмент настройки"
+
+#: mozc_engine.h:103 mozc_engine.cc:194
+msgid "Dictionary Tool"
+msgstr "Инструмент словаря"
+
+#: mozc_engine.h:71 mozc_engine.cc:65
+msgid "Direct"
+msgstr "Непосредственный"
+
+#: mozc_engine.h:92
+msgid "Expand Usage (Requires vertical candidate list)"
+msgstr "Расширить использование (требуется вертикальный список кандидатов)"
+
+#: mozc_engine.h:96
+msgid "Fix embedded preedit cursor at the beginning of the preedit"
+msgstr ""
+"Зафиксировать встроенный курсор предварительного редактирования в начале."
+
+#: mozc_engine.h:65
+msgid "Follow Global Configuration"
+msgstr "Следовать глобальной конфигурации"
+
+#. Full width ASCII letter A.
+#: mozc_engine.h:73 mozc_engine.cc:95
+msgid "Full ASCII"
+msgstr "Полноширинная ASCII"
+
+#. Katakana letter A.
+#: mozc_engine.h:72 mozc_engine.cc:79
+msgid "Full Katakana"
+msgstr "Полная Катакана"
+
+#: mozc_engine.h:72 mozc_engine.cc:87
+msgid "Half ASCII"
+msgstr "Полуширинная ASCII"
+
+#. Half width Katakana letter A.
+#: mozc_engine.h:73 mozc_engine.cc:102
+msgid "Half Katakana"
+msgstr "Полуширинная Катакана"
+
+#. Hiragana letter A in UTF-8.
+#: mozc_engine.h:71 mozc_engine.cc:72
+msgid "Hiragana"
+msgstr "Хирагана"
+
+#: mozc_engine.h:69
+msgid "Hotkey"
+msgstr "Горячая клавиша"
+
+#: mozc_engine.h:98
+msgid "Hotkey to expand usage"
+msgstr "Горячая клавиша для расширения использования"
+
+#: mozc_engine.h:83
+msgid "Initial Mode"
+msgstr "Начальный режим"
+
+#: org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in:8
+msgid "Japanese input method based on Mozc"
+msgstr "Японский метод ввода на основе Mozc"
+
+#: mozc_engine.cc:158 mozc_engine.cc:159
+msgid "Mozc Settings"
+msgstr "Настройки Mozc"
+
+#: org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in:7
+msgid "Mozc for Fcitx 5"
+msgstr "Mozc для Fcitx 5"
+
+#: mozc_engine.h:66
+msgid "No"
+msgstr "Нет"
+
+#: mozc_engine.h:68
+msgid "On Focus"
+msgstr "В фокусе"
+
+#. We don't have a good library option for this, just do the simple
+#. replace. absl's runtime parsed format string is too copmlex.
+#: mozc_response_parser.cc:189
+#, c-format
+msgid "Press %s to show usages."
+msgstr "Нажмите %s , чтобы показать использование."
+
+#: mozc_state.cc:462
+msgid "Press Escape to go back"
+msgstr "Нажмите Escape, чтобы вернуться назад"
+
+#: mozc_engine.h:66
+msgid "Program"
+msgstr "Программа"
+
+#: mozc_engine.h:86
+msgid "Shared Input State"
+msgstr "Общее состояние ввода"
+
+#: mozc_engine.h:88
+msgid "Vertical candidate list"
+msgstr "Вертикальный список кандидатов"
diff --git a/src/unix/fcitx5/po/tr.po b/src/unix/fcitx5/po/tr.po
new file mode 100644
index 0000000..83fbc98
--- /dev/null
+++ b/src/unix/fcitx5/po/tr.po
@@ -0,0 +1,139 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the fcitx5-mozc package.
+#
+# Translators:
+# abc Def <hdogan1974@gmail.com>, 2021
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: fcitx5-mozc\n"
+"Report-Msgid-Bugs-To: fcitx-dev@googlegroups.com\n"
+"POT-Creation-Date: 2023-09-20 20:24+0000\n"
+"PO-Revision-Date: 2017-11-23 05:28+0000\n"
+"Last-Translator: abc Def <hdogan1974@gmail.com>, 2021\n"
+"Language-Team: Turkish (https://app.transifex.com/fcitx/teams/12005/tr/)\n"
+"Language: tr\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n > 1);\n"
+
+#: mozc_engine.h:94 mozc_engine.cc:198
+msgid "About Mozc"
+msgstr "Mozc Hakkında"
+
+#: mozc_engine.h:92 mozc_engine.cc:191
+msgid "Add Word"
+msgstr "Kelime Ekle"
+
+#: mozc_engine.h:52
+msgid "All"
+msgstr ""
+
+#: mozc_engine.h:55
+msgid "Always"
+msgstr ""
+
+#: mozc_engine.h:88 mozc_engine.cc:175
+msgid "Configuration Tool"
+msgstr ""
+
+#: mozc_engine.h:90 mozc_engine.cc:183
+msgid "Dictionary Tool"
+msgstr ""
+
+#: mozc_engine.h:58 mozc_engine.cc:54
+msgid "Direct"
+msgstr ""
+
+#: mozc_engine.h:79
+msgid "Expand Usage (Requires vertical candidate list)"
+msgstr ""
+
+#: mozc_engine.h:83
+msgid "Fix embedded preedit cursor at the beginning of the preedit"
+msgstr ""
+
+#: mozc_engine.h:52
+msgid "Follow Global Configuration"
+msgstr ""
+
+#. Full width ASCII letter A.
+#: mozc_engine.h:60 mozc_engine.cc:84
+msgid "Full ASCII"
+msgstr ""
+
+#. Katakana letter A.
+#: mozc_engine.h:59 mozc_engine.cc:68
+msgid "Full Katakana"
+msgstr ""
+
+#: mozc_engine.h:59 mozc_engine.cc:76
+msgid "Half ASCII"
+msgstr ""
+
+#. Half width Katakana letter A.
+#: mozc_engine.h:60 mozc_engine.cc:91
+msgid "Half Katakana"
+msgstr ""
+
+#. Hiragana letter A in UTF-8.
+#: mozc_engine.h:58 mozc_engine.cc:61
+msgid "Hiragana"
+msgstr ""
+
+#: mozc_engine.h:56
+msgid "Hotkey"
+msgstr ""
+
+#: mozc_engine.h:85
+msgid "Hotkey to expand usage"
+msgstr ""
+
+#: mozc_engine.h:70
+msgid "Initial Mode"
+msgstr ""
+
+#: org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in:8
+msgid "Japanese input method based on Mozc"
+msgstr ""
+
+#: mozc_engine.cc:147 mozc_engine.cc:148
+msgid "Mozc Settings"
+msgstr ""
+
+#: org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in:7
+msgid "Mozc for Fcitx 5"
+msgstr ""
+
+#: mozc_engine.h:53
+msgid "No"
+msgstr ""
+
+#: mozc_engine.h:55
+msgid "On Focus"
+msgstr ""
+
+#. We don't have a good library option for this, just do the simple
+#. replace. absl's runtime parsed format string is too copmlex.
+#: mozc_response_parser.cc:175
+#, c-format
+msgid "Press %s to show usages."
+msgstr ""
+
+#: mozc_state.cc:426
+msgid "Press Escape to go back"
+msgstr ""
+
+#: mozc_engine.h:53
+msgid "Program"
+msgstr ""
+
+#: mozc_engine.h:73
+msgid "Shared Input State"
+msgstr ""
+
+#: mozc_engine.h:75
+msgid "Vertical candidate list"
+msgstr ""
diff --git a/src/unix/fcitx5/po/vi.po b/src/unix/fcitx5/po/vi.po
new file mode 100644
index 0000000..962789d
--- /dev/null
+++ b/src/unix/fcitx5/po/vi.po
@@ -0,0 +1,139 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the fcitx5-mozc package.
+#
+# Translators:
+# hoanghuy309 <hoanghuy309@gmail.com>, 2025
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: fcitx5-mozc\n"
+"Report-Msgid-Bugs-To: fcitx-dev@googlegroups.com\n"
+"POT-Creation-Date: 2025-04-22 20:24+0000\n"
+"PO-Revision-Date: 2017-11-23 05:28+0000\n"
+"Last-Translator: hoanghuy309 <hoanghuy309@gmail.com>, 2025\n"
+"Language-Team: Vietnamese (https://app.transifex.com/fcitx/teams/12005/vi/)\n"
+"Language: vi\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=1; plural=0;\n"
+
+#: mozc_engine.h:106 mozc_engine.cc:208
+msgid "About Mozc"
+msgstr ""
+
+#: mozc_engine.h:104 mozc_engine.cc:201
+msgid "Add Word"
+msgstr ""
+
+#: mozc_engine.h:64
+msgid "All"
+msgstr "Tất cả"
+
+#: mozc_engine.h:67
+msgid "Always"
+msgstr ""
+
+#: mozc_engine.h:100 mozc_engine.cc:185
+msgid "Configuration Tool"
+msgstr "Công Cụ Cấu Hình"
+
+#: mozc_engine.h:102 mozc_engine.cc:193
+msgid "Dictionary Tool"
+msgstr ""
+
+#: mozc_engine.h:70 mozc_engine.cc:66
+msgid "Direct"
+msgstr ""
+
+#: mozc_engine.h:91
+msgid "Expand Usage (Requires vertical candidate list)"
+msgstr ""
+
+#: mozc_engine.h:95
+msgid "Fix embedded preedit cursor at the beginning of the preedit"
+msgstr ""
+
+#: mozc_engine.h:64
+msgid "Follow Global Configuration"
+msgstr "Theo Cấu Hình Chung"
+
+#. Full width ASCII letter A.
+#: mozc_engine.h:72 mozc_engine.cc:96
+msgid "Full ASCII"
+msgstr ""
+
+#. Katakana letter A.
+#: mozc_engine.h:71 mozc_engine.cc:80
+msgid "Full Katakana"
+msgstr ""
+
+#: mozc_engine.h:71 mozc_engine.cc:88
+msgid "Half ASCII"
+msgstr ""
+
+#. Half width Katakana letter A.
+#: mozc_engine.h:72 mozc_engine.cc:103
+msgid "Half Katakana"
+msgstr ""
+
+#. Hiragana letter A in UTF-8.
+#: mozc_engine.h:70 mozc_engine.cc:73
+msgid "Hiragana"
+msgstr ""
+
+#: mozc_engine.h:68
+msgid "Hotkey"
+msgstr ""
+
+#: mozc_engine.h:97
+msgid "Hotkey to expand usage"
+msgstr ""
+
+#: mozc_engine.h:82
+msgid "Initial Mode"
+msgstr ""
+
+#: org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in:8
+msgid "Japanese input method based on Mozc"
+msgstr "Kiểu gõ Tiếng Nhật dựa trên Mozc"
+
+#: mozc_engine.cc:157 mozc_engine.cc:158
+msgid "Mozc Settings"
+msgstr ""
+
+#: org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in:7
+msgid "Mozc for Fcitx 5"
+msgstr ""
+
+#: mozc_engine.h:65
+msgid "No"
+msgstr ""
+
+#: mozc_engine.h:67
+msgid "On Focus"
+msgstr ""
+
+#. We don't have a good library option for this, just do the simple
+#. replace. absl's runtime parsed format string is too copmlex.
+#: mozc_response_parser.cc:189
+#, c-format
+msgid "Press %s to show usages."
+msgstr ""
+
+#: mozc_state.cc:460
+msgid "Press Escape to go back"
+msgstr ""
+
+#: mozc_engine.h:65
+msgid "Program"
+msgstr ""
+
+#: mozc_engine.h:85
+msgid "Shared Input State"
+msgstr ""
+
+#: mozc_engine.h:87
+msgid "Vertical candidate list"
+msgstr ""
diff --git a/src/unix/fcitx5/po/zh_CN.po b/src/unix/fcitx5/po/zh_CN.po
new file mode 100644
index 0000000..9c5bcab
--- /dev/null
+++ b/src/unix/fcitx5/po/zh_CN.po
@@ -0,0 +1,140 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the fcitx5-mozc package.
+#
+# Translators:
+# csslayer <wengxt@gmail.com>, 2023
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: fcitx5-mozc\n"
+"Report-Msgid-Bugs-To: fcitx-dev@googlegroups.com\n"
+"POT-Creation-Date: 2023-09-23 20:24+0000\n"
+"PO-Revision-Date: 2017-11-23 05:28+0000\n"
+"Last-Translator: csslayer <wengxt@gmail.com>, 2023\n"
+"Language-Team: Chinese (China) (https://app.transifex.com/fcitx/teams/12005/"
+"zh_CN/)\n"
+"Language: zh_CN\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=1; plural=0;\n"
+
+#: mozc_engine.h:94 mozc_engine.cc:198
+msgid "About Mozc"
+msgstr "关于 Mozc"
+
+#: mozc_engine.h:92 mozc_engine.cc:191
+msgid "Add Word"
+msgstr "添加词组"
+
+#: mozc_engine.h:52
+msgid "All"
+msgstr "所有"
+
+#: mozc_engine.h:55
+msgid "Always"
+msgstr "总是"
+
+#: mozc_engine.h:88 mozc_engine.cc:175
+msgid "Configuration Tool"
+msgstr "配置工具"
+
+#: mozc_engine.h:90 mozc_engine.cc:183
+msgid "Dictionary Tool"
+msgstr "词典工具"
+
+#: mozc_engine.h:58 mozc_engine.cc:54
+msgid "Direct"
+msgstr "直接键盘输入"
+
+#: mozc_engine.h:79
+msgid "Expand Usage (Requires vertical candidate list)"
+msgstr "展开用法 (需要垂直候选列表)"
+
+#: mozc_engine.h:83
+msgid "Fix embedded preedit cursor at the beginning of the preedit"
+msgstr "固定嵌入预编辑文本光标在预编辑的开头"
+
+#: mozc_engine.h:52
+msgid "Follow Global Configuration"
+msgstr "跟随全局配置"
+
+#. Full width ASCII letter A.
+#: mozc_engine.h:60 mozc_engine.cc:84
+msgid "Full ASCII"
+msgstr "全角 ASCII"
+
+#. Katakana letter A.
+#: mozc_engine.h:59 mozc_engine.cc:68
+msgid "Full Katakana"
+msgstr "全角片假名"
+
+#: mozc_engine.h:59 mozc_engine.cc:76
+msgid "Half ASCII"
+msgstr "半角 ASCII"
+
+#. Half width Katakana letter A.
+#: mozc_engine.h:60 mozc_engine.cc:91
+msgid "Half Katakana"
+msgstr "半角片假名"
+
+#. Hiragana letter A in UTF-8.
+#: mozc_engine.h:58 mozc_engine.cc:61
+msgid "Hiragana"
+msgstr "平假名"
+
+#: mozc_engine.h:56
+msgid "Hotkey"
+msgstr "快捷键"
+
+#: mozc_engine.h:85
+msgid "Hotkey to expand usage"
+msgstr "展开用法的快捷键"
+
+#: mozc_engine.h:70
+msgid "Initial Mode"
+msgstr "初始模式"
+
+#: org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in:8
+msgid "Japanese input method based on Mozc"
+msgstr "基于 Mozc 的日语输入法"
+
+#: mozc_engine.cc:147 mozc_engine.cc:148
+msgid "Mozc Settings"
+msgstr "Mozc 设置"
+
+#: org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in:7
+msgid "Mozc for Fcitx 5"
+msgstr "Fcitx 5 的 Mozc 支持"
+
+#: mozc_engine.h:53
+msgid "No"
+msgstr "否"
+
+#: mozc_engine.h:55
+msgid "On Focus"
+msgstr "选中时"
+
+#. We don't have a good library option for this, just do the simple
+#. replace. absl's runtime parsed format string is too copmlex.
+#: mozc_response_parser.cc:175
+#, c-format
+msgid "Press %s to show usages."
+msgstr "按下 %s 显示用法。"
+
+#: mozc_state.cc:425
+msgid "Press Escape to go back"
+msgstr "按 Escape 返回"
+
+#: mozc_engine.h:53
+msgid "Program"
+msgstr "程序"
+
+#: mozc_engine.h:73
+msgid "Shared Input State"
+msgstr "共享输入状态"
+
+#: mozc_engine.h:75
+msgid "Vertical candidate list"
+msgstr "垂直候选列表"
diff --git a/src/unix/fcitx5/po/zh_TW.po b/src/unix/fcitx5/po/zh_TW.po
new file mode 100644
index 0000000..a6d0845
--- /dev/null
+++ b/src/unix/fcitx5/po/zh_TW.po
@@ -0,0 +1,144 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the fcitx5-mozc package.
+#
+# Translators:
+# csslayer <wengxt@gmail.com>, 2017
+# bruh, 2020
+# Neko ◣ 0xFF, 2022
+# Yiyu Liu, 2023
+# Kisaragi Hiu <flyingfeather1501@gmail.com>, 2024
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: fcitx5-mozc\n"
+"Report-Msgid-Bugs-To: fcitx-dev@googlegroups.com\n"
+"POT-Creation-Date: 2024-07-08 20:24+0000\n"
+"PO-Revision-Date: 2017-11-23 05:28+0000\n"
+"Last-Translator: Kisaragi Hiu <flyingfeather1501@gmail.com>, 2024\n"
+"Language-Team: Chinese (Taiwan) (https://app.transifex.com/fcitx/teams/12005/"
+"zh_TW/)\n"
+"Language: zh_TW\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=1; plural=0;\n"
+
+#: mozc_engine.h:107 mozc_engine.cc:209
+msgid "About Mozc"
+msgstr "關於 Mozc"
+
+#: mozc_engine.h:105 mozc_engine.cc:202
+msgid "Add Word"
+msgstr "添加單詞"
+
+#: mozc_engine.h:65
+msgid "All"
+msgstr "所有"
+
+#: mozc_engine.h:68
+msgid "Always"
+msgstr "總是"
+
+#: mozc_engine.h:101 mozc_engine.cc:186
+msgid "Configuration Tool"
+msgstr "設定工具"
+
+#: mozc_engine.h:103 mozc_engine.cc:194
+msgid "Dictionary Tool"
+msgstr "字典工具"
+
+#: mozc_engine.h:71 mozc_engine.cc:65
+msgid "Direct"
+msgstr "直接鍵盤輸入"
+
+#: mozc_engine.h:92
+msgid "Expand Usage (Requires vertical candidate list)"
+msgstr "擴展使用 (需要垂直候選列表)"
+
+#: mozc_engine.h:96
+msgid "Fix embedded preedit cursor at the beginning of the preedit"
+msgstr "將內嵌預編輯游標位置固定在預編輯的開頭"
+
+#: mozc_engine.h:65
+msgid "Follow Global Configuration"
+msgstr "跟隨全域配置"
+
+#. Full width ASCII letter A.
+#: mozc_engine.h:73 mozc_engine.cc:95
+msgid "Full ASCII"
+msgstr "全形 ASCII"
+
+#. Katakana letter A.
+#: mozc_engine.h:72 mozc_engine.cc:79
+msgid "Full Katakana"
+msgstr "全形片假名"
+
+#: mozc_engine.h:72 mozc_engine.cc:87
+msgid "Half ASCII"
+msgstr "半形 ASCII"
+
+#. Half width Katakana letter A.
+#: mozc_engine.h:73 mozc_engine.cc:102
+msgid "Half Katakana"
+msgstr "半形片假名"
+
+#. Hiragana letter A in UTF-8.
+#: mozc_engine.h:71 mozc_engine.cc:72
+msgid "Hiragana"
+msgstr "平假名"
+
+#: mozc_engine.h:69
+msgid "Hotkey"
+msgstr "快捷鍵"
+
+#: mozc_engine.h:98
+msgid "Hotkey to expand usage"
+msgstr "展開用法的快捷鍵"
+
+#: mozc_engine.h:83
+msgid "Initial Mode"
+msgstr "初始模式"
+
+#: org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in:8
+msgid "Japanese input method based on Mozc"
+msgstr "基於 Mozc 的日語輸入法"
+
+#: mozc_engine.cc:158 mozc_engine.cc:159
+msgid "Mozc Settings"
+msgstr "Mozc 設定"
+
+#: org.fcitx.Fcitx5.Addon.Mozc.metainfo.xml.in:7
+msgid "Mozc for Fcitx 5"
+msgstr "Fcitx 5 的 Mozc 支援"
+
+#: mozc_engine.h:66
+msgid "No"
+msgstr "否"
+
+#: mozc_engine.h:68
+msgid "On Focus"
+msgstr "聚焦時"
+
+#. We don't have a good library option for this, just do the simple
+#. replace. absl's runtime parsed format string is too copmlex.
+#: mozc_response_parser.cc:189
+#, c-format
+msgid "Press %s to show usages."
+msgstr "按下 %s 顯示用法。"
+
+#: mozc_state.cc:462
+msgid "Press Escape to go back"
+msgstr "按下 Escape 返回"
+
+#: mozc_engine.h:66
+msgid "Program"
+msgstr "程式"
+
+#: mozc_engine.h:86
+msgid "Shared Input State"
+msgstr "共享輸入狀態"
+
+#: mozc_engine.h:88
+msgid "Vertical candidate list"
+msgstr "垂直候選字列表"
diff --git a/src/unix/fcitx5/surrounding_text_util.cc b/src/unix/fcitx5/surrounding_text_util.cc
new file mode 100644
index 0000000..68bf40e
--- /dev/null
+++ b/src/unix/fcitx5/surrounding_text_util.cc
@@ -0,0 +1,227 @@
+// Copyright 2010-2013, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "unix/fcitx5/surrounding_text_util.h"
+
+#include <fcitx-module/clipboard/clipboard_public.h>
+#include <fcitx-utils/capabilityflags.h>
+#include <fcitx/inputcontext.h>
+
+#include <algorithm>
+#include <cstddef>
+#include <cstdint>
+#include <cstdlib>
+#include <limits>
+#include <string>
+
+#include "absl/log/check.h"
+#include "absl/log/log.h"
+#include "base/util.h"
+
+namespace fcitx {
+
+using namespace mozc;
+
+bool SurroundingTextUtil::GetSafeDelta(unsigned int from, unsigned int to,
+                                       int32_t *delta) {
+  DCHECK(delta);
+
+  static_assert(sizeof(int64_t) >= sizeof(unsigned int),
+                "int64_t must be sufficient to store a unsigned int value.");
+  static_assert(sizeof(int64_t) == sizeof(llabs(0)),
+                "|llabs(0)| must returns a 64-bit integer.");
+  const int64_t kInt32AbsMax =
+      llabs(static_cast<int64_t>(std::numeric_limits<int32_t>::max()));
+  const int64_t kInt32AbsMin =
+      llabs(static_cast<int64_t>(std::numeric_limits<int32_t>::min()));
+  const int64_t kInt32SafeAbsMax = std::min(kInt32AbsMax, kInt32AbsMin);
+
+  const int64_t diff = static_cast<int64_t>(from) - static_cast<int64_t>(to);
+  if (llabs(diff) > kInt32SafeAbsMax) {
+    return false;
+  }
+
+  *delta = static_cast<int32_t>(diff);
+  return true;
+}
+
+namespace {
+
+// Moves |iter| with |skip_count| characters.
+// Returns false if |iter| reaches to the end before skipping
+// |skip_count| characters.
+bool Skip(ConstChar32Iterator *iter, size_t skip_count) {
+  for (size_t i = 0; i < skip_count; ++i) {
+    if (iter->Done()) {
+      return false;
+    }
+    iter->Next();
+  }
+  return true;
+}
+
+// Returns true if |prefix_iter| is the prefix of |iter|.
+// Returns false if |prefix_iter| is an empty sequence.
+// Otherwise returns false.
+// This function receives ConstChar32Iterator as pointer because
+// ConstChar32Iterator is defined as non-copyable.
+bool StartsWith(ConstChar32Iterator *iter, ConstChar32Iterator *prefix_iter) {
+  if (iter->Done() || prefix_iter->Done()) {
+    return false;
+  }
+
+  while (true) {
+    if (iter->Get() != prefix_iter->Get()) {
+      return false;
+    }
+    prefix_iter->Next();
+    if (prefix_iter->Done()) {
+      return true;
+    }
+    iter->Next();
+    if (iter->Done()) {
+      return false;
+    }
+  }
+}
+
+// Returns true if |surrounding_text| contains |selected_text|
+// from |cursor_pos| to |*anchor_pos|.
+// Otherwise returns false.
+bool SearchAnchorPosForward(const std::string &surrounding_text,
+                            const std::string &selected_text,
+                            size_t selected_chars_len, unsigned int cursor_pos,
+                            unsigned int *anchor_pos) {
+  ConstChar32Iterator iter(surrounding_text);
+  // Move |iter| to cursor pos.
+  if (!Skip(&iter, cursor_pos)) {
+    return false;
+  }
+
+  ConstChar32Iterator sel_iter(selected_text);
+  if (!StartsWith(&iter, &sel_iter)) {
+    return false;
+  }
+  *anchor_pos = cursor_pos + selected_chars_len;
+  return true;
+}
+
+// Returns true if |surrounding_text| contains |selected_text|
+// from |*anchor_pos| to |cursor_pos|.
+// Otherwise returns false.
+bool SearchAnchorPosBackward(const std::string &surrounding_text,
+                             const std::string &selected_text,
+                             size_t selected_chars_len, unsigned int cursor_pos,
+                             unsigned int *anchor_pos) {
+  if (cursor_pos < selected_chars_len) {
+    return false;
+  }
+
+  ConstChar32Iterator iter(surrounding_text);
+  // Skip |iter| to (potential) anchor pos.
+  const unsigned int skip_count = cursor_pos - selected_chars_len;
+  DCHECK_LE(skip_count, cursor_pos);
+  if (!Skip(&iter, skip_count)) {
+    return false;
+  }
+
+  ConstChar32Iterator sel_iter(selected_text);
+  if (!StartsWith(&iter, &sel_iter)) {
+    return false;
+  }
+  *anchor_pos = cursor_pos - selected_chars_len;
+  return true;
+}
+
+}  // namespace
+
+bool SurroundingTextUtil::GetAnchorPosFromSelection(
+    const std::string &surrounding_text, const std::string &selected_text,
+    unsigned int cursor_pos, unsigned int *anchor_pos) {
+  DCHECK(anchor_pos);
+
+  if (surrounding_text.empty()) {
+    return false;
+  }
+
+  if (selected_text.empty()) {
+    return false;
+  }
+
+  const size_t selected_chars_len = Util::CharsLen(selected_text);
+
+  if (SearchAnchorPosForward(surrounding_text, selected_text,
+                             selected_chars_len, cursor_pos, anchor_pos)) {
+    return true;
+  }
+
+  return SearchAnchorPosBackward(surrounding_text, selected_text,
+                                 selected_chars_len, cursor_pos, anchor_pos);
+}
+
+bool GetSurroundingText(InputContext *ic, SurroundingTextInfo *info,
+                        AddonInstance *clipboard) {
+  if (!ic->capabilityFlags().test(CapabilityFlag::SurroundingText) ||
+      !ic->surroundingText().isValid()) {
+    return false;
+  }
+
+  const auto surrounding_text = ic->surroundingText().text();
+  unsigned int cursor_pos = ic->surroundingText().cursor();
+  unsigned int anchor_pos = ic->surroundingText().anchor();
+
+  if (cursor_pos == anchor_pos && clipboard) {
+    std::string primary = clipboard->call<IClipboard::primary>(ic);
+    if (!primary.empty()) {
+      unsigned int new_anchor_pos = 0;
+      if (SurroundingTextUtil::GetAnchorPosFromSelection(
+              surrounding_text, primary, cursor_pos, &new_anchor_pos)) {
+        anchor_pos = new_anchor_pos;
+      }
+    }
+  }
+
+  if (!SurroundingTextUtil::GetSafeDelta(cursor_pos, anchor_pos,
+                                         &info->relative_selected_length)) {
+    LOG(ERROR) << "Too long text selection.";
+    return false;
+  }
+
+  const size_t selection_start = std::min(cursor_pos, anchor_pos);
+  const size_t selection_length = std::abs(info->relative_selected_length);
+  info->preceding_text =
+      std::string(Util::Utf8SubString(surrounding_text, 0, selection_start));
+  info->selection_text = std::string(
+      Util::Utf8SubString(surrounding_text, selection_start, selection_length));
+  info->following_text = std::string(Util::Utf8SubString(
+      surrounding_text, selection_start + selection_length));
+  return true;
+}
+
+}  // namespace fcitx
diff --git a/src/unix/fcitx5/surrounding_text_util.h b/src/unix/fcitx5/surrounding_text_util.h
new file mode 100644
index 0000000..8370b74
--- /dev/null
+++ b/src/unix/fcitx5/surrounding_text_util.h
@@ -0,0 +1,83 @@
+// Copyright 2010-2013, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MOZC_UNIX_FCITX_SURROUNDING_TEXT_URIL_H_
+#define MOZC_UNIX_FCITX_SURROUNDING_TEXT_URIL_H_
+
+#include <fcitx/inputcontext.h>
+
+#include <cstdint>
+#include <string>
+
+namespace fcitx {
+
+class AddonInstance;
+
+struct SurroundingTextInfo {
+  int32_t relative_selected_length = 0;
+  std::string preceding_text;
+  std::string selection_text;
+  std::string following_text;
+};
+
+class SurroundingTextUtil {
+ public:
+  SurroundingTextUtil() = delete;
+  SurroundingTextUtil(const SurroundingTextUtil &) = delete;
+  SurroundingTextUtil &operator=(const SurroundingTextUtil &) = delete;
+  // Calculates |from| - |to| and stores the result into |delta| with
+  // checking integer overflow.
+  // Returns true when neither |abs(delta)| nor |-delta| does not cause
+  // integer overflow, that is, |delta| is in a safe range.
+  // Returns false otherwise.
+  static bool GetSafeDelta(unsigned int from, unsigned int to, int32_t *delta);
+
+  // Returns true if
+  // 1. |surrounding_text| contains |selected_text|
+  //    from |cursor_pos| to |*anchor_pos|.
+  // or,
+  // 2. |surrounding_text| contains |selected_text|
+  //    from |*anchor_pos| to |cursor_pos|.
+  // with calculating |*anchor_pos|,
+  // where |cursor_pos| and |*anchor_pos| are counts of Unicode characters.
+  // When both 1) and 2) are satisfied, this function calculates
+  // |*anchor_pos| for case 1).
+  // Otherwise returns false.
+  static bool GetAnchorPosFromSelection(const std::string &surrounding_text,
+                                        const std::string &selected_text,
+                                        unsigned int cursor_pos,
+                                        unsigned int *anchor_pos);
+};
+
+bool GetSurroundingText(InputContext *ic, SurroundingTextInfo *info,
+                        AddonInstance *clipboard);
+
+}  // namespace fcitx
+
+#endif  // MOZC_UNIX_FCITX_SURROUNDING_TEXT_URIL_H_
diff --git a/src/win32/tip/BUILD.bazel b/src/win32/tip/BUILD.bazel
index 7aa084e..ce5d3e8 100644
--- a/src/win32/tip/BUILD.bazel
+++ b/src/win32/tip/BUILD.bazel
@@ -231,9 +231,9 @@ mozc_cc_library(
     target_compatible_with = ["@platforms//os:windows"],
     deps = [
         ":tip_compartment_util",
+        "//base:absl_nullability",
         "//base/win32:com",
         "//base/win32:hresultor",
-        "@com_google_absl//absl/base:nullability",
         "@com_microsoft_wil//:wil",
     ],
 )
diff --git a/src/win32/tip/tip_transitory_extension.cc b/src/win32/tip/tip_transitory_extension.cc
index 39fd2d4..a481eae 100644
--- a/src/win32/tip/tip_transitory_extension.cc
+++ b/src/win32/tip/tip_transitory_extension.cc
@@ -34,7 +34,7 @@
 #include <wil/resource.h>
 #include <windows.h>
 
-#include "absl/base/nullability.h"
+#include "base/absl_nullability.h"
 #include "base/win32/com.h"
 #include "base/win32/hresultor.h"
 #include "win32/tip/tip_compartment_util.h"
